"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/esm/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/fast-equals/dist/esm/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nvar getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n/**\r\n * Combine two comparators into a single comparators.\r\n */\r\nfunction combineComparators(comparatorA, comparatorB) {\r\n    return function isEqual(a, b, state) {\r\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\r\n    };\r\n}\r\n/**\r\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\r\n * for circular references to be safely included in the comparison without creating\r\n * stack overflows.\r\n */\r\nfunction createIsCircular(areItemsEqual) {\r\n    return function isCircular(a, b, state) {\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return areItemsEqual(a, b, state);\r\n        }\r\n        var cache = state.cache;\r\n        var cachedA = cache.get(a);\r\n        var cachedB = cache.get(b);\r\n        if (cachedA && cachedB) {\r\n            return cachedA === b && cachedB === a;\r\n        }\r\n        cache.set(a, b);\r\n        cache.set(b, a);\r\n        var result = areItemsEqual(a, b, state);\r\n        cache.delete(a);\r\n        cache.delete(b);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Get the properties to strictly examine, which include both own properties that are\r\n * not enumerable and symbol properties.\r\n */\r\nfunction getStrictProperties(object) {\r\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\r\n}\r\n/**\r\n * Whether the object contains the property passed as an own property.\r\n */\r\nvar hasOwn = Object.hasOwn ||\r\n    (function (object, property) {\r\n        return hasOwnProperty.call(object, property);\r\n    });\r\n/**\r\n * Whether the values passed are strictly equal or both NaN.\r\n */\r\nfunction sameValueZeroEqual(a, b) {\r\n    return a === b || (!a && !b && a !== a && b !== b);\r\n}\r\n\r\nvar PREACT_VNODE = '__v';\r\nvar PREACT_OWNER = '__o';\r\nvar REACT_OWNER = '_owner';\r\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\r\n/**\r\n * Whether the arrays are equal in value.\r\n */\r\nfunction areArraysEqual(a, b, state) {\r\n    var index = a.length;\r\n    if (b.length !== index) {\r\n        return false;\r\n    }\r\n    while (index-- > 0) {\r\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the dates passed are equal in value.\r\n */\r\nfunction areDatesEqual(a, b) {\r\n    return sameValueZeroEqual(a.getTime(), b.getTime());\r\n}\r\n/**\r\n * Whether the errors passed are equal in value.\r\n */\r\nfunction areErrorsEqual(a, b) {\r\n    return (a.name === b.name &&\r\n        a.message === b.message &&\r\n        a.cause === b.cause &&\r\n        a.stack === b.stack);\r\n}\r\n/**\r\n * Whether the functions passed are equal in value.\r\n */\r\nfunction areFunctionsEqual(a, b) {\r\n    return a === b;\r\n}\r\n/**\r\n * Whether the `Map`s are equal in value.\r\n */\r\nfunction areMapsEqual(a, b, state) {\r\n    var size = a.size;\r\n    if (size !== b.size) {\r\n        return false;\r\n    }\r\n    if (!size) {\r\n        return true;\r\n    }\r\n    var matchedIndices = new Array(size);\r\n    var aIterable = a.entries();\r\n    var aResult;\r\n    var bResult;\r\n    var index = 0;\r\n    while ((aResult = aIterable.next())) {\r\n        if (aResult.done) {\r\n            break;\r\n        }\r\n        var bIterable = b.entries();\r\n        var hasMatch = false;\r\n        var matchIndex = 0;\r\n        while ((bResult = bIterable.next())) {\r\n            if (bResult.done) {\r\n                break;\r\n            }\r\n            if (matchedIndices[matchIndex]) {\r\n                matchIndex++;\r\n                continue;\r\n            }\r\n            var aEntry = aResult.value;\r\n            var bEntry = bResult.value;\r\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) &&\r\n                state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\r\n                hasMatch = matchedIndices[matchIndex] = true;\r\n                break;\r\n            }\r\n            matchIndex++;\r\n        }\r\n        if (!hasMatch) {\r\n            return false;\r\n        }\r\n        index++;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the numbers are equal in value.\r\n */\r\nvar areNumbersEqual = sameValueZeroEqual;\r\n/**\r\n * Whether the objects are equal in value.\r\n */\r\nfunction areObjectsEqual(a, b, state) {\r\n    var properties = keys(a);\r\n    var index = properties.length;\r\n    if (keys(b).length !== index) {\r\n        return false;\r\n    }\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        if (!isPropertyEqual(a, b, state, properties[index])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the objects are equal in value with strict property checking.\r\n */\r\nfunction areObjectsEqualStrict(a, b, state) {\r\n    var properties = getStrictProperties(a);\r\n    var index = properties.length;\r\n    if (getStrictProperties(b).length !== index) {\r\n        return false;\r\n    }\r\n    var property;\r\n    var descriptorA;\r\n    var descriptorB;\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        property = properties[index];\r\n        if (!isPropertyEqual(a, b, state, property)) {\r\n            return false;\r\n        }\r\n        descriptorA = getOwnPropertyDescriptor(a, property);\r\n        descriptorB = getOwnPropertyDescriptor(b, property);\r\n        if ((descriptorA || descriptorB) &&\r\n            (!descriptorA ||\r\n                !descriptorB ||\r\n                descriptorA.configurable !== descriptorB.configurable ||\r\n                descriptorA.enumerable !== descriptorB.enumerable ||\r\n                descriptorA.writable !== descriptorB.writable)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the primitive wrappers passed are equal in value.\r\n */\r\nfunction arePrimitiveWrappersEqual(a, b) {\r\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n}\r\n/**\r\n * Whether the regexps passed are equal in value.\r\n */\r\nfunction areRegExpsEqual(a, b) {\r\n    return a.source === b.source && a.flags === b.flags;\r\n}\r\n/**\r\n * Whether the `Set`s are equal in value.\r\n */\r\nfunction areSetsEqual(a, b, state) {\r\n    var size = a.size;\r\n    if (size !== b.size) {\r\n        return false;\r\n    }\r\n    if (!size) {\r\n        return true;\r\n    }\r\n    var matchedIndices = new Array(size);\r\n    var aIterable = a.values();\r\n    var aResult;\r\n    var bResult;\r\n    while ((aResult = aIterable.next())) {\r\n        if (aResult.done) {\r\n            break;\r\n        }\r\n        var bIterable = b.values();\r\n        var hasMatch = false;\r\n        var matchIndex = 0;\r\n        while ((bResult = bIterable.next())) {\r\n            if (bResult.done) {\r\n                break;\r\n            }\r\n            if (!matchedIndices[matchIndex] &&\r\n                state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\r\n                hasMatch = matchedIndices[matchIndex] = true;\r\n                break;\r\n            }\r\n            matchIndex++;\r\n        }\r\n        if (!hasMatch) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the TypedArray instances are equal in value.\r\n */\r\nfunction areTypedArraysEqual(a, b) {\r\n    var index = a.length;\r\n    if (b.length !== index) {\r\n        return false;\r\n    }\r\n    while (index-- > 0) {\r\n        if (a[index] !== b[index]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the URL instances are equal in value.\r\n */\r\nfunction areUrlsEqual(a, b) {\r\n    return (a.hostname === b.hostname &&\r\n        a.pathname === b.pathname &&\r\n        a.protocol === b.protocol &&\r\n        a.port === b.port &&\r\n        a.hash === b.hash &&\r\n        a.username === b.username &&\r\n        a.password === b.password);\r\n}\r\nfunction isPropertyEqual(a, b, state, property) {\r\n    if ((property === REACT_OWNER ||\r\n        property === PREACT_OWNER ||\r\n        property === PREACT_VNODE) &&\r\n        (a.$$typeof || b.$$typeof)) {\r\n        return true;\r\n    }\r\n    return (hasOwn(b, property) &&\r\n        state.equals(a[property], b[property], property, property, a, b, state));\r\n}\r\n\r\nvar ARGUMENTS_TAG = '[object Arguments]';\r\nvar BOOLEAN_TAG = '[object Boolean]';\r\nvar DATE_TAG = '[object Date]';\r\nvar ERROR_TAG = '[object Error]';\r\nvar MAP_TAG = '[object Map]';\r\nvar NUMBER_TAG = '[object Number]';\r\nvar OBJECT_TAG = '[object Object]';\r\nvar REG_EXP_TAG = '[object RegExp]';\r\nvar SET_TAG = '[object Set]';\r\nvar STRING_TAG = '[object String]';\r\nvar URL_TAG = '[object URL]';\r\nvar isArray = Array.isArray;\r\nvar isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView\r\n    ? ArrayBuffer.isView\r\n    : null;\r\nvar assign = Object.assign;\r\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\r\n/**\r\n * Create a comparator method based on the type-specific equality comparators passed.\r\n */\r\nfunction createEqualityComparator(_a) {\r\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areErrorsEqual = _a.areErrorsEqual, areFunctionsEqual = _a.areFunctionsEqual, areMapsEqual = _a.areMapsEqual, areNumbersEqual = _a.areNumbersEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual, areUrlsEqual = _a.areUrlsEqual;\r\n    /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     */\r\n    return function comparator(a, b, state) {\r\n        // If the items are strictly equal, no need to do a value comparison.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // If either of the items are nullish and fail the strictly equal check\r\n        // above, then they must be unequal.\r\n        if (a == null || b == null) {\r\n            return false;\r\n        }\r\n        var type = typeof a;\r\n        if (type !== typeof b) {\r\n            return false;\r\n        }\r\n        if (type !== 'object') {\r\n            if (type === 'number') {\r\n                return areNumbersEqual(a, b, state);\r\n            }\r\n            if (type === 'function') {\r\n                return areFunctionsEqual(a, b, state);\r\n            }\r\n            // If a primitive value that is not strictly equal, it must be unequal.\r\n            return false;\r\n        }\r\n        var constructor = a.constructor;\r\n        // Checks are listed in order of commonality of use-case:\r\n        //   1. Common complex object types (plain object, array)\r\n        //   2. Common data values (date, regexp)\r\n        //   3. Less-common complex object types (map, set)\r\n        //   4. Less-common data values (promise, primitive wrappers)\r\n        // Inherently this is both subjective and assumptive, however\r\n        // when reviewing comparable libraries in the wild this order\r\n        // appears to be generally consistent.\r\n        // Constructors should match, otherwise there is potential for false positives\r\n        // between class and subclass or custom object and POJO.\r\n        if (constructor !== b.constructor) {\r\n            return false;\r\n        }\r\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n        // comparisons are rare, and will be handled in the ultimate fallback, so\r\n        // we can avoid capturing the string tag.\r\n        if (constructor === Object) {\r\n            return areObjectsEqual(a, b, state);\r\n        }\r\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\r\n        // the string tag or doing an `instanceof` check.\r\n        if (isArray(a)) {\r\n            return areArraysEqual(a, b, state);\r\n        }\r\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\r\n        // capturing the string tag or comparing against all possible constructors.\r\n        if (isTypedArray != null && isTypedArray(a)) {\r\n            return areTypedArraysEqual(a, b, state);\r\n        }\r\n        // Try to fast-path equality checks for other complex object types in the\r\n        // same realm to avoid capturing the string tag. Strict equality is used\r\n        // instead of `instanceof` because it is more performant for the common\r\n        // use-case. If someone is subclassing a native class, it will be handled\r\n        // with the string tag comparison.\r\n        if (constructor === Date) {\r\n            return areDatesEqual(a, b, state);\r\n        }\r\n        if (constructor === RegExp) {\r\n            return areRegExpsEqual(a, b, state);\r\n        }\r\n        if (constructor === Map) {\r\n            return areMapsEqual(a, b, state);\r\n        }\r\n        if (constructor === Set) {\r\n            return areSetsEqual(a, b, state);\r\n        }\r\n        // Since this is a custom object, capture the string tag to determing its type.\r\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\r\n        var tag = getTag(a);\r\n        if (tag === DATE_TAG) {\r\n            return areDatesEqual(a, b, state);\r\n        }\r\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\r\n        // tested like a standard object.\r\n        if (tag === REG_EXP_TAG) {\r\n            return areRegExpsEqual(a, b, state);\r\n        }\r\n        if (tag === MAP_TAG) {\r\n            return areMapsEqual(a, b, state);\r\n        }\r\n        if (tag === SET_TAG) {\r\n            return areSetsEqual(a, b, state);\r\n        }\r\n        if (tag === OBJECT_TAG) {\r\n            // The exception for value comparison is custom `Promise`-like class instances. These should\r\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\r\n            // it reaches this point then that strict equality comparison has already failed.\r\n            return (typeof a.then !== 'function' &&\r\n                typeof b.then !== 'function' &&\r\n                areObjectsEqual(a, b, state));\r\n        }\r\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\r\n        // enumerable, and therefore will give false positives if tested like a standard object.\r\n        if (tag === URL_TAG) {\r\n            return areUrlsEqual(a, b, state);\r\n        }\r\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\r\n        // enumerable, and therefore will give false positives if tested like a standard object.\r\n        if (tag === ERROR_TAG) {\r\n            return areErrorsEqual(a, b, state);\r\n        }\r\n        // If an arguments tag, it should be treated as a standard object.\r\n        if (tag === ARGUMENTS_TAG) {\r\n            return areObjectsEqual(a, b, state);\r\n        }\r\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n        // types.\r\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\r\n            return arePrimitiveWrappersEqual(a, b, state);\r\n        }\r\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n        //     comparison that can be made.\r\n        //   - For types that can be introspected, but rarely have requirements to be compared\r\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n        //     use-cases (may be included in a future release, if requested enough).\r\n        //   - For types that can be introspected but do not have an objective definition of what\r\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n        // In all cases, these decisions should be reevaluated based on changes to the language and\r\n        // common development practices.\r\n        return false;\r\n    };\r\n}\r\n/**\r\n * Create the configuration object used for building comparators.\r\n */\r\nfunction createEqualityComparatorConfig(_a) {\r\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\r\n    var config = {\r\n        areArraysEqual: strict\r\n            ? areObjectsEqualStrict\r\n            : areArraysEqual,\r\n        areDatesEqual: areDatesEqual,\r\n        areErrorsEqual: areErrorsEqual,\r\n        areFunctionsEqual: areFunctionsEqual,\r\n        areMapsEqual: strict\r\n            ? combineComparators(areMapsEqual, areObjectsEqualStrict)\r\n            : areMapsEqual,\r\n        areNumbersEqual: areNumbersEqual,\r\n        areObjectsEqual: strict\r\n            ? areObjectsEqualStrict\r\n            : areObjectsEqual,\r\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\r\n        areRegExpsEqual: areRegExpsEqual,\r\n        areSetsEqual: strict\r\n            ? combineComparators(areSetsEqual, areObjectsEqualStrict)\r\n            : areSetsEqual,\r\n        areTypedArraysEqual: strict\r\n            ? areObjectsEqualStrict\r\n            : areTypedArraysEqual,\r\n        areUrlsEqual: areUrlsEqual,\r\n    };\r\n    if (createCustomConfig) {\r\n        config = assign({}, config, createCustomConfig(config));\r\n    }\r\n    if (circular) {\r\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\r\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\r\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\r\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\r\n        config = assign({}, config, {\r\n            areArraysEqual: areArraysEqual$1,\r\n            areMapsEqual: areMapsEqual$1,\r\n            areObjectsEqual: areObjectsEqual$1,\r\n            areSetsEqual: areSetsEqual$1,\r\n        });\r\n    }\r\n    return config;\r\n}\r\n/**\r\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n * use inside the built comparator.\r\n */\r\nfunction createInternalEqualityComparator(compare) {\r\n    return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\r\n        return compare(a, b, state);\r\n    };\r\n}\r\n/**\r\n * Create the `isEqual` function used by the consuming application.\r\n */\r\nfunction createIsEqual(_a) {\r\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\r\n    if (createState) {\r\n        return function isEqual(a, b) {\r\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\r\n            return comparator(a, b, {\r\n                cache: cache,\r\n                equals: equals,\r\n                meta: meta,\r\n                strict: strict,\r\n            });\r\n        };\r\n    }\r\n    if (circular) {\r\n        return function isEqual(a, b) {\r\n            return comparator(a, b, {\r\n                cache: new WeakMap(),\r\n                equals: equals,\r\n                meta: undefined,\r\n                strict: strict,\r\n            });\r\n        };\r\n    }\r\n    var state = {\r\n        cache: undefined,\r\n        equals: equals,\r\n        meta: undefined,\r\n        strict: strict,\r\n    };\r\n    return function isEqual(a, b) {\r\n        return comparator(a, b, state);\r\n    };\r\n}\r\n\r\n/**\r\n * Whether the items passed are deeply-equal in value.\r\n */\r\nvar deepEqual = createCustomEqual();\r\n/**\r\n * Whether the items passed are deeply-equal in value based on strict comparison.\r\n */\r\nvar strictDeepEqual = createCustomEqual({ strict: true });\r\n/**\r\n * Whether the items passed are deeply-equal in value, including circular references.\r\n */\r\nvar circularDeepEqual = createCustomEqual({ circular: true });\r\n/**\r\n * Whether the items passed are deeply-equal in value, including circular references,\r\n * based on strict comparison.\r\n */\r\nvar strictCircularDeepEqual = createCustomEqual({\r\n    circular: true,\r\n    strict: true,\r\n});\r\n/**\r\n * Whether the items passed are shallowly-equal in value.\r\n */\r\nvar shallowEqual = createCustomEqual({\r\n    createInternalComparator: function () { return sameValueZeroEqual; },\r\n});\r\n/**\r\n * Whether the items passed are shallowly-equal in value based on strict comparison\r\n */\r\nvar strictShallowEqual = createCustomEqual({\r\n    strict: true,\r\n    createInternalComparator: function () { return sameValueZeroEqual; },\r\n});\r\n/**\r\n * Whether the items passed are shallowly-equal in value, including circular references.\r\n */\r\nvar circularShallowEqual = createCustomEqual({\r\n    circular: true,\r\n    createInternalComparator: function () { return sameValueZeroEqual; },\r\n});\r\n/**\r\n * Whether the items passed are shallowly-equal in value, including circular references,\r\n * based on strict comparison.\r\n */\r\nvar strictCircularShallowEqual = createCustomEqual({\r\n    circular: true,\r\n    createInternalComparator: function () { return sameValueZeroEqual; },\r\n    strict: true,\r\n});\r\n/**\r\n * Create a custom equality comparison method.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `RegExp.prototype.flags` out of the box.\r\n */\r\nfunction createCustomEqual(options) {\r\n    if (options === void 0) { options = {}; }\r\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\r\n    var config = createEqualityComparatorConfig(options);\r\n    var comparator = createEqualityComparator(config);\r\n    var equals = createCustomInternalComparator\r\n        ? createCustomInternalComparator(comparator)\r\n        : createInternalEqualityComparator(comparator);\r\n    return createIsEqual({ circular: circular, comparator: comparator, createState: createState, equals: equals, strict: strict });\r\n}\r\n\r\n\r\n//# sourceMappingURL=index.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0QkFBNEI7QUFDeEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNEJBQTRCO0FBQ3hFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNEJBQTRCO0FBQ3hFO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0dBQXNHO0FBQ2pJO0FBQ0E7QUFDNk07QUFDN00iLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxmYXN0LWVxdWFsc1xcZGlzdFxcZXNtXFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuLyoqXHJcbiAqIENvbWJpbmUgdHdvIGNvbXBhcmF0b3JzIGludG8gYSBzaW5nbGUgY29tcGFyYXRvcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21iaW5lQ29tcGFyYXRvcnMoY29tcGFyYXRvckEsIGNvbXBhcmF0b3JCKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yQShhLCBiLCBzdGF0ZSkgJiYgY29tcGFyYXRvckIoYSwgYiwgc3RhdGUpO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogV3JhcCB0aGUgcHJvdmlkZWQgYGFyZUl0ZW1zRXF1YWxgIG1ldGhvZCB0byBtYW5hZ2UgdGhlIGNpcmN1bGFyIHN0YXRlLCBhbGxvd2luZ1xyXG4gKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xyXG4gKiBzdGFjayBvdmVyZmxvd3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBpc0NpcmN1bGFyKGEsIGIsIHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKCFhIHx8ICFiIHx8IHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcclxuICAgICAgICB2YXIgY2FjaGVkQSA9IGNhY2hlLmdldChhKTtcclxuICAgICAgICB2YXIgY2FjaGVkQiA9IGNhY2hlLmdldChiKTtcclxuICAgICAgICBpZiAoY2FjaGVkQSAmJiBjYWNoZWRCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBID09PSBiICYmIGNhY2hlZEIgPT09IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhY2hlLnNldChhLCBiKTtcclxuICAgICAgICBjYWNoZS5zZXQoYiwgYSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xyXG4gICAgICAgIGNhY2hlLmRlbGV0ZShhKTtcclxuICAgICAgICBjYWNoZS5kZWxldGUoYik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgcHJvcGVydGllcyB0byBzdHJpY3RseSBleGFtaW5lLCB3aGljaCBpbmNsdWRlIGJvdGggb3duIHByb3BlcnRpZXMgdGhhdCBhcmVcclxuICogbm90IGVudW1lcmFibGUgYW5kIHN5bWJvbCBwcm9wZXJ0aWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RyaWN0UHJvcGVydGllcyhvYmplY3QpIHtcclxuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBwYXNzZWQgYXMgYW4gb3duIHByb3BlcnR5LlxyXG4gKi9cclxudmFyIGhhc093biA9IE9iamVjdC5oYXNPd24gfHxcclxuICAgIChmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xyXG4gICAgfSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBzdHJpY3RseSBlcXVhbCBvciBib3RoIE5hTi5cclxuICovXHJcbmZ1bmN0aW9uIHNhbWVWYWx1ZVplcm9FcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYiB8fCAoIWEgJiYgIWIgJiYgYSAhPT0gYSAmJiBiICE9PSBiKTtcclxufVxyXG5cclxudmFyIFBSRUFDVF9WTk9ERSA9ICdfX3YnO1xyXG52YXIgUFJFQUNUX09XTkVSID0gJ19fbyc7XHJcbnZhciBSRUFDVF9PV05FUiA9ICdfb3duZXInO1xyXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwga2V5cyA9IE9iamVjdC5rZXlzO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgYXJyYXlzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKSB7XHJcbiAgICB2YXIgaW5kZXggPSBhLmxlbmd0aDtcclxuICAgIGlmIChiLmxlbmd0aCAhPT0gaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICBpZiAoIXN0YXRlLmVxdWFscyhhW2luZGV4XSwgYltpbmRleF0sIGluZGV4LCBpbmRleCwgYSwgYiwgc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgZGF0ZXMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZURhdGVzRXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLmdldFRpbWUoKSwgYi5nZXRUaW1lKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBlcnJvcnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZUVycm9yc0VxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiAoYS5uYW1lID09PSBiLm5hbWUgJiZcclxuICAgICAgICBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZSAmJlxyXG4gICAgICAgIGEuY2F1c2UgPT09IGIuY2F1c2UgJiZcclxuICAgICAgICBhLnN0YWNrID09PSBiLnN0YWNrKTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgZnVuY3Rpb25zIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVGdW5jdGlvbnNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gYjtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgYE1hcGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSkge1xyXG4gICAgdmFyIHNpemUgPSBhLnNpemU7XHJcbiAgICBpZiAoc2l6ZSAhPT0gYi5zaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgICB2YXIgYUl0ZXJhYmxlID0gYS5lbnRyaWVzKCk7XHJcbiAgICB2YXIgYVJlc3VsdDtcclxuICAgIHZhciBiUmVzdWx0O1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XHJcbiAgICAgICAgaWYgKGFSZXN1bHQuZG9uZSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJJdGVyYWJsZSA9IGIuZW50cmllcygpO1xyXG4gICAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBtYXRjaEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xyXG4gICAgICAgICAgICBpZiAoYlJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhRW50cnkgPSBhUmVzdWx0LnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgYkVudHJ5ID0gYlJlc3VsdC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlLmVxdWFscyhhRW50cnlbMF0sIGJFbnRyeVswXSwgaW5kZXgsIG1hdGNoSW5kZXgsIGEsIGIsIHN0YXRlKSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhdGUuZXF1YWxzKGFFbnRyeVsxXSwgYkVudHJ5WzFdLCBhRW50cnlbMF0sIGJFbnRyeVswXSwgYSwgYiwgc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgbnVtYmVycyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG52YXIgYXJlTnVtYmVyc0VxdWFsID0gc2FtZVZhbHVlWmVyb0VxdWFsO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpIHtcclxuICAgIHZhciBwcm9wZXJ0aWVzID0ga2V5cyhhKTtcclxuICAgIHZhciBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXHJcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxyXG4gICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxyXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XHJcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnRpZXNbaW5kZXhdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlIHdpdGggc3RyaWN0IHByb3BlcnR5IGNoZWNraW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsU3RyaWN0KGEsIGIsIHN0YXRlKSB7XHJcbiAgICB2YXIgcHJvcGVydGllcyA9IGdldFN0cmljdFByb3BlcnRpZXMoYSk7XHJcbiAgICB2YXIgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcclxuICAgIGlmIChnZXRTdHJpY3RQcm9wZXJ0aWVzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvcGVydHk7XHJcbiAgICB2YXIgZGVzY3JpcHRvckE7XHJcbiAgICB2YXIgZGVzY3JpcHRvckI7XHJcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXHJcbiAgICAvLyBkZWNyZW1lbnRpbmcgYGZvcmAgbG9vcCBhbmQgdGhhbiBhbiBpbmNyZW1lbnRpbmcgYHdoaWxlYCBsb29wLiBEZWNsYXJhdGl2ZVxyXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcclxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cclxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF07XHJcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc2NyaXB0b3JBID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIHByb3BlcnR5KTtcclxuICAgICAgICBkZXNjcmlwdG9yQiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yQSB8fCBkZXNjcmlwdG9yQikgJiZcclxuICAgICAgICAgICAgKCFkZXNjcmlwdG9yQSB8fFxyXG4gICAgICAgICAgICAgICAgIWRlc2NyaXB0b3JCIHx8XHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yQS5jb25maWd1cmFibGUgIT09IGRlc2NyaXB0b3JCLmNvbmZpZ3VyYWJsZSB8fFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvckEuZW51bWVyYWJsZSAhPT0gZGVzY3JpcHRvckIuZW51bWVyYWJsZSB8fFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvckEud3JpdGFibGUgIT09IGRlc2NyaXB0b3JCLndyaXRhYmxlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHByaW1pdGl2ZSB3cmFwcGVycyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHJlZ2V4cHMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZVJlZ0V4cHNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGBTZXRgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpIHtcclxuICAgIHZhciBzaXplID0gYS5zaXplO1xyXG4gICAgaWYgKHNpemUgIT09IGIuc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIG1hdGNoZWRJbmRpY2VzID0gbmV3IEFycmF5KHNpemUpO1xyXG4gICAgdmFyIGFJdGVyYWJsZSA9IGEudmFsdWVzKCk7XHJcbiAgICB2YXIgYVJlc3VsdDtcclxuICAgIHZhciBiUmVzdWx0O1xyXG4gICAgd2hpbGUgKChhUmVzdWx0ID0gYUl0ZXJhYmxlLm5leHQoKSkpIHtcclxuICAgICAgICBpZiAoYVJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYkl0ZXJhYmxlID0gYi52YWx1ZXMoKTtcclxuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICB2YXIgbWF0Y2hJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKChiUmVzdWx0ID0gYkl0ZXJhYmxlLm5leHQoKSkpIHtcclxuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhdGUuZXF1YWxzKGFSZXN1bHQudmFsdWUsIGJSZXN1bHQudmFsdWUsIGFSZXN1bHQudmFsdWUsIGJSZXN1bHQudmFsdWUsIGEsIGIsIHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaEluZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGFzTWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBUeXBlZEFycmF5IGluc3RhbmNlcyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgIHZhciBpbmRleCA9IGEubGVuZ3RoO1xyXG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgIGlmIChhW2luZGV4XSAhPT0gYltpbmRleF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBVUkwgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZVVybHNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gKGEuaG9zdG5hbWUgPT09IGIuaG9zdG5hbWUgJiZcclxuICAgICAgICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmXHJcbiAgICAgICAgYS5wcm90b2NvbCA9PT0gYi5wcm90b2NvbCAmJlxyXG4gICAgICAgIGEucG9ydCA9PT0gYi5wb3J0ICYmXHJcbiAgICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcclxuICAgICAgICBhLnVzZXJuYW1lID09PSBiLnVzZXJuYW1lICYmXHJcbiAgICAgICAgYS5wYXNzd29yZCA9PT0gYi5wYXNzd29yZCk7XHJcbn1cclxuZnVuY3Rpb24gaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKChwcm9wZXJ0eSA9PT0gUkVBQ1RfT1dORVIgfHxcclxuICAgICAgICBwcm9wZXJ0eSA9PT0gUFJFQUNUX09XTkVSIHx8XHJcbiAgICAgICAgcHJvcGVydHkgPT09IFBSRUFDVF9WTk9ERSkgJiZcclxuICAgICAgICAoYS4kJHR5cGVvZiB8fCBiLiQkdHlwZW9mKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChoYXNPd24oYiwgcHJvcGVydHkpICYmXHJcbiAgICAgICAgc3RhdGUuZXF1YWxzKGFbcHJvcGVydHldLCBiW3Byb3BlcnR5XSwgcHJvcGVydHksIHByb3BlcnR5LCBhLCBiLCBzdGF0ZSkpO1xyXG59XHJcblxyXG52YXIgQVJHVU1FTlRTX1RBRyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xyXG52YXIgQk9PTEVBTl9UQUcgPSAnW29iamVjdCBCb29sZWFuXSc7XHJcbnZhciBEQVRFX1RBRyA9ICdbb2JqZWN0IERhdGVdJztcclxudmFyIEVSUk9SX1RBRyA9ICdbb2JqZWN0IEVycm9yXSc7XHJcbnZhciBNQVBfVEFHID0gJ1tvYmplY3QgTWFwXSc7XHJcbnZhciBOVU1CRVJfVEFHID0gJ1tvYmplY3QgTnVtYmVyXSc7XHJcbnZhciBPQkpFQ1RfVEFHID0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbnZhciBSRUdfRVhQX1RBRyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG52YXIgU0VUX1RBRyA9ICdbb2JqZWN0IFNldF0nO1xyXG52YXIgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xyXG52YXIgVVJMX1RBRyA9ICdbb2JqZWN0IFVSTF0nO1xyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbnZhciBpc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XHJcbiAgICA/IEFycmF5QnVmZmVyLmlzVmlld1xyXG4gICAgOiBudWxsO1xyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcclxudmFyIGdldFRhZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xyXG4vKipcclxuICogQ3JlYXRlIGEgY29tcGFyYXRvciBtZXRob2QgYmFzZWQgb24gdGhlIHR5cGUtc3BlY2lmaWMgZXF1YWxpdHkgY29tcGFyYXRvcnMgcGFzc2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yKF9hKSB7XHJcbiAgICB2YXIgYXJlQXJyYXlzRXF1YWwgPSBfYS5hcmVBcnJheXNFcXVhbCwgYXJlRGF0ZXNFcXVhbCA9IF9hLmFyZURhdGVzRXF1YWwsIGFyZUVycm9yc0VxdWFsID0gX2EuYXJlRXJyb3JzRXF1YWwsIGFyZUZ1bmN0aW9uc0VxdWFsID0gX2EuYXJlRnVuY3Rpb25zRXF1YWwsIGFyZU1hcHNFcXVhbCA9IF9hLmFyZU1hcHNFcXVhbCwgYXJlTnVtYmVyc0VxdWFsID0gX2EuYXJlTnVtYmVyc0VxdWFsLCBhcmVPYmplY3RzRXF1YWwgPSBfYS5hcmVPYmplY3RzRXF1YWwsIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwgPSBfYS5hcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLCBhcmVSZWdFeHBzRXF1YWwgPSBfYS5hcmVSZWdFeHBzRXF1YWwsIGFyZVNldHNFcXVhbCA9IF9hLmFyZVNldHNFcXVhbCwgYXJlVHlwZWRBcnJheXNFcXVhbCA9IF9hLmFyZVR5cGVkQXJyYXlzRXF1YWwsIGFyZVVybHNFcXVhbCA9IF9hLmFyZVVybHNFcXVhbDtcclxuICAgIC8qKlxyXG4gICAgICogY29tcGFyZSB0aGUgdmFsdWUgb2YgdGhlIHR3byBvYmplY3RzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBzdGF0ZSkge1xyXG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgc3RyaWN0bHkgZXF1YWwsIG5vIG5lZWQgdG8gZG8gYSB2YWx1ZSBjb21wYXJpc29uLlxyXG4gICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBlaXRoZXIgb2YgdGhlIGl0ZW1zIGFyZSBudWxsaXNoIGFuZCBmYWlsIHRoZSBzdHJpY3RseSBlcXVhbCBjaGVja1xyXG4gICAgICAgIC8vIGFib3ZlLCB0aGVuIHRoZXkgbXVzdCBiZSB1bmVxdWFsLlxyXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYTtcclxuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlTnVtYmVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZUZ1bmN0aW9uc0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzIG5vdCBzdHJpY3RseSBlcXVhbCwgaXQgbXVzdCBiZSB1bmVxdWFsLlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGEuY29uc3RydWN0b3I7XHJcbiAgICAgICAgLy8gQ2hlY2tzIGFyZSBsaXN0ZWQgaW4gb3JkZXIgb2YgY29tbW9uYWxpdHkgb2YgdXNlLWNhc2U6XHJcbiAgICAgICAgLy8gICAxLiBDb21tb24gY29tcGxleCBvYmplY3QgdHlwZXMgKHBsYWluIG9iamVjdCwgYXJyYXkpXHJcbiAgICAgICAgLy8gICAyLiBDb21tb24gZGF0YSB2YWx1ZXMgKGRhdGUsIHJlZ2V4cClcclxuICAgICAgICAvLyAgIDMuIExlc3MtY29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChtYXAsIHNldClcclxuICAgICAgICAvLyAgIDQuIExlc3MtY29tbW9uIGRhdGEgdmFsdWVzIChwcm9taXNlLCBwcmltaXRpdmUgd3JhcHBlcnMpXHJcbiAgICAgICAgLy8gSW5oZXJlbnRseSB0aGlzIGlzIGJvdGggc3ViamVjdGl2ZSBhbmQgYXNzdW1wdGl2ZSwgaG93ZXZlclxyXG4gICAgICAgIC8vIHdoZW4gcmV2aWV3aW5nIGNvbXBhcmFibGUgbGlicmFyaWVzIGluIHRoZSB3aWxkIHRoaXMgb3JkZXJcclxuICAgICAgICAvLyBhcHBlYXJzIHRvIGJlIGdlbmVyYWxseSBjb25zaXN0ZW50LlxyXG4gICAgICAgIC8vIENvbnN0cnVjdG9ycyBzaG91bGQgbWF0Y2gsIG90aGVyd2lzZSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGZhbHNlIHBvc2l0aXZlc1xyXG4gICAgICAgIC8vIGJldHdlZW4gY2xhc3MgYW5kIHN1YmNsYXNzIG9yIGN1c3RvbSBvYmplY3QgYW5kIFBPSk8uXHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYGlzUGxhaW5PYmplY3RgIG9ubHkgY2hlY2tzIGFnYWluc3QgdGhlIG9iamVjdCdzIG93biByZWFsbS4gQ3Jvc3MtcmVhbG1cclxuICAgICAgICAvLyBjb21wYXJpc29ucyBhcmUgcmFyZSwgYW5kIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgdWx0aW1hdGUgZmFsbGJhY2ssIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy5cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYGlzQXJyYXkoKWAgd29ya3Mgb24gc3ViY2xhc3NlcyBhbmQgaXMgY3Jvc3MtcmVhbG0sIHNvIHdlIGNhbiBhdm9pZCBjYXB0dXJpbmdcclxuICAgICAgICAvLyB0aGUgc3RyaW5nIHRhZyBvciBkb2luZyBhbiBgaW5zdGFuY2VvZmAgY2hlY2suXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoYSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYGlzVHlwZWRBcnJheSgpYCB3b3JrcyBvbiBhbGwgcG9zc2libGUgVHlwZWRBcnJheSBjbGFzc2VzLCBzbyB3ZSBjYW4gYXZvaWRcclxuICAgICAgICAvLyBjYXB0dXJpbmcgdGhlIHN0cmluZyB0YWcgb3IgY29tcGFyaW5nIGFnYWluc3QgYWxsIHBvc3NpYmxlIGNvbnN0cnVjdG9ycy5cclxuICAgICAgICBpZiAoaXNUeXBlZEFycmF5ICE9IG51bGwgJiYgaXNUeXBlZEFycmF5KGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIGZhc3QtcGF0aCBlcXVhbGl0eSBjaGVja3MgZm9yIG90aGVyIGNvbXBsZXggb2JqZWN0IHR5cGVzIGluIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgcmVhbG0gdG8gYXZvaWQgY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnLiBTdHJpY3QgZXF1YWxpdHkgaXMgdXNlZFxyXG4gICAgICAgIC8vIGluc3RlYWQgb2YgYGluc3RhbmNlb2ZgIGJlY2F1c2UgaXQgaXMgbW9yZSBwZXJmb3JtYW50IGZvciB0aGUgY29tbW9uXHJcbiAgICAgICAgLy8gdXNlLWNhc2UuIElmIHNvbWVvbmUgaXMgc3ViY2xhc3NpbmcgYSBuYXRpdmUgY2xhc3MsIGl0IHdpbGwgYmUgaGFuZGxlZFxyXG4gICAgICAgIC8vIHdpdGggdGhlIHN0cmluZyB0YWcgY29tcGFyaXNvbi5cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZURhdGVzRXF1YWwoYSwgYiwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJlUmVnRXhwc0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gU2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgY3VzdG9tIG9iamVjdCwgY2FwdHVyZSB0aGUgc3RyaW5nIHRhZyB0byBkZXRlcm1pbmcgaXRzIHR5cGUuXHJcbiAgICAgICAgLy8gVGhpcyBpcyByZWFzb25hYmx5IHBlcmZvcm1hbnQgaW4gbW9kZXJuIGVudmlyb25tZW50cyBsaWtlIHY4IGFuZCBTcGlkZXJNb25rZXkuXHJcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhhKTtcclxuICAgICAgICBpZiAodGFnID09PSBEQVRFX1RBRykge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZvciBSZWdFeHAsIHRoZSBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZSwgYW5kIHRoZXJlZm9yZSB3aWxsIGdpdmUgZmFsc2UgcG9zaXRpdmVzIGlmXHJcbiAgICAgICAgLy8gdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gUkVHX0VYUF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT09IE1BUF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT09IFNFVF9UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YWcgPT09IE9CSkVDVF9UQUcpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBmb3IgdmFsdWUgY29tcGFyaXNvbiBpcyBjdXN0b20gYFByb21pc2VgLWxpa2UgY2xhc3MgaW5zdGFuY2VzLiBUaGVzZSBzaG91bGRcclxuICAgICAgICAgICAgLy8gYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBzdGFuZGFyZCBgUHJvbWlzZWAgb2JqZWN0cywgd2hpY2ggbWVhbnMgc3RyaWN0IGVxdWFsaXR5LCBhbmQgaWZcclxuICAgICAgICAgICAgLy8gaXQgcmVhY2hlcyB0aGlzIHBvaW50IHRoZW4gdGhhdCBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbiBoYXMgYWxyZWFkeSBmYWlsZWQuXHJcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGEudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGIudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGEgVVJMIHRhZywgaXQgc2hvdWxkIGJlIHRlc3RlZCBleHBsaWNpdGx5LiBMaWtlIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdFxyXG4gICAgICAgIC8vIGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZiB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cclxuICAgICAgICBpZiAodGFnID09PSBVUkxfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVVcmxzRXF1YWwoYSwgYiwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhbiBlcnJvciB0YWcsIGl0IHNob3VsZCBiZSB0ZXN0ZWQgZXhwbGljaXRseS4gTGlrZSBSZWdFeHAsIHRoZSBwcm9wZXJ0aWVzIGFyZSBub3RcclxuICAgICAgICAvLyBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gRVJST1JfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVFcnJvcnNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGFuIGFyZ3VtZW50cyB0YWcsIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc3RhbmRhcmQgb2JqZWN0LlxyXG4gICAgICAgIGlmICh0YWcgPT09IEFSR1VNRU5UU19UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFzIHRoZSBwZW51bHRpbWF0ZSBmYWxsYmFjaywgY2hlY2sgaWYgdGhlIHZhbHVlcyBwYXNzZWQgYXJlIHByaW1pdGl2ZSB3cmFwcGVycy4gVGhpc1xyXG4gICAgICAgIC8vIGlzIHZlcnkgcmFyZSBpbiBtb2Rlcm4gSlMsIHdoaWNoIGlzIHdoeSBpdCBpcyBkZXByaW9yaXRpemVkIGNvbXBhcmVkIHRvIGFsbCBvdGhlciBvYmplY3RcclxuICAgICAgICAvLyB0eXBlcy5cclxuICAgICAgICBpZiAodGFnID09PSBCT09MRUFOX1RBRyB8fCB0YWcgPT09IE5VTUJFUl9UQUcgfHwgdGFnID09PSBTVFJJTkdfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgbm90IG1hdGNoaW5nIGFueSB0YWdzIHRoYXQgcmVxdWlyZSBhIHNwZWNpZmljIHR5cGUgb2YgY29tcGFyaXNvbiwgdGhlbiB3ZSBoYXJkLWNvZGUgZmFsc2UgYmVjYXVzZVxyXG4gICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIHJlbWFpbmluZyBpcyBzdHJpY3QgZXF1YWxpdHksIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gY29tcGFyZWQuIFRoaXMgaXMgZm9yIGEgZmV3IHJlYXNvbnM6XHJcbiAgICAgICAgLy8gICAtIENlcnRhaW4gdHlwZXMgdGhhdCBjYW5ub3QgYmUgaW50cm9zcGVjdGVkIChlLmcuLCBgV2Vha01hcGApLiBGb3IgdGhlc2UgdHlwZXMsIHRoaXMgaXMgdGhlIG9ubHlcclxuICAgICAgICAvLyAgICAgY29tcGFyaXNvbiB0aGF0IGNhbiBiZSBtYWRlLlxyXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkLCBidXQgcmFyZWx5IGhhdmUgcmVxdWlyZW1lbnRzIHRvIGJlIGNvbXBhcmVkXHJcbiAgICAgICAgLy8gICAgIChgQXJyYXlCdWZmZXJgLCBgRGF0YVZpZXdgLCBldGMuKSwgdGhlIGNvc3QgaXMgYXZvaWRlZCB0byBwcmlvcml0aXplIHRoZSBjb21tb25cclxuICAgICAgICAvLyAgICAgdXNlLWNhc2VzIChtYXkgYmUgaW5jbHVkZWQgaW4gYSBmdXR1cmUgcmVsZWFzZSwgaWYgcmVxdWVzdGVkIGVub3VnaCkuXHJcbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQgYnV0IGRvIG5vdCBoYXZlIGFuIG9iamVjdGl2ZSBkZWZpbml0aW9uIG9mIHdoYXRcclxuICAgICAgICAvLyAgICAgZXF1YWxpdHkgaXMgKGBFcnJvcmAsIGV0Yy4pLCB0aGUgc3ViamVjdGl2ZSBkZWNpc2lvbiBpcyB0byBiZSBjb25zZXJ2YXRpdmUgYW5kIHN0cmljdGx5IGNvbXBhcmUuXHJcbiAgICAgICAgLy8gSW4gYWxsIGNhc2VzLCB0aGVzZSBkZWNpc2lvbnMgc2hvdWxkIGJlIHJlZXZhbHVhdGVkIGJhc2VkIG9uIGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIGFuZFxyXG4gICAgICAgIC8vIGNvbW1vbiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB1c2VkIGZvciBidWlsZGluZyBjb21wYXJhdG9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyhfYSkge1xyXG4gICAgdmFyIGNpcmN1bGFyID0gX2EuY2lyY3VsYXIsIGNyZWF0ZUN1c3RvbUNvbmZpZyA9IF9hLmNyZWF0ZUN1c3RvbUNvbmZpZywgc3RyaWN0ID0gX2Euc3RyaWN0O1xyXG4gICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICBhcmVBcnJheXNFcXVhbDogc3RyaWN0XHJcbiAgICAgICAgICAgID8gYXJlT2JqZWN0c0VxdWFsU3RyaWN0XHJcbiAgICAgICAgICAgIDogYXJlQXJyYXlzRXF1YWwsXHJcbiAgICAgICAgYXJlRGF0ZXNFcXVhbDogYXJlRGF0ZXNFcXVhbCxcclxuICAgICAgICBhcmVFcnJvcnNFcXVhbDogYXJlRXJyb3JzRXF1YWwsXHJcbiAgICAgICAgYXJlRnVuY3Rpb25zRXF1YWw6IGFyZUZ1bmN0aW9uc0VxdWFsLFxyXG4gICAgICAgIGFyZU1hcHNFcXVhbDogc3RyaWN0XHJcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZU1hcHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxyXG4gICAgICAgICAgICA6IGFyZU1hcHNFcXVhbCxcclxuICAgICAgICBhcmVOdW1iZXJzRXF1YWw6IGFyZU51bWJlcnNFcXVhbCxcclxuICAgICAgICBhcmVPYmplY3RzRXF1YWw6IHN0cmljdFxyXG4gICAgICAgICAgICA/IGFyZU9iamVjdHNFcXVhbFN0cmljdFxyXG4gICAgICAgICAgICA6IGFyZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsOiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLFxyXG4gICAgICAgIGFyZVJlZ0V4cHNFcXVhbDogYXJlUmVnRXhwc0VxdWFsLFxyXG4gICAgICAgIGFyZVNldHNFcXVhbDogc3RyaWN0XHJcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZVNldHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxyXG4gICAgICAgICAgICA6IGFyZVNldHNFcXVhbCxcclxuICAgICAgICBhcmVUeXBlZEFycmF5c0VxdWFsOiBzdHJpY3RcclxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcclxuICAgICAgICAgICAgOiBhcmVUeXBlZEFycmF5c0VxdWFsLFxyXG4gICAgICAgIGFyZVVybHNFcXVhbDogYXJlVXJsc0VxdWFsLFxyXG4gICAgfTtcclxuICAgIGlmIChjcmVhdGVDdXN0b21Db25maWcpIHtcclxuICAgICAgICBjb25maWcgPSBhc3NpZ24oe30sIGNvbmZpZywgY3JlYXRlQ3VzdG9tQ29uZmlnKGNvbmZpZykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNpcmN1bGFyKSB7XHJcbiAgICAgICAgdmFyIGFyZUFycmF5c0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVBcnJheXNFcXVhbCk7XHJcbiAgICAgICAgdmFyIGFyZU1hcHNFcXVhbCQxID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlTWFwc0VxdWFsKTtcclxuICAgICAgICB2YXIgYXJlT2JqZWN0c0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVPYmplY3RzRXF1YWwpO1xyXG4gICAgICAgIHZhciBhcmVTZXRzRXF1YWwkMSA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZVNldHNFcXVhbCk7XHJcbiAgICAgICAgY29uZmlnID0gYXNzaWduKHt9LCBjb25maWcsIHtcclxuICAgICAgICAgICAgYXJlQXJyYXlzRXF1YWw6IGFyZUFycmF5c0VxdWFsJDEsXHJcbiAgICAgICAgICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsJDEsXHJcbiAgICAgICAgICAgIGFyZU9iamVjdHNFcXVhbDogYXJlT2JqZWN0c0VxdWFsJDEsXHJcbiAgICAgICAgICAgIGFyZVNldHNFcXVhbDogYXJlU2V0c0VxdWFsJDEsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZhdWx0IGVxdWFsaXR5IGNvbXBhcmF0b3IgcGFzcy10aHJvdWdoLCB1c2VkIGFzIHRoZSBzdGFuZGFyZCBgaXNFcXVhbGAgY3JlYXRvciBmb3JcclxuICogdXNlIGluc2lkZSB0aGUgYnVpbHQgY29tcGFyYXRvci5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yKGNvbXBhcmUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgX2luZGV4T3JLZXlBLCBfaW5kZXhPcktleUIsIF9wYXJlbnRBLCBfcGFyZW50Qiwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gY29tcGFyZShhLCBiLCBzdGF0ZSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgdGhlIGBpc0VxdWFsYCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBjb25zdW1pbmcgYXBwbGljYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJc0VxdWFsKF9hKSB7XHJcbiAgICB2YXIgY2lyY3VsYXIgPSBfYS5jaXJjdWxhciwgY29tcGFyYXRvciA9IF9hLmNvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlID0gX2EuY3JlYXRlU3RhdGUsIGVxdWFscyA9IF9hLmVxdWFscywgc3RyaWN0ID0gX2Euc3RyaWN0O1xyXG4gICAgaWYgKGNyZWF0ZVN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBjcmVhdGVTdGF0ZSgpLCBfYiA9IF9hLmNhY2hlLCBjYWNoZSA9IF9iID09PSB2b2lkIDAgPyBjaXJjdWxhciA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQgOiBfYiwgbWV0YSA9IF9hLm1ldGE7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZSxcclxuICAgICAgICAgICAgICAgIGVxdWFsczogZXF1YWxzLFxyXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YSxcclxuICAgICAgICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGNpcmN1bGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZTogbmV3IFdlYWtNYXAoKSxcclxuICAgICAgICAgICAgICAgIGVxdWFsczogZXF1YWxzLFxyXG4gICAgICAgICAgICAgICAgbWV0YTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhdGUgPSB7XHJcbiAgICAgICAgY2FjaGU6IHVuZGVmaW5lZCxcclxuICAgICAgICBlcXVhbHM6IGVxdWFscyxcclxuICAgICAgICBtZXRhOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc3RyaWN0OiBzdHJpY3QsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHN0YXRlKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbnZhciBkZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCgpO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUgYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXHJcbiAqL1xyXG52YXIgc3RyaWN0RGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoeyBzdHJpY3Q6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG52YXIgY2lyY3VsYXJEZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7IGNpcmN1bGFyOiB0cnVlIH0pO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLFxyXG4gKiBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cclxuICovXHJcbnZhciBzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcclxuICAgIGNpcmN1bGFyOiB0cnVlLFxyXG4gICAgc3RyaWN0OiB0cnVlLFxyXG59KTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxudmFyIHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcclxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxyXG59KTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uXHJcbiAqL1xyXG52YXIgc3RyaWN0U2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xyXG4gICAgc3RyaWN0OiB0cnVlLFxyXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXHJcbn0pO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxudmFyIGNpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xyXG4gICAgY2lyY3VsYXI6IHRydWUsXHJcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcclxufSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMsXHJcbiAqIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxyXG4gKi9cclxudmFyIHN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xyXG4gICAgY2lyY3VsYXI6IHRydWUsXHJcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcclxuICAgIHN0cmljdDogdHJ1ZSxcclxufSk7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBtZXRob2QuXHJcbiAqXHJcbiAqIFRoaXMgY2FuIGJlIGRvbmUgdG8gY3JlYXRlIHZlcnkgdGFyZ2V0ZWQgY29tcGFyaXNvbnMgaW4gZXh0cmVtZSBob3QtcGF0aCBzY2VuYXJpb3NcclxuICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxyXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxyXG4gKiBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2Agb3V0IG9mIHRoZSBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcXVhbChvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9hID0gb3B0aW9ucy5jaXJjdWxhciwgY2lyY3VsYXIgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yID0gb3B0aW9ucy5jcmVhdGVJbnRlcm5hbENvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlID0gb3B0aW9ucy5jcmVhdGVTdGF0ZSwgX2IgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XHJcbiAgICB2YXIgY29uZmlnID0gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yQ29uZmlnKG9wdGlvbnMpO1xyXG4gICAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IoY29uZmlnKTtcclxuICAgIHZhciBlcXVhbHMgPSBjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3JcclxuICAgICAgICA/IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvcihjb21wYXJhdG9yKVxyXG4gICAgICAgIDogY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IoY29tcGFyYXRvcik7XHJcbiAgICByZXR1cm4gY3JlYXRlSXNFcXVhbCh7IGNpcmN1bGFyOiBjaXJjdWxhciwgY29tcGFyYXRvcjogY29tcGFyYXRvciwgY3JlYXRlU3RhdGU6IGNyZWF0ZVN0YXRlLCBlcXVhbHM6IGVxdWFscywgc3RyaWN0OiBzdHJpY3QgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGNpcmN1bGFyRGVlcEVxdWFsLCBjaXJjdWxhclNoYWxsb3dFcXVhbCwgY3JlYXRlQ3VzdG9tRXF1YWwsIGRlZXBFcXVhbCwgc2FtZVZhbHVlWmVyb0VxdWFsLCBzaGFsbG93RXF1YWwsIHN0cmljdENpcmN1bGFyRGVlcEVxdWFsLCBzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCwgc3RyaWN0RGVlcEVxdWFsLCBzdHJpY3RTaGFsbG93RXF1YWwgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\n");

/***/ })

};
;