"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\n\r\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(ssr)/./node_modules/ws/lib/stream.js\");\r\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(ssr)/./node_modules/ws/lib/websocket-server.js\");\r\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\r\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(ssr)/./node_modules/ws/lib/sender.js\");\r\n\r\nWebSocket.WebSocket = WebSocket;\r\nWebSocket.WebSocketServer = WebSocket.Server;\r\n\r\nmodule.exports = WebSocket;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlFQUFpQjtBQUMzQztBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDJEQUFjO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLCtFQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMkRBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcclxuXHJcbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcclxuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcclxuV2ViU29ja2V0LlJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvcmVjZWl2ZXInKTtcclxuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xyXG5cclxuV2ViU29ja2V0LldlYlNvY2tldCA9IFdlYlNvY2tldDtcclxuV2ViU29ja2V0LldlYlNvY2tldFNlcnZlciA9IFdlYlNvY2tldC5TZXJ2ZXI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nfunction concat(list, totalLength) {\r\n  if (list.length === 0) return EMPTY_BUFFER;\r\n  if (list.length === 1) return list[0];\r\n\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  let offset = 0;\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    target.set(buf, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  if (offset < totalLength) {\r\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Masks a buffer using the given mask.\r\n *\r\n * @param {Buffer} source The buffer to mask\r\n * @param {Buffer} mask The mask to use\r\n * @param {Buffer} output The buffer where to store the result\r\n * @param {Number} offset The offset at which to start writing\r\n * @param {Number} length The number of bytes to mask.\r\n * @public\r\n */\r\nfunction _mask(source, mask, output, offset, length) {\r\n  for (let i = 0; i < length; i++) {\r\n    output[offset + i] = source[i] ^ mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Unmasks a buffer using the given mask.\r\n *\r\n * @param {Buffer} buffer The buffer to unmask\r\n * @param {Buffer} mask The mask to use\r\n * @public\r\n */\r\nfunction _unmask(buffer, mask) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    buffer[i] ^= mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} buf The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n * @public\r\n */\r\nfunction toArrayBuffer(buf) {\r\n  if (buf.length === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n}\r\n\r\n/**\r\n * Converts `data` to a `Buffer`.\r\n *\r\n * @param {*} data The data to convert\r\n * @return {Buffer} The buffer\r\n * @throws {TypeError}\r\n * @public\r\n */\r\nfunction toBuffer(data) {\r\n  toBuffer.readOnly = true;\r\n\r\n  if (Buffer.isBuffer(data)) return data;\r\n\r\n  let buf;\r\n\r\n  if (data instanceof ArrayBuffer) {\r\n    buf = new FastBuffer(data);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\r\n  } else {\r\n    buf = Buffer.from(data);\r\n    toBuffer.readOnly = false;\r\n  }\r\n\r\n  return buf;\r\n}\r\n\r\nmodule.exports = {\r\n  concat,\r\n  mask: _mask,\r\n  toArrayBuffer,\r\n  toBuffer,\r\n  unmask: _unmask\r\n};\r\n\r\n/* istanbul ignore else  */\r\nif (!process.env.WS_NO_BUFFER_UTIL) {\r\n  try {\r\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?32c4\");\r\n\r\n    module.exports.mask = function (source, mask, output, offset, length) {\r\n      if (length < 48) _mask(source, mask, output, offset, length);\r\n      else bufferUtil.mask(source, mask, output, offset, length);\r\n    };\r\n\r\n    module.exports.unmask = function (buffer, mask) {\r\n      if (buffer.length < 32) _unmask(buffer, mask);\r\n      else bufferUtil.unmask(buffer, mask);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUJBQVk7QUFDM0M7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxidWZmZXItdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XHJcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XHJcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XHJcblxyXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XHJcbiAgbGV0IG9mZnNldCA9IDA7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcclxuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xyXG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcclxuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcclxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcclxuICBpZiAoYnVmLmxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5sZW5ndGgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcclxuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XHJcblxyXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xyXG5cclxuICBsZXQgYnVmO1xyXG5cclxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcclxuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xyXG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XHJcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1ZjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgY29uY2F0LFxyXG4gIG1hc2s6IF9tYXNrLFxyXG4gIHRvQXJyYXlCdWZmZXIsXHJcbiAgdG9CdWZmZXIsXHJcbiAgdW5tYXNrOiBfdW5tYXNrXHJcbn07XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cclxuaWYgKCFwcm9jZXNzLmVudi5XU19OT19CVUZGRVJfVVRJTCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcclxuICAgICAgZWxzZSBidWZmZXJVdGlsLm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24gKGJ1ZmZlciwgbWFzaykge1xyXG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XHJcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\r\n\r\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\r\nconst hasBlob = typeof Blob !== 'undefined';\r\n\r\nif (hasBlob) BINARY_TYPES.push('blob');\r\n\r\nmodule.exports = {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER: Buffer.alloc(0),\r\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\r\n  hasBlob,\r\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\r\n  kListener: Symbol('kListener'),\r\n  kStatusCode: Symbol('status-code'),\r\n  kWebSocket: Symbol('websocket'),\r\n  NOOP: () => {}\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xyXG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xyXG5cclxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBCSU5BUllfVFlQRVMsXHJcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXHJcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXHJcbiAgaGFzQmxvYixcclxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXHJcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxyXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXHJcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcclxuICBOT09QOiAoKSA9PiB7fVxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst kCode = Symbol('kCode');\r\nconst kData = Symbol('kData');\r\nconst kError = Symbol('kError');\r\nconst kMessage = Symbol('kMessage');\r\nconst kReason = Symbol('kReason');\r\nconst kTarget = Symbol('kTarget');\r\nconst kType = Symbol('kType');\r\nconst kWasClean = Symbol('kWasClean');\r\n\r\n/**\r\n * Class representing an event.\r\n */\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\r\n  constructor(type) {\r\n    this[kTarget] = null;\r\n    this[kType] = type;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get target() {\r\n    return this[kTarget];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get type() {\r\n    return this[kType];\r\n  }\r\n}\r\n\r\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\r\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\r\n\r\n/**\r\n * Class representing a close event.\r\n *\r\n * @extends Event\r\n */\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kCode] = options.code === undefined ? 0 : options.code;\r\n    this[kReason] = options.reason === undefined ? '' : options.reason;\r\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get code() {\r\n    return this[kCode];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get reason() {\r\n    return this[kReason];\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get wasClean() {\r\n    return this[kWasClean];\r\n  }\r\n}\r\n\r\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\r\n\r\n/**\r\n * Class representing an error event.\r\n *\r\n * @extends Event\r\n */\r\nclass ErrorEvent extends Event {\r\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kError] = options.error === undefined ? null : options.error;\r\n    this[kMessage] = options.message === undefined ? '' : options.message;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get error() {\r\n    return this[kError];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get message() {\r\n    return this[kMessage];\r\n  }\r\n}\r\n\r\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\r\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\r\n\r\n/**\r\n * Class representing a message event.\r\n *\r\n * @extends Event\r\n */\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kData] = options.data === undefined ? null : options.data;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get data() {\r\n    return this[kData];\r\n  }\r\n}\r\n\r\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\r\n\r\n/**\r\n * This provides methods for emulating the `EventTarget` interface. It's not\r\n * meant to be used directly.\r\n *\r\n * @mixin\r\n */\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\r\n  addEventListener(type, handler, options = {}) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (\r\n        !options[kForOnEventAttribute] &&\r\n        listener[kListener] === handler &&\r\n        !listener[kForOnEventAttribute]\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    let wrapper;\r\n\r\n    if (type === 'message') {\r\n      wrapper = function onMessage(data, isBinary) {\r\n        const event = new MessageEvent('message', {\r\n          data: isBinary ? data : data.toString()\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'close') {\r\n      wrapper = function onClose(code, message) {\r\n        const event = new CloseEvent('close', {\r\n          code,\r\n          reason: message.toString(),\r\n          wasClean: this._closeFrameReceived && this._closeFrameSent\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'error') {\r\n      wrapper = function onError(error) {\r\n        const event = new ErrorEvent('error', {\r\n          error,\r\n          message: error.message\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'open') {\r\n      wrapper = function onOpen() {\r\n        const event = new Event('open');\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\r\n    wrapper[kListener] = handler;\r\n\r\n    if (options.once) {\r\n      this.once(type, wrapper);\r\n    } else {\r\n      this.on(type, wrapper);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener(type, handler) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\r\n        this.removeListener(type, listener);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  CloseEvent,\r\n  ErrorEvent,\r\n  Event,\r\n  EventTarget,\r\n  MessageEvent\r\n};\r\n\r\n/**\r\n * Call an event listener\r\n *\r\n * @param {(Function|Object)} listener The listener to call\r\n * @param {*} thisArg The value to use as `this`` when calling the listener\r\n * @param {Event} event The event to pass to the listener\r\n * @private\r\n */\r\nfunction callListener(listener, thisArg, event) {\r\n  if (typeof listener === 'object' && listener.handleEvent) {\r\n    listener.handleEvent.call(listener, event);\r\n  } else {\r\n    listener.call(thisArg, event);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekUseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxldmVudC10YXJnZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XHJcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xyXG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2tFcnJvcicpO1xyXG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcclxuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xyXG5jb25zdCBrVGFyZ2V0ID0gU3ltYm9sKCdrVGFyZ2V0Jyk7XHJcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xyXG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cclxuICovXHJcbmNsYXNzIEV2ZW50IHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGB0eXBlYCBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZSkge1xyXG4gICAgdGhpc1trVGFyZ2V0XSA9IG51bGw7XHJcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Kn1cclxuICAgKi9cclxuICBnZXQgdGFyZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCB0eXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1R5cGVdO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcclxuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcclxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbj0nJ10gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHlcclxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcclxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWRcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xyXG4gICAgdGhpc1trUmVhc29uXSA9IG9wdGlvbnMucmVhc29uID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMucmVhc29uO1xyXG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgY29kZSgpIHtcclxuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHJlYXNvbigpIHtcclxuICAgIHJldHVybiB0aGlzW2tSZWFzb25dO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHdhc0NsZWFuKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3JlYXNvbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBFdmVudFxyXG4gKi9cclxuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXHJcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcclxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmVycm9yPW51bGxdIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcih0eXBlKTtcclxuXHJcbiAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcclxuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHsqfVxyXG4gICAqL1xyXG4gIGdldCBlcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBtZXNzYWdlKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba01lc3NhZ2VdO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cclxuICpcclxuICogQGV4dGVuZHMgRXZlbnRcclxuICovXHJcbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcclxuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcih0eXBlKTtcclxuXHJcbiAgICB0aGlzW2tEYXRhXSA9IG9wdGlvbnMuZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHsqfVxyXG4gICAqL1xyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcclxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cclxuICpcclxuICogQG1peGluXHJcbiAqL1xyXG5jb25zdCBFdmVudFRhcmdldCA9IHtcclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXHJcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gYWRkXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XHJcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25jZT1mYWxzZV0gQSBgQm9vbGVhbmAgaW5kaWNhdGluZyB0aGF0IHRoZVxyXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcclxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV0gJiZcclxuICAgICAgICBsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmXHJcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgd3JhcHBlcjtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnKSB7XHJcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcclxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XHJcbiAgICAgICAgICBkYXRhOiBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xyXG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcclxuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xyXG4gICAgICAgICAgY29kZSxcclxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XHJcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xyXG4gICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcclxuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BlbicpIHtcclxuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcclxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xyXG5cclxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XHJcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XHJcbiAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBoYW5kbGVyO1xyXG5cclxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcclxuICAgICAgdGhpcy5vbmNlKHR5cGUsIHdyYXBwZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXHJcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xyXG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xyXG4gICAgICBpZiAobGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBDbG9zZUV2ZW50LFxyXG4gIEVycm9yRXZlbnQsXHJcbiAgRXZlbnQsXHJcbiAgRXZlbnRUYXJnZXQsXHJcbiAgTWVzc2FnZUV2ZW50XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lclxyXG4gKlxyXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBhcyBgdGhpc2BgIHdoZW4gY2FsbGluZyB0aGUgbGlzdGVuZXJcclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobGlzdGVuZXIsIHRoaXNBcmcsIGV2ZW50KSB7XHJcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcclxuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Adds an offer to the map of extension offers or a parameter to the map of\r\n * parameters.\r\n *\r\n * @param {Object} dest The map of extension offers or parameters\r\n * @param {String} name The extension or parameter name\r\n * @param {(Object|Boolean|String)} elem The extension parameters or the\r\n *     parameter value\r\n * @private\r\n */\r\nfunction push(dest, name, elem) {\r\n  if (dest[name] === undefined) dest[name] = [elem];\r\n  else dest[name].push(elem);\r\n}\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Extensions` header into an object.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Object} The parsed object\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const offers = Object.create(null);\r\n  let params = Object.create(null);\r\n  let mustUnescape = false;\r\n  let isEscaping = false;\r\n  let inQuotes = false;\r\n  let extensionName;\r\n  let paramName;\r\n  let start = -1;\r\n  let code = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (; i < header.length; i++) {\r\n    code = header.charCodeAt(i);\r\n\r\n    if (extensionName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (\r\n        i !== 0 &&\r\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n      ) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 0x2c) {\r\n          push(offers, name, params);\r\n          params = Object.create(null);\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20 || code === 0x09) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      //\r\n      // The value of a quoted-string after unescaping must conform to the\r\n      // token ABNF, so only token characters are valid.\r\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\r\n      //\r\n      if (isEscaping) {\r\n        if (tokenChars[code] !== 1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1) start = i;\r\n        else if (!mustUnescape) mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars[code] === 1) {\r\n          if (start === -1) start = i;\r\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 0x5c /* '\\' */) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\r\n        if (end === -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        let value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, '');\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        paramName = undefined;\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  if (end === -1) end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === undefined) {\r\n    push(offers, token, params);\r\n  } else {\r\n    if (paramName === undefined) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, ''));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n\r\n  return offers;\r\n}\r\n\r\n/**\r\n * Builds the `Sec-WebSocket-Extensions` header field value.\r\n *\r\n * @param {Object} extensions The map of extensions and parameters to format\r\n * @return {String} A string representing the given object\r\n * @public\r\n */\r\nfunction format(extensions) {\r\n  return Object.keys(extensions)\r\n    .map((extension) => {\r\n      let configurations = extensions[extension];\r\n      if (!Array.isArray(configurations)) configurations = [configurations];\r\n      return configurations\r\n        .map((params) => {\r\n          return [extension]\r\n            .concat(\r\n              Object.keys(params).map((k) => {\r\n                let values = params[k];\r\n                if (!Array.isArray(values)) values = [values];\r\n                return values\r\n                  .map((v) => (v === true ? k : `${k}=${v}`))\r\n                  .join('; ');\r\n              })\r\n            )\r\n            .join('; ');\r\n        })\r\n        .join(', ');\r\n    })\r\n    .join(', ');\r\n}\r\n\r\nmodule.exports = { format, parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcZXh0ZW5zaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxyXG4gKiBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZXh0ZW5zaW9uIG9yIHBhcmFtZXRlciBuYW1lXHJcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxyXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcclxuICBpZiAoZGVzdFtuYW1lXSA9PT0gdW5kZWZpbmVkKSBkZXN0W25hbWVdID0gW2VsZW1dO1xyXG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcclxuICBjb25zdCBvZmZlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcclxuICBsZXQgaXNFc2NhcGluZyA9IGZhbHNlO1xyXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xyXG4gIGxldCBleHRlbnNpb25OYW1lO1xyXG4gIGxldCBwYXJhbU5hbWU7XHJcbiAgbGV0IHN0YXJ0ID0gLTE7XHJcbiAgbGV0IGNvZGUgPSAtMTtcclxuICBsZXQgZW5kID0gLTE7XHJcbiAgbGV0IGkgPSAwO1xyXG5cclxuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICBpICE9PSAwICYmXHJcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xyXG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcclxuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xyXG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzZCAvKiAnPScgKi8gJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcclxuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xyXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXHJcbiAgICAgIC8vIHRva2VuIEFCTkYsIHNvIG9ubHkgdG9rZW4gY2hhcmFjdGVycyBhcmUgdmFsaWQuXHJcbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcclxuICAgICAgLy9cclxuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcclxuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xyXG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xyXG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XHJcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgZW5kID0gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xyXG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xyXG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcclxuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcclxuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJhbU5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcclxuICB9XHJcblxyXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwgcGFyYW1zKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHB1c2gocGFyYW1zLCB0b2tlbiwgdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xyXG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XHJcbiAgICB9XHJcbiAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvZmZlcnM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIG1hcCBvZiBleHRlbnNpb25zIGFuZCBwYXJhbWV0ZXJzIHRvIGZvcm1hdFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXHJcbiAgICAubWFwKChleHRlbnNpb24pID0+IHtcclxuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XHJcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uc1xyXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXHJcbiAgICAgICAgICAgIC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkgdmFsdWVzID0gW3ZhbHVlc107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcclxuICAgICAgICAgICAgICAgICAgLmpvaW4oJzsgJyk7XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuam9pbignOyAnKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgfSlcclxuICAgIC5qb2luKCcsICcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\r\n\r\nconst kDone = Symbol('kDone');\r\nconst kRun = Symbol('kRun');\r\n\r\n/**\r\n * A very simple job queue with adjustable concurrency. Adapted from\r\n * https://github.com/STRML/async-limiter\r\n */\r\nclass Limiter {\r\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\r\n  constructor(concurrency) {\r\n    this[kDone] = () => {\r\n      this.pending--;\r\n      this[kRun]();\r\n    };\r\n    this.concurrency = concurrency || Infinity;\r\n    this.jobs = [];\r\n    this.pending = 0;\r\n  }\r\n\r\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\r\n  add(job) {\r\n    this.jobs.push(job);\r\n    this[kRun]();\r\n  }\r\n\r\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\r\n  [kRun]() {\r\n    if (this.pending === this.concurrency) return;\r\n\r\n    if (this.jobs.length) {\r\n      const job = this.jobs.shift();\r\n\r\n      this.pending++;\r\n      job(this[kDone]);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Limiter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcbGltaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcclxuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xyXG5cclxuLyoqXHJcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXHJcbiAqL1xyXG5jbGFzcyBMaW1pdGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcclxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XHJcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcclxuICAgICAgdGhpcy5wZW5kaW5nLS07XHJcbiAgICAgIHRoaXNba1J1bl0oKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XHJcbiAgICB0aGlzLmpvYnMgPSBbXTtcclxuICAgIHRoaXMucGVuZGluZyA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBhZGQoam9iKSB7XHJcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xyXG4gICAgdGhpc1trUnVuXSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW2tSdW5dKCkge1xyXG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xyXG5cclxuICAgICAgdGhpcy5wZW5kaW5nKys7XHJcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\n\r\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./node_modules/ws/lib/limiter.js\");\r\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst kPerMessageDeflate = Symbol('permessage-deflate');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\r\n  constructor(options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold =\r\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency =\r\n        this._options.concurrencyLimit !== undefined\r\n          ? this._options.concurrencyLimit\r\n          : 10;\r\n      zlibLimiter = new Limiter(concurrency);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName() {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer() {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept(configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n\r\n    this.params = this._isServer\r\n      ? this.acceptAsServer(configurations)\r\n      : this.acceptAsClient(configurations);\r\n\r\n    return this.params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup() {\r\n    if (this._inflate) {\r\n      this._inflate.close();\r\n      this._inflate = null;\r\n    }\r\n\r\n    if (this._deflate) {\r\n      const callback = this._deflate[kCallback];\r\n\r\n      this._deflate.close();\r\n      this._deflate = null;\r\n\r\n      if (callback) {\r\n        callback(\r\n          new Error(\r\n            'The deflate stream was closed while data was being processed'\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer(offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (\r\n        (opts.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (params.server_max_window_bits &&\r\n          (opts.serverMaxWindowBits === false ||\r\n            (typeof opts.serverMaxWindowBits === 'number' &&\r\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\r\n        (typeof opts.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    if (!accepted) {\r\n      throw new Error('None of the extension offers can be accepted');\r\n    }\r\n\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === 'number') {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === 'number') {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (\r\n      accepted.client_max_window_bits === true ||\r\n      opts.clientMaxWindowBits === false\r\n    ) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient(response) {\r\n    const params = response[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (\r\n      this._options.clientMaxWindowBits === false ||\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\r\n    ) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams(configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        let value = params[key];\r\n\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        if (key === 'client_max_window_bits') {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === 'server_max_window_bits') {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (\r\n          key === 'client_no_context_takeover' ||\r\n          key === 'server_no_context_takeover'\r\n        ) {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n\r\n        params[key] = value;\r\n      });\r\n    });\r\n\r\n    return configurations;\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw({\r\n        ...this._options.zlibInflateOptions,\r\n        windowBits\r\n      });\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (this._inflate._readableState.endEmitted) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n\r\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n          this._inflate.reset();\r\n        }\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw({\r\n        ...this._options.zlibDeflateOptions,\r\n        windowBits\r\n      });\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kCallback] = callback;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      if (!this._deflate) {\r\n        //\r\n        // The deflate stream was closed while data was being processed.\r\n        //\r\n        return;\r\n      }\r\n\r\n      let data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) {\r\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\r\n      }\r\n\r\n      //\r\n      // Ensure that the callback will not be called again in\r\n      // `PerMessageDeflate#cleanup()`.\r\n      //\r\n      this._deflate[kCallback] = null;\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n        this._deflate.reset();\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData(chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData(chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kPerMessageDeflate]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new RangeError('Max payload size exceeded');\r\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\r\n  this[kError][kStatusCode] = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n\r\n  //\r\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\r\n  // fact that in Node.js versions prior to 13.10.0, the callback for\r\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\r\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\r\n  // emitted.\r\n  //\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError(err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kPerMessageDeflate]._inflate = null;\r\n\r\n  if (this[kError]) {\r\n    this[kCallback](this[kError]);\r\n    return;\r\n  }\r\n\r\n  err[kStatusCode] = 1007;\r\n  this[kCallback](err);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMseURBQVc7QUFDbkMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxwZXJtZXNzYWdlLWRlZmxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcclxuXHJcbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XHJcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcclxuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuXHJcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xyXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcclxuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcclxuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcclxuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xyXG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xyXG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XHJcblxyXG4vL1xyXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cclxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xyXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcclxuLy9cclxuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXHJcbi8vXHJcbmxldCB6bGliTGltaXRlcjtcclxuXHJcbi8qKlxyXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XHJcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xyXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XHJcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcclxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XHJcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXHJcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cclxuICAgKiAgICAgZGVmbGF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXHJcbiAgICogICAgIGluZmxhdGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXHJcbiAgICogICAgIGNsaWVudCBtb2RlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xyXG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxyXG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xyXG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xyXG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XHJcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XHJcblxyXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xyXG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XHJcbiAgICAgICAgICA6IDEwO1xyXG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xyXG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgb2ZmZXIoKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcclxuXHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xyXG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcclxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcclxuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XHJcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xyXG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xyXG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXHJcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xlYW51cCgpIHtcclxuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XHJcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcclxuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XHJcblxyXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2soXHJcbiAgICAgICAgICBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xyXG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxyXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxyXG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxyXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcclxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcclxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghYWNjZXB0ZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XHJcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XHJcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xyXG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XHJcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcclxuICAgICkge1xyXG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWNjZXB0ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXHJcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxyXG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxyXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcclxuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xyXG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcclxuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XHJcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XHJcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhbHVlID0gbnVtO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcclxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XHJcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcclxuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xyXG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XHJcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29tcHJlc3MgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xyXG5cclxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xyXG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcclxuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XHJcbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXHJcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcclxuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcclxuXHJcbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xyXG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxyXG4gICAgICAgIHdpbmRvd0JpdHNcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XHJcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XHJcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XHJcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xyXG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XHJcblxyXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcclxuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XHJcblxyXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcclxuXHJcbiAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XHJcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcclxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcclxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcclxuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wcmVzcyBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcclxuXHJcbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcclxuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XHJcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxyXG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXHJcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XHJcblxyXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcclxuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcclxuICAgICAgICB3aW5kb3dCaXRzXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcclxuXHJcbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xyXG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcclxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcclxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChmaW4pIHtcclxuICAgICAgICBkYXRhID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGggLSA0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9cclxuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxyXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cclxuICAgICAgLy9cclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XHJcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XHJcblxyXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcclxuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XHJcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XHJcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XHJcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcclxuXHJcbiAgaWYgKFxyXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxyXG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxyXG4gICkge1xyXG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xyXG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XHJcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xyXG5cclxuICAvL1xyXG4gIC8vIFRoZSBjaG9pY2UgdG8gZW1wbG95IGB6bGliLnJlc2V0KClgIG92ZXIgYHpsaWIuY2xvc2UoKWAgaXMgZGljdGF0ZWQgYnkgdGhlXHJcbiAgLy8gZmFjdCB0aGF0IGluIE5vZGUuanMgdmVyc2lvbnMgcHJpb3IgdG8gMTMuMTAuMCwgdGhlIGNhbGxiYWNrIGZvclxyXG4gIC8vIGB6bGliLmZsdXNoKClgIGlzIG5vdCBjYWxsZWQgaWYgYHpsaWIuY2xvc2UoKWAgaXMgdXNlZC4gVXRpbGl6aW5nXHJcbiAgLy8gYHpsaWIucmVzZXQoKWAgZW5zdXJlcyB0aGF0IGVpdGhlciB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCBvciBhbiBlcnJvciBpc1xyXG4gIC8vIGVtaXR0ZWQuXHJcbiAgLy9cclxuICB0aGlzLnJlc2V0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XHJcbiAgLy9cclxuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XHJcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cclxuICAvL1xyXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XHJcblxyXG4gIGlmICh0aGlzW2tFcnJvcl0pIHtcclxuICAgIHRoaXNba0NhbGxiYWNrXSh0aGlzW2tFcnJvcl0pO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XHJcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  kStatusCode,\r\n  kWebSocket\r\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\nconst DEFER_EVENT = 6;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends Writable\r\n */\r\nclass Receiver extends Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    this._allowSynchronousEvents =\r\n      options.allowSynchronousEvents !== undefined\r\n        ? options.allowSynchronousEvents\r\n        : true;\r\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\r\n    this._extensions = options.extensions || {};\r\n    this._isServer = !!options.isServer;\r\n    this._maxPayload = options.maxPayload | 0;\r\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\r\n    this[kWebSocket] = undefined;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = undefined;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._errored = false;\r\n    this._loop = false;\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  _write(chunk, encoding, cb) {\r\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\r\n\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume(n) {\r\n    this._bufferedBytes -= n;\r\n\r\n    if (n === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = new FastBuffer(\r\n        buf.buffer,\r\n        buf.byteOffset + n,\r\n        buf.length - n\r\n      );\r\n\r\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\r\n    }\r\n\r\n    const dst = Buffer.allocUnsafe(n);\r\n\r\n    do {\r\n      const buf = this._buffers[0];\r\n      const offset = dst.length - n;\r\n\r\n      if (n >= buf.length) {\r\n        dst.set(this._buffers.shift(), offset);\r\n      } else {\r\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\r\n        this._buffers[0] = new FastBuffer(\r\n          buf.buffer,\r\n          buf.byteOffset + n,\r\n          buf.length - n\r\n        );\r\n      }\r\n\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop(cb) {\r\n    this._loop = true;\r\n\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          this.getInfo(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          this.getPayloadLength16(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          this.getPayloadLength64(cb);\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          this.getData(cb);\r\n          break;\r\n        case INFLATING:\r\n        case DEFER_EVENT:\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n\r\n    if (!this._errored) cb();\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getInfo(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV2 and RSV3 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_2_3'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV1 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_1'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'invalid opcode 0',\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid opcode ${this._opcode}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'FIN must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_FIN'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        this._payloadLength > 0x7d ||\r\n        (this._opcode === 0x08 && this._payloadLength === 1)\r\n      ) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else {\r\n      const error = this.createError(\r\n        RangeError,\r\n        `invalid opcode ${this._opcode}`,\r\n        true,\r\n        1002,\r\n        'WS_ERR_INVALID_OPCODE'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._isServer) {\r\n      if (!this._masked) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'MASK must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_MASK'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else if (this._masked) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'MASK must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_MASK'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength16(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength64(cb) {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\r\n        false,\r\n        1009,\r\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  haveLength(cb) {\r\n    if (this._payloadLength && this._opcode < 0x08) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'Max payload size exceeded',\r\n          false,\r\n          1009,\r\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask() {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getData(cb) {\r\n    let data = EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n\r\n      data = this.consume(this._payloadLength);\r\n\r\n      if (\r\n        this._masked &&\r\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\r\n      ) {\r\n        unmask(data, this._mask);\r\n      }\r\n    }\r\n\r\n    if (this._opcode > 0x07) {\r\n      this.controlMessage(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (data.length) {\r\n      //\r\n      // This message is not compressed so its length is the sum of the payload\r\n      // length of all fragments.\r\n      //\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n\r\n    this.dataMessage(cb);\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress(data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) return cb(err);\r\n\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            'Max payload size exceeded',\r\n            false,\r\n            1009,\r\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._fragments.push(buf);\r\n      }\r\n\r\n      this.dataMessage(cb);\r\n      if (this._state === GET_INFO) this.startLoop(cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  dataMessage(cb) {\r\n    if (!this._fin) {\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    const messageLength = this._messageLength;\r\n    const fragments = this._fragments;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragmented = 0;\r\n    this._fragments = [];\r\n\r\n    if (this._opcode === 2) {\r\n      let data;\r\n\r\n      if (this._binaryType === 'nodebuffer') {\r\n        data = concat(fragments, messageLength);\r\n      } else if (this._binaryType === 'arraybuffer') {\r\n        data = toArrayBuffer(concat(fragments, messageLength));\r\n      } else if (this._binaryType === 'blob') {\r\n        data = new Blob(fragments);\r\n      } else {\r\n        data = fragments;\r\n      }\r\n\r\n      if (this._allowSynchronousEvents) {\r\n        this.emit('message', data, true);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', data, true);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    } else {\r\n      const buf = concat(fragments, messageLength);\r\n\r\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n        const error = this.createError(\r\n          Error,\r\n          'invalid UTF-8 sequence',\r\n          true,\r\n          1007,\r\n          'WS_ERR_INVALID_UTF8'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\r\n        this.emit('message', buf, false);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', buf, false);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage(data, cb) {\r\n    if (this._opcode === 0x08) {\r\n      if (data.length === 0) {\r\n        this._loop = false;\r\n        this.emit('conclude', 1005, EMPTY_BUFFER);\r\n        this.end();\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n\r\n        if (!isValidStatusCode(code)) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            `invalid status code ${code}`,\r\n            true,\r\n            1002,\r\n            'WS_ERR_INVALID_CLOSE_CODE'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        const buf = new FastBuffer(\r\n          data.buffer,\r\n          data.byteOffset + 2,\r\n          data.length - 2\r\n        );\r\n\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          const error = this.createError(\r\n            Error,\r\n            'invalid UTF-8 sequence',\r\n            true,\r\n            1007,\r\n            'WS_ERR_INVALID_UTF8'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._loop = false;\r\n        this.emit('conclude', code, buf);\r\n        this.end();\r\n      }\r\n\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    if (this._allowSynchronousEvents) {\r\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n      this._state = GET_INFO;\r\n    } else {\r\n      this._state = DEFER_EVENT;\r\n      setImmediate(() => {\r\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n        this._state = GET_INFO;\r\n        this.startLoop(cb);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds an error object.\r\n   *\r\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\r\n   * @param {String} message The error message\r\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n   *     `message`\r\n   * @param {Number} statusCode The status code\r\n   * @param {String} errorCode The exposed error code\r\n   * @return {(Error|RangeError)} The error\r\n   * @private\r\n   */\r\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\r\n    this._loop = false;\r\n    this._errored = true;\r\n\r\n    const err = new ErrorCtor(\r\n      prefix ? `Invalid WebSocket frame: ${message}` : message\r\n    );\r\n\r\n    Error.captureStackTrace(err, this.createError);\r\n    err.code = errorCode;\r\n    err[kStatusCode] = statusCode;\r\n    return err;\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QixRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDakUsUUFBUSxpQ0FBaUMsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHJlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5cclxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCB7XHJcbiAgQklOQVJZX1RZUEVTLFxyXG4gIEVNUFRZX0JVRkZFUixcclxuICBrU3RhdHVzQ29kZSxcclxuICBrV2ViU29ja2V0XHJcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XHJcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuXHJcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xyXG5cclxuY29uc3QgR0VUX0lORk8gPSAwO1xyXG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xyXG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xyXG5jb25zdCBHRVRfTUFTSyA9IDM7XHJcbmNvbnN0IEdFVF9EQVRBID0gNDtcclxuY29uc3QgSU5GTEFUSU5HID0gNTtcclxuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xyXG5cclxuLyoqXHJcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHRlbmRzIFdyaXRhYmxlXHJcbiAqL1xyXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXHJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXHJcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWRcclxuICAgKiAgICAgZXh0ZW5zaW9uc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cclxuICAgKiAgICAgY2xpZW50IG9yIHNlcnZlciBtb2RlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxyXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cclxuICAgICAgb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50c1xyXG4gICAgICAgIDogdHJ1ZTtcclxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBvcHRpb25zLmJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xyXG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcclxuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xyXG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZCB8IDA7XHJcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xyXG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcclxuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcclxuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZmluID0gZmFsc2U7XHJcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xyXG5cclxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2Vycm9yZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XHJcblxyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XHJcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xyXG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgY29uc3VtZShuKSB7XHJcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XHJcblxyXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xyXG5cclxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcclxuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxyXG4gICAgICAgIGJ1Zi5idWZmZXIsXHJcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxyXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XHJcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xyXG5cclxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xyXG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcclxuICAgICAgICAgIGJ1Zi5idWZmZXIsXHJcbiAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXHJcbiAgICAgICAgICBidWYubGVuZ3RoIC0gblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcclxuICAgIH0gd2hpbGUgKG4gPiAwKTtcclxuXHJcbiAgICByZXR1cm4gZHN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhcnRMb29wKGNiKSB7XHJcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcclxuICAgICAgICBjYXNlIEdFVF9JTkZPOlxyXG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxyXG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XHJcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEdFVF9NQVNLOlxyXG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEdFVF9EQVRBOlxyXG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgSU5GTEFUSU5HOlxyXG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XHJcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xyXG5cclxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRJbmZvKGNiKSB7XHJcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcclxuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xyXG5cclxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICAxMDAyLFxyXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcclxuXHJcbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xyXG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcclxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xyXG5cclxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcclxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcclxuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xyXG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcclxuICAgICAgICAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICAxMDAyLFxyXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcclxuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcclxuXHJcbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcclxuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICAxMDAyLFxyXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XHJcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xyXG4gICAgZWxzZSB0aGlzLmhhdmVMZW5ndGgoY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0UGF5bG9hZExlbmd0aDE2KGNiKSB7XHJcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcclxuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XHJcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0UGF5bG9hZExlbmd0aDY0KGNiKSB7XHJcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcclxuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xyXG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXHJcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXHJcbiAgICAvL1xyXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICAxMDA5LFxyXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNiKGVycm9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xyXG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgaGF2ZUxlbmd0aChjYikge1xyXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xyXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcclxuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxyXG4gICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAxMDA5LFxyXG4gICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcclxuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldE1hc2soKSB7XHJcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcclxuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcclxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldERhdGEoY2IpIHtcclxuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xyXG5cclxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fbWFza2VkICYmXHJcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXHJcbiAgICAgICkge1xyXG4gICAgICAgIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XHJcbiAgICAgIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcclxuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XHJcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIG5vdCBjb21wcmVzc2VkIHNvIGl0cyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgcGF5bG9hZFxyXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cclxuICAgICAgLy9cclxuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcclxuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XHJcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XHJcblxyXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xyXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcclxuXHJcbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAxMDA5LFxyXG4gICAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBHRVRfSU5GTykgdGhpcy5zdGFydExvb3AoY2IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRhdGFNZXNzYWdlKGNiKSB7XHJcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XHJcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XHJcblxyXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XHJcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcclxuXHJcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XHJcbiAgICAgIGxldCBkYXRhO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xyXG4gICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XHJcbiAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xyXG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcclxuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICBFcnJvcixcclxuICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDA3LFxyXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcgfHwgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xyXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcclxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XHJcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcclxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjb250cm9sTWVzc2FnZShkYXRhLCBjYikge1xyXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xyXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XHJcbiAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XHJcblxyXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcclxuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DTE9TRV9DT0RFJ1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcclxuICAgICAgICAgIGRhdGEuYnVmZmVyLFxyXG4gICAgICAgICAgZGF0YS5ieXRlT2Zmc2V0ICsgMixcclxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XHJcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICAgIEVycm9yLFxyXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXHJcbiAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgIDEwMDcsXHJcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zik7XHJcbiAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XHJcbiAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcclxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICB0aGlzLmVtaXQodGhpcy5fb3Bjb2RlID09PSAweDA5ID8gJ3BpbmcnIDogJ3BvbmcnLCBkYXRhKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZml4IFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBhZGQgYSBkZWZhdWx0IHByZWZpeCB0b1xyXG4gICAqICAgICBgbWVzc2FnZWBcclxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JDb2RlIFRoZSBleHBvc2VkIGVycm9yIGNvZGVcclxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgY3JlYXRlRXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xyXG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZXJyb3JlZCA9IHRydWU7XHJcblxyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcclxuICAgICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcclxuICAgICk7XHJcblxyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCB0aGlzLmNyZWF0ZUVycm9yKTtcclxuICAgIGVyci5jb2RlID0gZXJyb3JDb2RlO1xyXG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XHJcbiAgICByZXR1cm4gZXJyO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\r\n * HyBi Sender implementation.\r\n */ class Sender {\n    /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {Duplex} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === 'string') {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n            throw new TypeError('First argument must be a valid error code number');\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError('The message must not be greater than 123 bytes');\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === 'string') {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\r\n   * Gets the contents of a blob as binary data.\r\n   *\r\n   * @param {Blob} blob The blob\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     the data\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while the blob was being read');\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while data was being compressed');\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {(Buffer | String)[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\r\n * Calls queued callbacks with an error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error to call the callbacks with\r\n * @param {Function} [cb] The first callback\r\n * @private\r\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === 'function') cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === 'function') callback(err);\n    }\n}\n/**\r\n * Handles a `Sender` error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error\r\n * @param {Function} [cb] The first pending callback\r\n * @private\r\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0UsR0FFM0Q7QUFFYixNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNuQyxNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUUzQyxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDLCtFQUFzQjtBQUN4RCxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsNkRBQWE7QUFDaEUsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLCtEQUFjO0FBQzVELE1BQU0sRUFBRVEsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsaUVBQWU7QUFFN0QsTUFBTVcsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFFdEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7O0dBT0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUM1QyxJQUFJLENBQUNDLFdBQVcsR0FBR0YsY0FBYyxDQUFDO1FBRWxDLElBQUlDLGNBQWM7WUFDaEIsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1lBQ3JCLElBQUksQ0FBQ0csV0FBVyxHQUFHZixPQUFPQyxLQUFLLENBQUM7UUFDbEM7UUFFQSxJQUFJLENBQUNlLE9BQU8sR0FBR047UUFFZixJQUFJLENBQUNPLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVq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QUFNQyxXQUFXN0IsTUFBTSxDQUFDQSxPQUFPL0IsTUFBTSxHQUFHLEVBQUU7UUFFMUMsSUFBSSxPQUFPNEQsYUFBYSxZQUFZQSxTQUFTckI7SUFDL0M7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTyxRQUFRWSxNQUFNLEVBQUVuQixHQUFHLEVBQUUzQixFQUFFO0lBQzlCK0IsY0FBY2UsUUFBUW5CLEtBQUszQjtJQUMzQjhDLE9BQU9wRSxPQUFPLENBQUNpRDtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHNlbmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXhcIiB9XSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcclxuY29uc3QgeyBFTVBUWV9CVUZGRVIsIGtXZWJTb2NrZXQsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHsgaXNCbG9iLCBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XHJcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xyXG5cclxuY29uc3Qga0J5dGVMZW5ndGggPSBTeW1ib2woJ2tCeXRlTGVuZ3RoJyk7XHJcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XHJcbmNvbnN0IFJBTkRPTV9QT09MX1NJWkUgPSA4ICogMTAyNDtcclxubGV0IHJhbmRvbVBvb2w7XHJcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XHJcblxyXG5jb25zdCBERUZBVUxUID0gMDtcclxuY29uc3QgREVGTEFUSU5HID0gMTtcclxuY29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XHJcblxyXG4vKipcclxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5jbGFzcyBTZW5kZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXHJcbiAgICogICAgIGtleVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XHJcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcclxuXHJcbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XHJcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcclxuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XHJcblxyXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XHJcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xyXG4gICAgdGhpcy5fcXVldWUgPSBbXTtcclxuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcclxuICAgIHRoaXMub25lcnJvciA9IE5PT1A7XHJcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBGSU4gYml0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcclxuICAgKiAgICAgbWFza2luZyBrZXlcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcclxuICAgKiAgICAga2V5XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXHJcbiAgICogICAgIG1vZGlmaWVkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBSU1YxIGJpdFxyXG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcclxuICAgIGxldCBtYXNrO1xyXG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMjtcclxuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChvcHRpb25zLm1hc2spIHtcclxuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XHJcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHJhbmRvbVBvb2xQb2ludGVyID09PSBSQU5ET01fUE9PTF9TSVpFKSB7XHJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cclxuICAgICAgICAgIGlmIChyYW5kb21Qb29sID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcclxuICAgICAgICAgICAgLy8gYmUgbWFza2VkIHNvIGl0IG1heSBuZXZlciBiZSB1c2VkLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xyXG4gICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWFza1swXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XHJcbiAgICAgICAgbWFza1sxXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XHJcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XHJcbiAgICAgICAgbWFza1szXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xyXG4gICAgICBvZmZzZXQgPSA2O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkYXRhTGVuZ3RoO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxyXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcclxuICAgICAgKSB7XHJcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcclxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xyXG5cclxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XHJcbiAgICAgIG9mZnNldCArPSA4O1xyXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xyXG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XHJcbiAgICAgIG9mZnNldCArPSAyO1xyXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xyXG5cclxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XHJcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcclxuXHJcbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xyXG5cclxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcclxuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XHJcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xyXG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xyXG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcclxuXHJcbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcclxuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XHJcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xyXG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcclxuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XHJcblxyXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XHJcblxyXG4gICAgaWYgKG1lcmdlKSB7XHJcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XHJcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcclxuICAgIH1cclxuXHJcbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XHJcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgbGV0IGJ1ZjtcclxuXHJcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xyXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XHJcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcblxyXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xyXG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2ssXHJcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXHJcbiAgICAgIG9wY29kZTogMHgwOCxcclxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxyXG4gICAgICByc3YxOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcclxuICAgIGxldCBieXRlTGVuZ3RoO1xyXG4gICAgbGV0IHJlYWRPbmx5O1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcclxuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcclxuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XHJcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxyXG4gICAgICBmaW46IHRydWUsXHJcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxyXG4gICAgICBtYXNrLFxyXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxyXG4gICAgICBvcGNvZGU6IDB4MDksXHJcbiAgICAgIHJlYWRPbmx5LFxyXG4gICAgICByc3YxOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcclxuICAgIGxldCBieXRlTGVuZ3RoO1xyXG4gICAgbGV0IHJlYWRPbmx5O1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcclxuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcclxuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XHJcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxyXG4gICAgICBmaW46IHRydWUsXHJcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxyXG4gICAgICBtYXNrLFxyXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxyXG4gICAgICBvcGNvZGU6IDB4MGEsXHJcbiAgICAgIHJlYWRPbmx5LFxyXG4gICAgICByc3YxOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XHJcbiAgICogICAgIG9yIHRleHRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cclxuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcclxuICAgKiAgICAgbGFzdCBvbmVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xyXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xyXG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XHJcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XHJcblxyXG4gICAgbGV0IGJ5dGVMZW5ndGg7XHJcbiAgICBsZXQgcmVhZE9ubHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcclxuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcnN2MSAmJlxyXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlICYmXHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xyXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXHJcbiAgICAgICAgICAgID8gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xyXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcclxuICAgICAgICBdXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcnN2MSA9IGZhbHNlO1xyXG4gICAgICBvcGNvZGUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcclxuICAgICAgZmluOiBvcHRpb25zLmZpbixcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcclxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcclxuICAgICAgb3Bjb2RlLFxyXG4gICAgICByZWFkT25seSxcclxuICAgICAgcnN2MVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiBhIGJsb2IgYXMgYmluYXJ5IGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2JcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXHJcbiAgICogICAgIHRoZSBkYXRhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgRklOIGJpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXHJcbiAgICogICAgIG1hc2tpbmcga2V5XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xyXG4gICAqICAgICBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXHJcbiAgICogICAgIGtleVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxyXG4gICAqICAgICBtb2RpZmllZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgUlNWMSBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9CTE9CX0RBVEE7XHJcblxyXG4gICAgYmxvYlxyXG4gICAgICAuYXJyYXlCdWZmZXIoKVxyXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xyXG4gICAgICAgICAgLy8gdGhhdCBtaWdodCBiZSB0aHJvd24gaW4gdGhlIGNhbGxiYWNrcyBiZWhhdmUgbGlrZSBlcnJvcnMgdGhyb3duXHJcbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxyXG4gICAgICAgICAgLy9cclxuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbENhbGxiYWNrcywgdGhpcywgZXJyLCBjYik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b0J1ZmZlcihhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcclxuICAgICAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcclxuICAgICAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBgb25FcnJvcmAgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgZm9yIHRoZSBzYW1lIHJlYXNvbiB0aGF0XHJcbiAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGFib3ZlIGlzLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVycm9yLCB0aGlzLCBlcnIsIGNiKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIEZJTiBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gICAqICAgICBtYXNraW5nIGtleVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xyXG4gICAqICAgICBrZXlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcclxuICAgKiAgICAgbW9kaWZpZWRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIFJTVjEgYml0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XHJcbiAgICBpZiAoIWNvbXByZXNzKSB7XHJcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xyXG5cclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkxBVElORztcclxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNhbGxDYWxsYmFja3ModGhpcywgZXJyLCBjYik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XHJcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcclxuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcclxuICAgICAgdGhpcy5kZXF1ZXVlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRlcXVldWUoKSB7XHJcbiAgICB3aGlsZSAodGhpcy5fc3RhdGUgPT09IERFRkFVTFQgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XHJcblxyXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XHJcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZW5xdWV1ZShwYXJhbXMpIHtcclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcclxuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgZnJhbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXIgfCBTdHJpbmcpW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcclxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xyXG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XHJcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XHJcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcclxuXHJcbi8qKlxyXG4gKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgY2FsbGJhY2tcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKSB7XHJcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZW5kZXIuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuX3F1ZXVlW2ldO1xyXG4gICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBhIGBTZW5kZXJgIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XHJcbiAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xyXG4gIHNlbmRlci5vbmVycm9yKGVycik7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJyYW5kb21GaWxsU3luYyIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiRU1QVFlfQlVGRkVSIiwia1dlYlNvY2tldCIsIk5PT1AiLCJpc0Jsb2IiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsIm1hc2siLCJhcHBseU1hc2siLCJ0b0J1ZmZlciIsImtCeXRlTGVuZ3RoIiwiU3ltYm9sIiwibWFza0J1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiUkFORE9NX1BPT0xfU0laRSIsInJhbmRvbVBvb2wiLCJyYW5kb21Qb29sUG9pbnRlciIsIkRFRkFVTFQiLCJERUZMQVRJTkciLCJHRVRfQkxPQl9EQVRBIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiZ2VuZXJhdGVNYXNrIiwiX2V4dGVuc2lvbnMiLCJfZ2VuZXJhdGVNYXNrIiwiX21hc2tCdWZmZXIiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9xdWV1ZSIsIl9zdGF0ZSIsIm9uZXJyb3IiLCJ1bmRlZmluZWQiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJvZmZzZXQiLCJza2lwTWFza2luZyIsImRhdGFMZW5ndGgiLCJmcm9tIiwibGVuZ3RoIiwicmVhZE9ubHkiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiY2xvc2UiLCJjb2RlIiwiY2IiLCJidWYiLCJUeXBlRXJyb3IiLCJieXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsIndyaXRlIiwic2V0IiwiZW5xdWV1ZSIsImRpc3BhdGNoIiwic2VuZEZyYW1lIiwicGluZyIsInNpemUiLCJnZXRCbG9iRGF0YSIsInBvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJwYXJhbXMiLCJfaXNTZXJ2ZXIiLCJfdGhyZXNob2xkIiwib3B0cyIsImJsb2IiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJkZXN0cm95ZWQiLCJlcnIiLCJFcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGxDYWxsYmFja3MiLCJkZXF1ZXVlIiwiY2F0Y2giLCJvbkVycm9yIiwiXyIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VuZGVyIiwiaSIsImNhbGxiYWNrIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\r\n\r\n\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\n/**\r\n * Emits the `'close'` event on a stream.\r\n *\r\n * @param {Duplex} stream The stream.\r\n * @private\r\n */\r\nfunction emitClose(stream) {\r\n  stream.emit('close');\r\n}\r\n\r\n/**\r\n * The listener of the `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction duplexOnEnd() {\r\n  if (!this.destroyed && this._writableState.finished) {\r\n    this.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `'error'` event.\r\n *\r\n * @param {Error} err The error\r\n * @private\r\n */\r\nfunction duplexOnError(err) {\r\n  this.removeListener('error', duplexOnError);\r\n  this.destroy();\r\n  if (this.listenerCount('error') === 0) {\r\n    // Do not suppress the throwing behavior.\r\n    this.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Wraps a `WebSocket` in a duplex stream.\r\n *\r\n * @param {WebSocket} ws The `WebSocket` to wrap\r\n * @param {Object} [options] The options for the `Duplex` constructor\r\n * @return {Duplex} The duplex stream\r\n * @public\r\n */\r\nfunction createWebSocketStream(ws, options) {\r\n  let terminateOnDestroy = true;\r\n\r\n  const duplex = new Duplex({\r\n    ...options,\r\n    autoDestroy: false,\r\n    emitClose: false,\r\n    objectMode: false,\r\n    writableObjectMode: false\r\n  });\r\n\r\n  ws.on('message', function message(msg, isBinary) {\r\n    const data =\r\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\r\n\r\n    if (!duplex.push(data)) ws.pause();\r\n  });\r\n\r\n  ws.once('error', function error(err) {\r\n    if (duplex.destroyed) return;\r\n\r\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\r\n    //\r\n    // - If the `'error'` event is emitted before the `'open'` event, then\r\n    //   `ws.terminate()` is a noop as no socket is assigned.\r\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\r\n    //   event of the `Receiver` object. The listener already closes the\r\n    //   connection by calling `ws.close()`. This allows a close frame to be\r\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\r\n    //   then the close frame might not be sent.\r\n    terminateOnDestroy = false;\r\n    duplex.destroy(err);\r\n  });\r\n\r\n  ws.once('close', function close() {\r\n    if (duplex.destroyed) return;\r\n\r\n    duplex.push(null);\r\n  });\r\n\r\n  duplex._destroy = function (err, callback) {\r\n    if (ws.readyState === ws.CLOSED) {\r\n      callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n      return;\r\n    }\r\n\r\n    let called = false;\r\n\r\n    ws.once('error', function error(err) {\r\n      called = true;\r\n      callback(err);\r\n    });\r\n\r\n    ws.once('close', function close() {\r\n      if (!called) callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n    });\r\n\r\n    if (terminateOnDestroy) ws.terminate();\r\n  };\r\n\r\n  duplex._final = function (callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._final(callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    // If the value of the `_socket` property is `null` it means that `ws` is a\r\n    // client websocket and the handshake failed. In fact, when this happens, a\r\n    // socket is never assigned to the websocket. Wait for the `'error'` event\r\n    // that will be emitted by the websocket.\r\n    if (ws._socket === null) return;\r\n\r\n    if (ws._socket._writableState.finished) {\r\n      callback();\r\n      if (duplex._readableState.endEmitted) duplex.destroy();\r\n    } else {\r\n      ws._socket.once('finish', function finish() {\r\n        // `duplex` is not destroyed here because the `'end'` event will be\r\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\r\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\r\n        callback();\r\n      });\r\n      ws.close();\r\n    }\r\n  };\r\n\r\n  duplex._read = function () {\r\n    if (ws.isPaused) ws.resume();\r\n  };\r\n\r\n  duplex._write = function (chunk, encoding, callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._write(chunk, encoding, callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    ws.send(chunk, callback);\r\n  };\r\n\r\n  duplex.on('end', duplexOnEnd);\r\n  duplex.on('error', duplexOnError);\r\n  return duplex;\r\n}\r\n\r\nmodule.exports = createWebSocketStream;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msb0NBQW9DO0FBQzdEO0FBQ2I7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBYTtBQUN2QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5XZWJTb2NrZXQkXCIgfV0gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcclxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RHVwbGV4fSBzdHJlYW0gVGhlIHN0cmVhbS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGVtaXRDbG9zZShzdHJlYW0pIHtcclxuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xyXG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xyXG4gICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcclxuICB0aGlzLmRlc3Ryb3koKTtcclxuICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XHJcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxyXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3cyBUaGUgYFdlYlNvY2tldGAgdG8gd3JhcFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcclxuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcclxuXHJcbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XHJcbiAgICAuLi5vcHRpb25zLFxyXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxyXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcclxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxyXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxyXG4gIH0pO1xyXG5cclxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xyXG4gICAgY29uc3QgZGF0YSA9XHJcbiAgICAgICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xyXG5cclxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XHJcbiAgfSk7XHJcblxyXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XHJcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxyXG4gICAgLy9cclxuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cclxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxyXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXHJcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxyXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXHJcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXHJcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxyXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XHJcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xyXG4gIH0pO1xyXG5cclxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xyXG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcclxuXHJcbiAgICBkdXBsZXgucHVzaChudWxsKTtcclxuICB9KTtcclxuXHJcbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcclxuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcclxuICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcblxyXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcclxuICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xyXG4gIH07XHJcblxyXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xyXG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxyXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXHJcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxyXG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cclxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XHJcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxyXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xyXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHdzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHdzLmlzUGF1c2VkKSB3cy5yZXN1bWUoKTtcclxuICB9O1xyXG5cclxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcclxuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xyXG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xyXG4gIH07XHJcblxyXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xyXG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcclxuICByZXR1cm4gZHVwbGV4O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Set} The subprotocol names\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const protocols = new Set();\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (i; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n\r\n    if (end === -1 && tokenChars[code] === 1) {\r\n      if (start === -1) start = i;\r\n    } else if (\r\n      i !== 0 &&\r\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n    ) {\r\n      if (end === -1 && start !== -1) end = i;\r\n    } else if (code === 0x2c /* ',' */) {\r\n      if (start === -1) {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n\r\n      if (end === -1) end = i;\r\n\r\n      const protocol = header.slice(start, end);\r\n\r\n      if (protocols.has(protocol)) {\r\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n      }\r\n\r\n      protocols.add(protocol);\r\n      start = end = -1;\r\n    } else {\r\n      throw new SyntaxError(`Unexpected character at index ${i}`);\r\n    }\r\n  }\r\n\r\n  if (start === -1 || end !== -1) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  const protocol = header.slice(start, i);\r\n\r\n  if (protocols.has(protocol)) {\r\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n  }\r\n\r\n  protocols.add(protocol);\r\n  return protocols;\r\n}\r\n\r\nmodule.exports = { parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc3VicHJvdG9jb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcclxuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XHJcbiAgbGV0IHN0YXJ0ID0gLTE7XHJcbiAgbGV0IGVuZCA9IC0xO1xyXG4gIGxldCBpID0gMDtcclxuXHJcbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XHJcblxyXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xyXG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICBpICE9PSAwICYmXHJcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xyXG4gICAgKSB7XHJcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcclxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcclxuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuXHJcbiAgICAgIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XHJcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xyXG5cclxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XHJcbiAgfVxyXG5cclxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcclxuICByZXR1cm4gcHJvdG9jb2xzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyc2UgfTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\r\n\r\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\n//\r\n// Allowed token characters:\r\n//\r\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\r\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\r\n//\r\n// tokenChars[32] === 0 // ' '\r\n// tokenChars[33] === 1 // '!'\r\n// tokenChars[34] === 0 // '\"'\r\n// ...\r\n//\r\n// prettier-ignore\r\nconst tokenChars = [\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\r\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\r\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\r\n];\r\n\r\n/**\r\n * Checks if a status code is allowed in a close frame.\r\n *\r\n * @param {Number} code The status code\r\n * @return {Boolean} `true` if the status code is valid, else `false`\r\n * @public\r\n */\r\nfunction isValidStatusCode(code) {\r\n  return (\r\n    (code >= 1000 &&\r\n      code <= 1014 &&\r\n      code !== 1004 &&\r\n      code !== 1005 &&\r\n      code !== 1006) ||\r\n    (code >= 3000 && code <= 4999)\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if a given buffer contains only correct UTF-8.\r\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\r\n * Markus Kuhn.\r\n *\r\n * @param {Buffer} buf The buffer to check\r\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\r\n * @public\r\n */\r\nfunction _isValidUTF8(buf) {\r\n  const len = buf.length;\r\n  let i = 0;\r\n\r\n  while (i < len) {\r\n    if ((buf[i] & 0x80) === 0) {\r\n      // 0xxxxxxx\r\n      i++;\r\n    } else if ((buf[i] & 0xe0) === 0xc0) {\r\n      // 110xxxxx 10xxxxxx\r\n      if (\r\n        i + 1 === len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i] & 0xfe) === 0xc0 // Overlong\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 2;\r\n    } else if ((buf[i] & 0xf0) === 0xe0) {\r\n      // 1110xxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 2 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\r\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 3;\r\n    } else if ((buf[i] & 0xf8) === 0xf0) {\r\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 3 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i + 3] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\r\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\r\n        buf[i] > 0xf4 // > U+10FFFF\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 4;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines whether a value is a `Blob`.\r\n *\r\n * @param {*} value The value to be tested\r\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\r\n * @private\r\n */\r\nfunction isBlob(value) {\r\n  return (\r\n    hasBlob &&\r\n    typeof value === 'object' &&\r\n    typeof value.arrayBuffer === 'function' &&\r\n    typeof value.type === 'string' &&\r\n    typeof value.stream === 'function' &&\r\n    (value[Symbol.toStringTag] === 'Blob' ||\r\n      value[Symbol.toStringTag] === 'File')\r\n  );\r\n}\r\n\r\nmodule.exports = {\r\n  isBlob,\r\n  isValidStatusCode,\r\n  isValidUTF8: _isValidUTF8,\r\n  tokenChars\r\n};\r\n\r\nif (isUtf8) {\r\n  module.exports.isValidUTF8 = function (buf) {\r\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\r\n  };\r\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\r\n  try {\r\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\r\n\r\n    module.exports.isValidUTF8 = function (buf) {\r\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMEJBQTBCO0FBQzVCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyw2QkFBZ0I7QUFDaEQ7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHZhbGlkYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xyXG5cclxuY29uc3QgeyBoYXNCbG9iIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuLy9cclxuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxyXG4vL1xyXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxyXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXHJcbi8vXHJcbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xyXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcclxuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xyXG4vLyAuLi5cclxuLy9cclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XHJcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxyXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcclxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXHJcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcclxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XHJcbl07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcclxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcclxuICByZXR1cm4gKFxyXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxyXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcclxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxyXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXHJcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XHJcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cclxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcclxuICogTWFya3VzIEt1aG4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xyXG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XHJcbiAgbGV0IGkgPSAwO1xyXG5cclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xyXG4gICAgICAvLyAweHh4eHh4eFxyXG4gICAgICBpKys7XHJcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xyXG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxyXG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcclxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpICs9IDI7XHJcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xyXG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcclxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXHJcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpICs9IDM7XHJcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xyXG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcclxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XHJcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xyXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XHJcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaSArPSA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGBCbG9iYC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYEJsb2JgLCBlbHNlIGBmYWxzZWBcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICBoYXNCbG9iICYmXHJcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXHJcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcclxuICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgdHlwZW9mIHZhbHVlLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxyXG4gICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZScpXHJcbiAgKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaXNCbG9iLFxyXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxyXG4gIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXHJcbiAgdG9rZW5DaGFyc1xyXG59O1xyXG5cclxuaWYgKGlzVXRmOCkge1xyXG4gIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xyXG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAyNCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNVdGY4KGJ1Zik7XHJcbiAgfTtcclxufSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi8gZWxzZSBpZiAoIXByb2Nlc3MuZW52LldTX05PX1VURl84X1ZBTElEQVRFKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcclxuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/./node_modules/ws/lib/subprotocol.js\");\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\r\n\r\nconst RUNNING = 0;\r\nconst CLOSING = 1;\r\nconst CLOSED = 2;\r\n\r\n/**\r\n * Class representing a WebSocket server.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n   *     automatically send a pong in response to a ping\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\r\n  constructor(options, callback) {\r\n    super();\r\n\r\n    options = {\r\n      allowSynchronousEvents: true,\r\n      autoPong: true,\r\n      maxPayload: 100 * 1024 * 1024,\r\n      skipUTF8Validation: false,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null, // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null,\r\n      WebSocket,\r\n      ...options\r\n    };\r\n\r\n    if (\r\n      (options.port == null && !options.server && !options.noServer) ||\r\n      (options.port != null && (options.server || options.noServer)) ||\r\n      (options.server && options.noServer)\r\n    ) {\r\n      throw new TypeError(\r\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\r\n          'must be specified'\r\n      );\r\n    }\r\n\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n\r\n        res.writeHead(426, {\r\n          'Content-Length': body.length,\r\n          'Content-Type': 'text/plain'\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(\r\n        options.port,\r\n        options.host,\r\n        options.backlog,\r\n        callback\r\n      );\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n\r\n    if (this._server) {\r\n      const emitConnection = this.emit.bind(this, 'connection');\r\n\r\n      this._removeListeners = addListeners(this._server, {\r\n        listening: this.emit.bind(this, 'listening'),\r\n        error: this.emit.bind(this, 'error'),\r\n        upgrade: (req, socket, head) => {\r\n          this.handleUpgrade(req, socket, head, emitConnection);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\r\n    if (options.clientTracking) {\r\n      this.clients = new Set();\r\n      this._shouldEmitClose = false;\r\n    }\r\n\r\n    this.options = options;\r\n    this._state = RUNNING;\r\n  }\r\n\r\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\r\n  address() {\r\n    if (this.options.noServer) {\r\n      throw new Error('The server is operating in \"noServer\" mode');\r\n    }\r\n\r\n    if (!this._server) return null;\r\n    return this._server.address();\r\n  }\r\n\r\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\r\n  close(cb) {\r\n    if (this._state === CLOSED) {\r\n      if (cb) {\r\n        this.once('close', () => {\r\n          cb(new Error('The server is not running'));\r\n        });\r\n      }\r\n\r\n      process.nextTick(emitClose, this);\r\n      return;\r\n    }\r\n\r\n    if (cb) this.once('close', cb);\r\n\r\n    if (this._state === CLOSING) return;\r\n    this._state = CLOSING;\r\n\r\n    if (this.options.noServer || this.options.server) {\r\n      if (this._server) {\r\n        this._removeListeners();\r\n        this._removeListeners = this._server = null;\r\n      }\r\n\r\n      if (this.clients) {\r\n        if (!this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        } else {\r\n          this._shouldEmitClose = true;\r\n        }\r\n      } else {\r\n        process.nextTick(emitClose, this);\r\n      }\r\n    } else {\r\n      const server = this._server;\r\n\r\n      this._removeListeners();\r\n      this._removeListeners = this._server = null;\r\n\r\n      //\r\n      // The HTTP/S server was created internally. Close it, and rely on its\r\n      // `'close'` event.\r\n      //\r\n      server.close(() => {\r\n        emitClose(this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle(req) {\r\n    if (this.options.path) {\r\n      const index = req.url.indexOf('?');\r\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\r\n\r\n      if (pathname !== this.options.path) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade(req, socket, head, cb) {\r\n    socket.on('error', socketOnError);\r\n\r\n    const key = req.headers['sec-websocket-key'];\r\n    const upgrade = req.headers.upgrade;\r\n    const version = +req.headers['sec-websocket-version'];\r\n\r\n    if (req.method !== 'GET') {\r\n      const message = 'Invalid HTTP method';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\r\n      return;\r\n    }\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      const message = 'Invalid Upgrade header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (key === undefined || !keyRegex.test(key)) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (version !== 8 && version !== 13) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (!this.shouldHandle(req)) {\r\n      abortHandshake(socket, 400);\r\n      return;\r\n    }\r\n\r\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\r\n    let protocols = new Set();\r\n\r\n    if (secWebSocketProtocol !== undefined) {\r\n      try {\r\n        protocols = subprotocol.parse(secWebSocketProtocol);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Protocol header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\r\n    const extensions = {};\r\n\r\n    if (\r\n      this.options.perMessageDeflate &&\r\n      secWebSocketExtensions !== undefined\r\n    ) {\r\n      const perMessageDeflate = new PerMessageDeflate(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n\r\n      try {\r\n        const offers = extension.parse(secWebSocketExtensions);\r\n\r\n        if (offers[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\r\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        const message =\r\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Optionally call external client verification handler.\r\n    //\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin:\r\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\r\n        secure: !!(req.socket.authorized || req.socket.encrypted),\r\n        req\r\n      };\r\n\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message, headers) => {\r\n          if (!verified) {\r\n            return abortHandshake(socket, code || 401, message, headers);\r\n          }\r\n\r\n          this.completeUpgrade(\r\n            extensions,\r\n            key,\r\n            protocols,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\r\n    }\r\n\r\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\r\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\r\n    //\r\n    // Destroy the socket if the client has already sent a FIN packet.\r\n    //\r\n    if (!socket.readable || !socket.writable) return socket.destroy();\r\n\r\n    if (socket[kWebSocket]) {\r\n      throw new Error(\r\n        'server.handleUpgrade() was called more than once with the same ' +\r\n          'socket, possibly due to a misconfiguration'\r\n      );\r\n    }\r\n\r\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    const headers = [\r\n      'HTTP/1.1 101 Switching Protocols',\r\n      'Upgrade: websocket',\r\n      'Connection: Upgrade',\r\n      `Sec-WebSocket-Accept: ${digest}`\r\n    ];\r\n\r\n    const ws = new this.options.WebSocket(null, undefined, this.options);\r\n\r\n    if (protocols.size) {\r\n      //\r\n      // Optionally call external protocol selection handler.\r\n      //\r\n      const protocol = this.options.handleProtocols\r\n        ? this.options.handleProtocols(protocols, req)\r\n        : protocols.values().next().value;\r\n\r\n      if (protocol) {\r\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n        ws._protocol = protocol;\r\n      }\r\n    }\r\n\r\n    if (extensions[PerMessageDeflate.extensionName]) {\r\n      const params = extensions[PerMessageDeflate.extensionName].params;\r\n      const value = extension.format({\r\n        [PerMessageDeflate.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n      ws._extensions = extensions;\r\n    }\r\n\r\n    //\r\n    // Allow external modification/inspection of handshake headers.\r\n    //\r\n    this.emit('headers', headers, req);\r\n\r\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\r\n    socket.removeListener('error', socketOnError);\r\n\r\n    ws.setSocket(socket, head, {\r\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\r\n      maxPayload: this.options.maxPayload,\r\n      skipUTF8Validation: this.options.skipUTF8Validation\r\n    });\r\n\r\n    if (this.clients) {\r\n      this.clients.add(ws);\r\n      ws.on('close', () => {\r\n        this.clients.delete(ws);\r\n\r\n        if (this._shouldEmitClose && !this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        }\r\n      });\r\n    }\r\n\r\n    cb(ws, req);\r\n  }\r\n}\r\n\r\nmodule.exports = WebSocketServer;\r\n\r\n/**\r\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\r\n * pairs.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @param {Object.<String, Function>} map The listeners to add\r\n * @return {Function} A function that will remove the added listeners when\r\n *     called\r\n * @private\r\n */\r\nfunction addListeners(server, map) {\r\n  for (const event of Object.keys(map)) server.on(event, map[event]);\r\n\r\n  return function removeListeners() {\r\n    for (const event of Object.keys(map)) {\r\n      server.removeListener(event, map[event]);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Emit a `'close'` event on an `EventEmitter`.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @private\r\n */\r\nfunction emitClose(server) {\r\n  server._state = CLOSED;\r\n  server.emit('close');\r\n}\r\n\r\n/**\r\n * Handle socket errors.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  this.destroy();\r\n}\r\n\r\n/**\r\n * Close the connection when preconditions are not fulfilled.\r\n *\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} [message] The HTTP response body\r\n * @param {Object} [headers] Additional HTTP response headers\r\n * @private\r\n */\r\nfunction abortHandshake(socket, code, message, headers) {\r\n  //\r\n  // The socket is writable unless the user destroyed or ended it before calling\r\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\r\n  // error. Handling this does not make much sense as the worst that can happen\r\n  // is that some of the data written by the user might be discarded due to the\r\n  // call to `socket.end()` below, which triggers an `'error'` event that in\r\n  // turn causes the socket to be destroyed.\r\n  //\r\n  message = message || http.STATUS_CODES[code];\r\n  headers = {\r\n    Connection: 'close',\r\n    'Content-Type': 'text/html',\r\n    'Content-Length': Buffer.byteLength(message),\r\n    ...headers\r\n  };\r\n\r\n  socket.once('finish', socket.destroy);\r\n\r\n  socket.end(\r\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\r\n      Object.keys(headers)\r\n        .map((h) => `${h}: ${headers[h]}`)\r\n        .join('\\r\\n') +\r\n      '\\r\\n\\r\\n' +\r\n      message\r\n  );\r\n}\r\n\r\n/**\r\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\r\n * one listener for it, otherwise call `abortHandshake()`.\r\n *\r\n * @param {WebSocketServer} server The WebSocket server\r\n * @param {http.IncomingMessage} req The request object\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} message The HTTP response body\r\n * @private\r\n */\r\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\r\n  if (server.listenerCount('wsClientError')) {\r\n    const err = new Error(message);\r\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\r\n\r\n    server.emit('wsClientError', err, socket, req);\r\n  } else {\r\n    abortHandshake(socket, code, message);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDtBQUMvRjtBQUNhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkRBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLGlFQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUNsRDtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNu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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcd2Vic29ja2V0LXNlcnZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXgkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcclxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcclxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcclxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcclxuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcclxuXHJcbmNvbnN0IFJVTk5JTkcgPSAwO1xyXG5jb25zdCBDTE9TSU5HID0gMTtcclxuY29uc3QgQ0xPU0VEID0gMjtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICovXHJcbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcclxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXHJcbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXHJcbiAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xyXG4gICAqICAgICB0cmFjayBjbGllbnRzXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXSBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcclxuICAgKiAgICAgc2l6ZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcclxuICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPWZhbHNlXSBFbmFibGUvZGlzYWJsZVxyXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXHJcbiAgICogQHBhcmFtIHsoaHR0cC5TZXJ2ZXJ8aHR0cHMuU2VydmVyKX0gW29wdGlvbnMuc2VydmVyXSBBIHByZS1jcmVhdGVkIEhUVFAvU1xyXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxyXG4gICAqICAgICBjbGFzcyB0byB1c2UuIEl0IG11c3QgYmUgdGhlIGBXZWJTb2NrZXRgIGNsYXNzIG9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcclxuICAgICAgYXV0b1Bvbmc6IHRydWUsXHJcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxyXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxyXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXHJcbiAgICAgIGhhbmRsZVByb3RvY29sczogbnVsbCxcclxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXHJcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcclxuICAgICAgbm9TZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcclxuICAgICAgc2VydmVyOiBudWxsLFxyXG4gICAgICBob3N0OiBudWxsLFxyXG4gICAgICBwYXRoOiBudWxsLFxyXG4gICAgICBwb3J0OiBudWxsLFxyXG4gICAgICBXZWJTb2NrZXQsXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH07XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxyXG4gICAgICAob3B0aW9ucy5wb3J0ICE9IG51bGwgJiYgKG9wdGlvbnMuc2VydmVyIHx8IG9wdGlvbnMubm9TZXJ2ZXIpKSB8fFxyXG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXHJcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xyXG5cclxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVzLmVuZChib2R5KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXHJcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxyXG4gICAgICAgIG9wdGlvbnMuaG9zdCxcclxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXHJcbiAgICAgICAgY2FsbGJhY2tcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcclxuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xyXG4gICAgICBjb25zdCBlbWl0Q29ubmVjdGlvbiA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdjb25uZWN0aW9uJyk7XHJcblxyXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XHJcbiAgICAgICAgbGlzdGVuaW5nOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbGlzdGVuaW5nJyksXHJcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxyXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHtcclxuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xyXG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBSVU5OSU5HO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxyXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBhZGRyZXNzKCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcclxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNsb3NlKGNiKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xyXG4gICAgICBpZiAoY2IpIHtcclxuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XHJcblxyXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TSU5HKSByZXR1cm47XHJcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlciB8fCB0aGlzLm9wdGlvbnMuc2VydmVyKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5jbGllbnRzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xyXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcclxuXHJcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xyXG5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xyXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXHJcbiAgICAgIC8vXHJcbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XHJcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xyXG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcclxuXHJcbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcclxuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcclxuXHJcbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcclxuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XHJcblxyXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBIVFRQIG1ldGhvZCc7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gJ01pc3Npbmcgb3IgaW52YWxpZCBTZWMtV2ViU29ja2V0LUtleSBoZWFkZXInO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gJ01pc3Npbmcgb3IgaW52YWxpZCBTZWMtV2ViU29ja2V0LVZlcnNpb24gaGVhZGVyJztcclxuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcclxuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XHJcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgJiZcclxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xyXG5cclxuICAgICAgICBpZiAob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcclxuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxyXG4gICAgICAgICAgJ0ludmFsaWQgb3IgdW5hY2NlcHRhYmxlIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cclxuICAgIC8vXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xyXG4gICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgIG9yaWdpbjpcclxuICAgICAgICAgIHJlcS5oZWFkZXJzW2Ake3ZlcnNpb24gPT09IDggPyAnc2VjLXdlYnNvY2tldC1vcmlnaW4nIDogJ29yaWdpbid9YF0sXHJcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxyXG4gICAgICAgIHJlcVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcclxuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxyXG4gICAgICAgICAgICBleHRlbnNpb25zLFxyXG4gICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgIHByb3RvY29scyxcclxuICAgICAgICAgICAgcmVxLFxyXG4gICAgICAgICAgICBzb2NrZXQsXHJcbiAgICAgICAgICAgIGhlYWQsXHJcbiAgICAgICAgICAgIGNiXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgYWNjZXB0ZWQgZXh0ZW5zaW9uc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xyXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcclxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcclxuICAgIC8vXHJcbiAgICAvLyBEZXN0cm95IHRoZSBzb2NrZXQgaWYgdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBzZW50IGEgRklOIHBhY2tldC5cclxuICAgIC8vXHJcbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcclxuXHJcbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnc2VydmVyLmhhbmRsZVVwZ3JhZGUoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgJyArXHJcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XHJcblxyXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXHJcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcclxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XHJcblxyXG4gICAgY29uc3QgaGVhZGVycyA9IFtcclxuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcclxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXHJcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcclxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IHdzID0gbmV3IHRoaXMub3B0aW9ucy5XZWJTb2NrZXQobnVsbCwgdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXHJcbiAgICAgIC8vXHJcbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29sc1xyXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcclxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XHJcblxyXG4gICAgICBpZiAocHJvdG9jb2wpIHtcclxuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XHJcbiAgICAgICAgd3MuX3Byb3RvY29sID0gcHJvdG9jb2w7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xyXG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcclxuICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcclxuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXHJcbiAgICAgIH0pO1xyXG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcclxuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cclxuICAgIC8vXHJcbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xyXG5cclxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xyXG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG5cclxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcclxuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXHJcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxyXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IHRoaXMub3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcclxuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XHJcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICB0aGlzLmNsaWVudHMuZGVsZXRlKHdzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcclxuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNiKHdzLCByZXEpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTZXJ2ZXI7XHJcblxyXG4vKipcclxuICogQWRkIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBgRXZlbnRFbWl0dGVyYCB1c2luZyBhIG1hcCBvZiA8ZXZlbnQsIGxpc3RlbmVyPlxyXG4gKiBwYWlycy5cclxuICpcclxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxyXG4gKiAgICAgY2FsbGVkXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcclxuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XHJcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcclxuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cclxuICpcclxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xyXG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XHJcbiAgc2VydmVyLmVtaXQoJ2Nsb3NlJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XHJcbiAgdGhpcy5kZXN0cm95KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2hlYWRlcnNdIEFkZGl0aW9uYWwgSFRUUCByZXNwb25zZSBoZWFkZXJzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcclxuICAvL1xyXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xyXG4gIC8vIGBzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpYCBvciBpbiB0aGUgYHZlcmlmeUNsaWVudGAgZnVuY3Rpb24sIHdoaWNoIGlzIGEgdXNlclxyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXHJcbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcclxuICAvLyBjYWxsIHRvIGBzb2NrZXQuZW5kKClgIGJlbG93LCB3aGljaCB0cmlnZ2VycyBhbiBgJ2Vycm9yJ2AgZXZlbnQgdGhhdCBpblxyXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxyXG4gIC8vXHJcbiAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XHJcbiAgaGVhZGVycyA9IHtcclxuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXHJcbiAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvaHRtbCcsXHJcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcclxuICAgIC4uLmhlYWRlcnNcclxuICB9O1xyXG5cclxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xyXG5cclxuICBzb2NrZXQuZW5kKFxyXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcclxuICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcclxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXHJcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcclxuICAgICAgJ1xcclxcblxcclxcbicgK1xyXG4gICAgICBtZXNzYWdlXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVtaXQgYSBgJ3dzQ2xpZW50RXJyb3InYCBldmVudCBvbiBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGlmIHRoZXJlIGlzIGF0IGxlYXN0XHJcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXRTZXJ2ZXJ9IHNlcnZlciBUaGUgV2ViU29ja2V0IHNlcnZlclxyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XHJcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcclxuXHJcbiAgICBzZXJ2ZXIuZW1pdCgnd3NDbGllbnRFcnJvcicsIGVyciwgc29ja2V0LCByZXEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst tls = __webpack_require__(/*! tls */ \"tls\");\r\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { URL } = __webpack_require__(/*! url */ \"url\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\r\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/ws/lib/sender.js\");\r\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  GUID,\r\n  kForOnEventAttribute,\r\n  kListener,\r\n  kStatusCode,\r\n  kWebSocket,\r\n  NOOP\r\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\nconst {\r\n  EventTarget: { addEventListener, removeEventListener }\r\n} = __webpack_require__(/*! ./event-target */ \"(ssr)/./node_modules/ws/lib/event-target.js\");\r\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\r\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\n\r\nconst closeTimeout = 30 * 1000;\r\nconst kAborted = Symbol('kAborted');\r\nconst protocolVersions = [8, 13];\r\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\r\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\r\n\r\n/**\r\n * Class representing a WebSocket.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocket extends EventEmitter {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\r\n  constructor(address, protocols, options) {\r\n    super();\r\n\r\n    this._binaryType = BINARY_TYPES[0];\r\n    this._closeCode = 1006;\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = EMPTY_BUFFER;\r\n    this._closeTimer = null;\r\n    this._errorEmitted = false;\r\n    this._extensions = {};\r\n    this._paused = false;\r\n    this._protocol = '';\r\n    this._readyState = WebSocket.CONNECTING;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n\r\n    if (address !== null) {\r\n      this._bufferedAmount = 0;\r\n      this._isServer = false;\r\n      this._redirects = 0;\r\n\r\n      if (protocols === undefined) {\r\n        protocols = [];\r\n      } else if (!Array.isArray(protocols)) {\r\n        if (typeof protocols === 'object' && protocols !== null) {\r\n          options = protocols;\r\n          protocols = [];\r\n        } else {\r\n          protocols = [protocols];\r\n        }\r\n      }\r\n\r\n      initAsClient(this, address, protocols, options);\r\n    } else {\r\n      this._autoPong = options.autoPong;\r\n      this._isServer = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\r\n   * instead of \"blob\".\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType() {\r\n    return this._binaryType;\r\n  }\r\n\r\n  set binaryType(type) {\r\n    if (!BINARY_TYPES.includes(type)) return;\r\n\r\n    this._binaryType = type;\r\n\r\n    //\r\n    // Allow to change `binaryType` on the fly.\r\n    //\r\n    if (this._receiver) this._receiver._binaryType = type;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount() {\r\n    if (!this._socket) return this._bufferedAmount;\r\n\r\n    return this._socket._writableState.length + this._sender._bufferedBytes;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get extensions() {\r\n    return Object.keys(this._extensions).join();\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onclose() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onerror() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onopen() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onmessage() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get protocol() {\r\n    return this._protocol;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get readyState() {\r\n    return this._readyState;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\r\n  setSocket(socket, head, options) {\r\n    const receiver = new Receiver({\r\n      allowSynchronousEvents: options.allowSynchronousEvents,\r\n      binaryType: this.binaryType,\r\n      extensions: this._extensions,\r\n      isServer: this._isServer,\r\n      maxPayload: options.maxPayload,\r\n      skipUTF8Validation: options.skipUTF8Validation\r\n    });\r\n\r\n    const sender = new Sender(socket, this._extensions, options.generateMask);\r\n\r\n    this._receiver = receiver;\r\n    this._sender = sender;\r\n    this._socket = socket;\r\n\r\n    receiver[kWebSocket] = this;\r\n    sender[kWebSocket] = this;\r\n    socket[kWebSocket] = this;\r\n\r\n    receiver.on('conclude', receiverOnConclude);\r\n    receiver.on('drain', receiverOnDrain);\r\n    receiver.on('error', receiverOnError);\r\n    receiver.on('message', receiverOnMessage);\r\n    receiver.on('ping', receiverOnPing);\r\n    receiver.on('pong', receiverOnPong);\r\n\r\n    sender.onerror = senderOnError;\r\n\r\n    //\r\n    // These methods may not be available if `socket` is just a `Duplex`.\r\n    //\r\n    if (socket.setTimeout) socket.setTimeout(0);\r\n    if (socket.setNoDelay) socket.setNoDelay();\r\n\r\n    if (head.length > 0) socket.unshift(head);\r\n\r\n    socket.on('close', socketOnClose);\r\n    socket.on('data', socketOnData);\r\n    socket.on('end', socketOnEnd);\r\n    socket.on('error', socketOnError);\r\n\r\n    this._readyState = WebSocket.OPEN;\r\n    this.emit('open');\r\n  }\r\n\r\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose() {\r\n    if (!this._socket) {\r\n      this._readyState = WebSocket.CLOSED;\r\n      this.emit('close', this._closeCode, this._closeMessage);\r\n      return;\r\n    }\r\n\r\n    if (this._extensions[PerMessageDeflate.extensionName]) {\r\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\r\n    }\r\n\r\n    this._receiver.removeAllListeners();\r\n    this._readyState = WebSocket.CLOSED;\r\n    this.emit('close', this._closeCode, this._closeMessage);\r\n  }\r\n\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\r\n  close(code, data) {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (\r\n        this._closeFrameSent &&\r\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this._readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      //\r\n      // This error is handled by the `'error'` listener on the socket. We only\r\n      // want to know if the close frame has been sent here.\r\n      //\r\n      if (err) return;\r\n\r\n      this._closeFrameSent = true;\r\n\r\n      if (\r\n        this._closeFrameReceived ||\r\n        this._receiver._writableState.errorEmitted\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n    });\r\n\r\n    setCloseTimer(this);\r\n  }\r\n\r\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\r\n  pause() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = true;\r\n    this._socket.pause();\r\n  }\r\n\r\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\r\n  ping(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\r\n  pong(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\r\n  resume() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = false;\r\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\r\n  }\r\n\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof options === 'function') {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    const opts = {\r\n      binary: typeof data !== 'string',\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true,\r\n      ...options\r\n    };\r\n\r\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n\r\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\r\n  }\r\n\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate() {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this._socket) {\r\n      this._readyState = WebSocket.CLOSING;\r\n      this._socket.destroy();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n[\r\n  'binaryType',\r\n  'bufferedAmount',\r\n  'extensions',\r\n  'isPaused',\r\n  'protocol',\r\n  'readyState',\r\n  'url'\r\n].forEach((property) => {\r\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\r\n});\r\n\r\n//\r\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\r\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\r\n//\r\n['open', 'error', 'close', 'message'].forEach((method) => {\r\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\r\n    enumerable: true,\r\n    get() {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) return listener[kListener];\r\n      }\r\n\r\n      return null;\r\n    },\r\n    set(handler) {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) {\r\n          this.removeListener(method, listener);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (typeof handler !== 'function') return;\r\n\r\n      this.addEventListener(method, handler, {\r\n        [kForOnEventAttribute]: true\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nWebSocket.prototype.addEventListener = addEventListener;\r\nWebSocket.prototype.removeEventListener = removeEventListener;\r\n\r\nmodule.exports = WebSocket;\r\n\r\n/**\r\n * Initialize a WebSocket client.\r\n *\r\n * @param {WebSocket} websocket The client to initialize\r\n * @param {(String|URL)} address The URL to which to connect\r\n * @param {Array} protocols The subprotocols\r\n * @param {Object} [options] Connection options\r\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\r\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\r\n *     times in the same tick\r\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n *     automatically send a pong in response to a ping\r\n * @param {Function} [options.finishRequest] A function which can be used to\r\n *     customize the headers of each http request before it is sent\r\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\r\n *     redirects\r\n * @param {Function} [options.generateMask] The function used to generate the\r\n *     masking key\r\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\r\n *     handshake request\r\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n *     size\r\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\r\n *     allowed\r\n * @param {String} [options.origin] Value of the `Origin` or\r\n *     `Sec-WebSocket-Origin` header\r\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\r\n *     permessage-deflate\r\n * @param {Number} [options.protocolVersion=13] Value of the\r\n *     `Sec-WebSocket-Version` header\r\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n *     not to skip UTF-8 validation for text and close messages\r\n * @private\r\n */\r\nfunction initAsClient(websocket, address, protocols, options) {\r\n  const opts = {\r\n    allowSynchronousEvents: true,\r\n    autoPong: true,\r\n    protocolVersion: protocolVersions[1],\r\n    maxPayload: 100 * 1024 * 1024,\r\n    skipUTF8Validation: false,\r\n    perMessageDeflate: true,\r\n    followRedirects: false,\r\n    maxRedirects: 10,\r\n    ...options,\r\n    socketPath: undefined,\r\n    hostname: undefined,\r\n    protocol: undefined,\r\n    timeout: undefined,\r\n    method: 'GET',\r\n    host: undefined,\r\n    path: undefined,\r\n    port: undefined\r\n  };\r\n\r\n  websocket._autoPong = opts.autoPong;\r\n\r\n  if (!protocolVersions.includes(opts.protocolVersion)) {\r\n    throw new RangeError(\r\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\r\n        `(supported versions: ${protocolVersions.join(', ')})`\r\n    );\r\n  }\r\n\r\n  let parsedUrl;\r\n\r\n  if (address instanceof URL) {\r\n    parsedUrl = address;\r\n  } else {\r\n    try {\r\n      parsedUrl = new URL(address);\r\n    } catch (e) {\r\n      throw new SyntaxError(`Invalid URL: ${address}`);\r\n    }\r\n  }\r\n\r\n  if (parsedUrl.protocol === 'http:') {\r\n    parsedUrl.protocol = 'ws:';\r\n  } else if (parsedUrl.protocol === 'https:') {\r\n    parsedUrl.protocol = 'wss:';\r\n  }\r\n\r\n  websocket._url = parsedUrl.href;\r\n\r\n  const isSecure = parsedUrl.protocol === 'wss:';\r\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\r\n  let invalidUrlMessage;\r\n\r\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\r\n    invalidUrlMessage =\r\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\r\n      '\"http:\", \"https:\", or \"ws+unix:\"';\r\n  } else if (isIpcUrl && !parsedUrl.pathname) {\r\n    invalidUrlMessage = \"The URL's pathname is empty\";\r\n  } else if (parsedUrl.hash) {\r\n    invalidUrlMessage = 'The URL contains a fragment identifier';\r\n  }\r\n\r\n  if (invalidUrlMessage) {\r\n    const err = new SyntaxError(invalidUrlMessage);\r\n\r\n    if (websocket._redirects === 0) {\r\n      throw err;\r\n    } else {\r\n      emitErrorAndClose(websocket, err);\r\n      return;\r\n    }\r\n  }\r\n\r\n  const defaultPort = isSecure ? 443 : 80;\r\n  const key = randomBytes(16).toString('base64');\r\n  const request = isSecure ? https.request : http.request;\r\n  const protocolSet = new Set();\r\n  let perMessageDeflate;\r\n\r\n  opts.createConnection =\r\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\r\n  opts.defaultPort = opts.defaultPort || defaultPort;\r\n  opts.port = parsedUrl.port || defaultPort;\r\n  opts.host = parsedUrl.hostname.startsWith('[')\r\n    ? parsedUrl.hostname.slice(1, -1)\r\n    : parsedUrl.hostname;\r\n  opts.headers = {\r\n    ...opts.headers,\r\n    'Sec-WebSocket-Version': opts.protocolVersion,\r\n    'Sec-WebSocket-Key': key,\r\n    Connection: 'Upgrade',\r\n    Upgrade: 'websocket'\r\n  };\r\n  opts.path = parsedUrl.pathname + parsedUrl.search;\r\n  opts.timeout = opts.handshakeTimeout;\r\n\r\n  if (opts.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate(\r\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\r\n      false,\r\n      opts.maxPayload\r\n    );\r\n    opts.headers['Sec-WebSocket-Extensions'] = format({\r\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (protocols.length) {\r\n    for (const protocol of protocols) {\r\n      if (\r\n        typeof protocol !== 'string' ||\r\n        !subprotocolRegex.test(protocol) ||\r\n        protocolSet.has(protocol)\r\n      ) {\r\n        throw new SyntaxError(\r\n          'An invalid or duplicated subprotocol was specified'\r\n        );\r\n      }\r\n\r\n      protocolSet.add(protocol);\r\n    }\r\n\r\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\r\n  }\r\n  if (opts.origin) {\r\n    if (opts.protocolVersion < 13) {\r\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\r\n    } else {\r\n      opts.headers.Origin = opts.origin;\r\n    }\r\n  }\r\n  if (parsedUrl.username || parsedUrl.password) {\r\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\r\n  }\r\n\r\n  if (isIpcUrl) {\r\n    const parts = opts.path.split(':');\r\n\r\n    opts.socketPath = parts[0];\r\n    opts.path = parts[1];\r\n  }\r\n\r\n  let req;\r\n\r\n  if (opts.followRedirects) {\r\n    if (websocket._redirects === 0) {\r\n      websocket._originalIpc = isIpcUrl;\r\n      websocket._originalSecure = isSecure;\r\n      websocket._originalHostOrSocketPath = isIpcUrl\r\n        ? opts.socketPath\r\n        : parsedUrl.host;\r\n\r\n      const headers = options && options.headers;\r\n\r\n      //\r\n      // Shallow copy the user provided options so that headers can be changed\r\n      // without mutating the original object.\r\n      //\r\n      options = { ...options, headers: {} };\r\n\r\n      if (headers) {\r\n        for (const [key, value] of Object.entries(headers)) {\r\n          options.headers[key.toLowerCase()] = value;\r\n        }\r\n      }\r\n    } else if (websocket.listenerCount('redirect') === 0) {\r\n      const isSameHost = isIpcUrl\r\n        ? websocket._originalIpc\r\n          ? opts.socketPath === websocket._originalHostOrSocketPath\r\n          : false\r\n        : websocket._originalIpc\r\n          ? false\r\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\r\n\r\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\r\n        //\r\n        // Match curl 7.77.0 behavior and drop the following headers. These\r\n        // headers are also dropped when following a redirect to a subdomain.\r\n        //\r\n        delete opts.headers.authorization;\r\n        delete opts.headers.cookie;\r\n\r\n        if (!isSameHost) delete opts.headers.host;\r\n\r\n        opts.auth = undefined;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\r\n    // If the `Authorization` header is set, then there is nothing to do as it\r\n    // will take precedence.\r\n    //\r\n    if (opts.auth && !options.headers.authorization) {\r\n      options.headers.authorization =\r\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\r\n    }\r\n\r\n    req = websocket._req = request(opts);\r\n\r\n    if (websocket._redirects) {\r\n      //\r\n      // Unlike what is done for the `'upgrade'` event, no early exit is\r\n      // triggered here if the user calls `websocket.close()` or\r\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\r\n      // is because the user can also call `request.destroy()` with an error\r\n      // before calling `websocket.close()` or `websocket.terminate()` and this\r\n      // would result in an error being emitted on the `request` object with no\r\n      // `'error'` event listeners attached.\r\n      //\r\n      websocket.emit('redirect', websocket.url, req);\r\n    }\r\n  } else {\r\n    req = websocket._req = request(opts);\r\n  }\r\n\r\n  if (opts.timeout) {\r\n    req.on('timeout', () => {\r\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\r\n    });\r\n  }\r\n\r\n  req.on('error', (err) => {\r\n    if (req === null || req[kAborted]) return;\r\n\r\n    req = websocket._req = null;\r\n    emitErrorAndClose(websocket, err);\r\n  });\r\n\r\n  req.on('response', (res) => {\r\n    const location = res.headers.location;\r\n    const statusCode = res.statusCode;\r\n\r\n    if (\r\n      location &&\r\n      opts.followRedirects &&\r\n      statusCode >= 300 &&\r\n      statusCode < 400\r\n    ) {\r\n      if (++websocket._redirects > opts.maxRedirects) {\r\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\r\n        return;\r\n      }\r\n\r\n      req.abort();\r\n\r\n      let addr;\r\n\r\n      try {\r\n        addr = new URL(location, address);\r\n      } catch (e) {\r\n        const err = new SyntaxError(`Invalid URL: ${location}`);\r\n        emitErrorAndClose(websocket, err);\r\n        return;\r\n      }\r\n\r\n      initAsClient(websocket, addr, protocols, options);\r\n    } else if (!websocket.emit('unexpected-response', req, res)) {\r\n      abortHandshake(\r\n        websocket,\r\n        req,\r\n        `Unexpected server response: ${res.statusCode}`\r\n      );\r\n    }\r\n  });\r\n\r\n  req.on('upgrade', (res, socket, head) => {\r\n    websocket.emit('upgrade', res);\r\n\r\n    //\r\n    // The user may have closed the connection from a listener of the\r\n    // `'upgrade'` event.\r\n    //\r\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\r\n\r\n    req = websocket._req = null;\r\n\r\n    const upgrade = res.headers.upgrade;\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\r\n      return;\r\n    }\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    if (res.headers['sec-websocket-accept'] !== digest) {\r\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\r\n      return;\r\n    }\r\n\r\n    const serverProt = res.headers['sec-websocket-protocol'];\r\n    let protError;\r\n\r\n    if (serverProt !== undefined) {\r\n      if (!protocolSet.size) {\r\n        protError = 'Server sent a subprotocol but none was requested';\r\n      } else if (!protocolSet.has(serverProt)) {\r\n        protError = 'Server sent an invalid subprotocol';\r\n      }\r\n    } else if (protocolSet.size) {\r\n      protError = 'Server sent no subprotocol';\r\n    }\r\n\r\n    if (protError) {\r\n      abortHandshake(websocket, socket, protError);\r\n      return;\r\n    }\r\n\r\n    if (serverProt) websocket._protocol = serverProt;\r\n\r\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\r\n\r\n    if (secWebSocketExtensions !== undefined) {\r\n      if (!perMessageDeflate) {\r\n        const message =\r\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\r\n          'was requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      let extensions;\r\n\r\n      try {\r\n        extensions = parse(secWebSocketExtensions);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      const extensionNames = Object.keys(extensions);\r\n\r\n      if (\r\n        extensionNames.length !== 1 ||\r\n        extensionNames[0] !== PerMessageDeflate.extensionName\r\n      ) {\r\n        const message = 'Server indicated an extension that was not requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      websocket._extensions[PerMessageDeflate.extensionName] =\r\n        perMessageDeflate;\r\n    }\r\n\r\n    websocket.setSocket(socket, head, {\r\n      allowSynchronousEvents: opts.allowSynchronousEvents,\r\n      generateMask: opts.generateMask,\r\n      maxPayload: opts.maxPayload,\r\n      skipUTF8Validation: opts.skipUTF8Validation\r\n    });\r\n  });\r\n\r\n  if (opts.finishRequest) {\r\n    opts.finishRequest(req, websocket);\r\n  } else {\r\n    req.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Emit the `'error'` and `'close'` events.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {Error} The error to emit\r\n * @private\r\n */\r\nfunction emitErrorAndClose(websocket, err) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  //\r\n  // The following assignment is practically useless and is done only for\r\n  // consistency.\r\n  //\r\n  websocket._errorEmitted = true;\r\n  websocket.emit('error', err);\r\n  websocket.emitClose();\r\n}\r\n\r\n/**\r\n * Create a `net.Socket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {net.Socket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction netConnect(options) {\r\n  options.path = options.socketPath;\r\n  return net.connect(options);\r\n}\r\n\r\n/**\r\n * Create a `tls.TLSSocket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {tls.TLSSocket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction tlsConnect(options) {\r\n  options.path = undefined;\r\n\r\n  if (!options.servername && options.servername !== '') {\r\n    options.servername = net.isIP(options.host) ? '' : options.host;\r\n  }\r\n\r\n  return tls.connect(options);\r\n}\r\n\r\n/**\r\n * Abort the handshake and emit an error.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\r\n *     abort or the socket to destroy\r\n * @param {String} message The error message\r\n * @private\r\n */\r\nfunction abortHandshake(websocket, stream, message) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  const err = new Error(message);\r\n  Error.captureStackTrace(err, abortHandshake);\r\n\r\n  if (stream.setHeader) {\r\n    stream[kAborted] = true;\r\n    stream.abort();\r\n\r\n    if (stream.socket && !stream.socket.destroyed) {\r\n      //\r\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\r\n      // called after the request completed. See\r\n      // https://github.com/websockets/ws/issues/1869.\r\n      //\r\n      stream.socket.destroy();\r\n    }\r\n\r\n    process.nextTick(emitErrorAndClose, websocket, err);\r\n  } else {\r\n    stream.destroy(err);\r\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\r\n    stream.once('close', websocket.emitClose.bind(websocket));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\r\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {*} [data] The data to send\r\n * @param {Function} [cb] Callback\r\n * @private\r\n */\r\nfunction sendAfterClose(websocket, data, cb) {\r\n  if (data) {\r\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\r\n\r\n    //\r\n    // The `_bufferedAmount` property is used only when the peer is a client and\r\n    // the opening handshake fails. Under these circumstances, in fact, the\r\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\r\n    // properties are set to `null`.\r\n    //\r\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\r\n    else websocket._bufferedAmount += length;\r\n  }\r\n\r\n  if (cb) {\r\n    const err = new Error(\r\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\r\n        `(${readyStates[websocket.readyState]})`\r\n    );\r\n    process.nextTick(cb, err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'conclude'` event.\r\n *\r\n * @param {Number} code The status code\r\n * @param {Buffer} reason The reason for closing\r\n * @private\r\n */\r\nfunction receiverOnConclude(code, reason) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._closeFrameReceived = true;\r\n  websocket._closeMessage = reason;\r\n  websocket._closeCode = code;\r\n\r\n  if (websocket._socket[kWebSocket] === undefined) return;\r\n\r\n  websocket._socket.removeListener('data', socketOnData);\r\n  process.nextTick(resume, websocket._socket);\r\n\r\n  if (code === 1005) websocket.close();\r\n  else websocket.close(code, reason);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'drain'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnDrain() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (!websocket.isPaused) websocket._socket.resume();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'error'` event.\r\n *\r\n * @param {(RangeError|Error)} err The emitted error\r\n * @private\r\n */\r\nfunction receiverOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._socket[kWebSocket] !== undefined) {\r\n    websocket._socket.removeListener('data', socketOnData);\r\n\r\n    //\r\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\r\n    // https://github.com/websockets/ws/issues/1940.\r\n    //\r\n    process.nextTick(resume, websocket._socket);\r\n\r\n    websocket.close(err[kStatusCode]);\r\n  }\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'finish'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnFinish() {\r\n  this[kWebSocket].emitClose();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'message'` event.\r\n *\r\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\r\n * @param {Boolean} isBinary Specifies whether the message is binary or not\r\n * @private\r\n */\r\nfunction receiverOnMessage(data, isBinary) {\r\n  this[kWebSocket].emit('message', data, isBinary);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'ping'` event.\r\n *\r\n * @param {Buffer} data The data included in the ping frame\r\n * @private\r\n */\r\nfunction receiverOnPing(data) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\r\n  websocket.emit('ping', data);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'pong'` event.\r\n *\r\n * @param {Buffer} data The data included in the pong frame\r\n * @private\r\n */\r\nfunction receiverOnPong(data) {\r\n  this[kWebSocket].emit('pong', data);\r\n}\r\n\r\n/**\r\n * Resume a readable stream\r\n *\r\n * @param {Readable} stream The readable stream\r\n * @private\r\n */\r\nfunction resume(stream) {\r\n  stream.resume();\r\n}\r\n\r\n/**\r\n * The `Sender` error event handler.\r\n *\r\n * @param {Error} The error\r\n * @private\r\n */\r\nfunction senderOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket.readyState === WebSocket.CLOSED) return;\r\n  if (websocket.readyState === WebSocket.OPEN) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    setCloseTimer(websocket);\r\n  }\r\n\r\n  //\r\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\r\n  // peer to finish sending queued data. There is no need to set a timer here\r\n  // because `CLOSING` means that it is already set or not needed.\r\n  //\r\n  this._socket.end();\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Set a timer to destroy the underlying raw socket of a WebSocket.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @private\r\n */\r\nfunction setCloseTimer(websocket) {\r\n  websocket._closeTimer = setTimeout(\r\n    websocket._socket.destroy.bind(websocket._socket),\r\n    closeTimeout\r\n  );\r\n}\r\n\r\n/**\r\n * The listener of the socket `'close'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnClose() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('close', socketOnClose);\r\n  this.removeListener('data', socketOnData);\r\n  this.removeListener('end', socketOnEnd);\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  let chunk;\r\n\r\n  //\r\n  // The close frame might not have been received or the `'end'` event emitted,\r\n  // for example, if the socket was destroyed due to an error. Ensure that the\r\n  // `receiver` stream is closed after writing any remaining buffered data to\r\n  // it. If the readable side of the socket is in flowing mode then there is no\r\n  // buffered data as everything has been already written and `readable.read()`\r\n  // will return `null`. If instead, the socket is paused, any possible buffered\r\n  // data will be read as a single chunk.\r\n  //\r\n  if (\r\n    !this._readableState.endEmitted &&\r\n    !websocket._closeFrameReceived &&\r\n    !websocket._receiver._writableState.errorEmitted &&\r\n    (chunk = websocket._socket.read()) !== null\r\n  ) {\r\n    websocket._receiver.write(chunk);\r\n  }\r\n\r\n  websocket._receiver.end();\r\n\r\n  this[kWebSocket] = undefined;\r\n\r\n  clearTimeout(websocket._closeTimer);\r\n\r\n  if (\r\n    websocket._receiver._writableState.finished ||\r\n    websocket._receiver._writableState.errorEmitted\r\n  ) {\r\n    websocket.emitClose();\r\n  } else {\r\n    websocket._receiver.on('error', receiverOnFinish);\r\n    websocket._receiver.on('finish', receiverOnFinish);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction socketOnData(chunk) {\r\n  if (!this[kWebSocket]._receiver.write(chunk)) {\r\n    this.pause();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnEnd() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  websocket._receiver.end();\r\n  this.end();\r\n}\r\n\r\n/**\r\n * The listener of the socket `'error'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', NOOP);\r\n\r\n  if (websocket) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    this.destroy();\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msa0VBQWtFO0FBQ3hHO0FBQ2E7QUFDYjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDcEQsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0I7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsMkRBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHVEQUFVO0FBQ2pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDNUIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQy9DLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFx3ZWJzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcclxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XHJcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xyXG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgeyBEdXBsZXgsIFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcclxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xyXG5cclxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcclxuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcclxuY29uc3QgeyBpc0Jsb2IgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5cclxuY29uc3Qge1xyXG4gIEJJTkFSWV9UWVBFUyxcclxuICBFTVBUWV9CVUZGRVIsXHJcbiAgR1VJRCxcclxuICBrRm9yT25FdmVudEF0dHJpYnV0ZSxcclxuICBrTGlzdGVuZXIsXHJcbiAga1N0YXR1c0NvZGUsXHJcbiAga1dlYlNvY2tldCxcclxuICBOT09QXHJcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5jb25zdCB7XHJcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XHJcbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xyXG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XHJcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcclxuXHJcbmNvbnN0IGNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcclxuY29uc3Qga0Fib3J0ZWQgPSBTeW1ib2woJ2tBYm9ydGVkJyk7XHJcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xyXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XHJcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICovXHJcbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XHJcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XHJcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xyXG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XHJcbiAgICB0aGlzLl9lcnJvckVtaXR0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcclxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcclxuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcclxuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XHJcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xyXG5cclxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcclxuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcclxuXHJcbiAgICAgIGlmIChwcm90b2NvbHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHByb3RvY29scyA9IFtdO1xyXG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xyXG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9hdXRvUG9uZyA9IG9wdGlvbnMuYXV0b1Bvbmc7XHJcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRoZSBjdXN0b20gXCJub2RlYnVmZmVyXCIgdHlwZSBpcyB1c2VkIGJ5IHRoZSBkZWZhdWx0XHJcbiAgICogaW5zdGVhZCBvZiBcImJsb2JcIi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcclxuICB9XHJcblxyXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcclxuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cclxuICAgIC8vXHJcbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xyXG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzUGF1c2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIGdldCBvbmNsb3NlKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBnZXQgb25lcnJvcigpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgZ2V0IG9ub3BlbigpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgZ2V0IG9ubWVzc2FnZSgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgcHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZWFkeVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCB1cmwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlclxyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxyXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcclxuICAgKiAgICAgbWFza2luZyBrZXlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxyXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXHJcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcclxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcclxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxyXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHNlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XHJcblxyXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcclxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcclxuXHJcbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XHJcbiAgICBzZW5kZXJba1dlYlNvY2tldF0gPSB0aGlzO1xyXG4gICAgc29ja2V0W2tXZWJTb2NrZXRdID0gdGhpcztcclxuXHJcbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xyXG4gICAgcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcclxuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XHJcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcclxuICAgIHJlY2VpdmVyLm9uKCdwaW5nJywgcmVjZWl2ZXJPblBpbmcpO1xyXG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XHJcblxyXG4gICAgc2VuZGVyLm9uZXJyb3IgPSBzZW5kZXJPbkVycm9yO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGVzZSBtZXRob2RzIG1heSBub3QgYmUgYXZhaWxhYmxlIGlmIGBzb2NrZXRgIGlzIGp1c3QgYSBgRHVwbGV4YC5cclxuICAgIC8vXHJcbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xyXG4gICAgaWYgKHNvY2tldC5zZXROb0RlbGF5KSBzb2NrZXQuc2V0Tm9EZWxheSgpO1xyXG5cclxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xyXG5cclxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcclxuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XHJcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcclxuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcclxuXHJcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XHJcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZW1pdENsb3NlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcclxuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XHJcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xyXG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xyXG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXHJcbiAgICpcclxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXHJcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXHJcbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxyXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XHJcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xyXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XHJcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxyXG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxyXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcclxuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xyXG4gICAqICAgICAgICAgICAgICArLS0tK1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXHJcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xyXG4gICAqICAgICBjbG9zaW5nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcclxuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXHJcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxyXG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cclxuICAgICAgLy9cclxuICAgICAgaWYgKGVycikgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxyXG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHNldENsb3NlVGltZXIodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSB0aGUgc29ja2V0LlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGEgcGluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjYiA9IGRhdGE7XHJcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjYiA9IG1hc2s7XHJcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcclxuXHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xyXG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgYSBwb25nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gZGF0YTtcclxuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gbWFzaztcclxuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcmVzdW1lKCkge1xyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcclxuICAgKiAgICAgdGV4dFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xyXG4gICAqICAgICBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXHJcbiAgICogICAgIGxhc3Qgb25lXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjYiA9IG9wdGlvbnM7XHJcbiAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdHMgPSB7XHJcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxyXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXHJcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxyXG4gICAgICBmaW46IHRydWUsXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgdGVybWluYXRlKCkge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcclxuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XHJcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcclxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cclxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcclxufSk7XHJcblxyXG5bXHJcbiAgJ2JpbmFyeVR5cGUnLFxyXG4gICdidWZmZXJlZEFtb3VudCcsXHJcbiAgJ2V4dGVuc2lvbnMnLFxyXG4gICdpc1BhdXNlZCcsXHJcbiAgJ3Byb3RvY29sJyxcclxuICAncmVhZHlTdGF0ZScsXHJcbiAgJ3VybCdcclxuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG59KTtcclxuXHJcbi8vXHJcbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cclxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcclxuLy9cclxuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldCgpIHtcclxuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHNldChoYW5kbGVyKSB7XHJcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xyXG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcclxuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxyXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcclxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIGFueVxyXG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxyXG4gKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xyXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xyXG4gKiAgICAgY3VzdG9taXplIHRoZSBoZWFkZXJzIG9mIGVhY2ggaHR0cCByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50XHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcclxuICogICAgIHJlZGlyZWN0c1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gKiAgICAgbWFza2luZyBrZXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcclxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXHJcbiAqICAgICBzaXplXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcclxuICogICAgIGFsbG93ZWRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXHJcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXHJcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXHJcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XHJcbiAgY29uc3Qgb3B0cyA9IHtcclxuICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXHJcbiAgICBhdXRvUG9uZzogdHJ1ZSxcclxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcclxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxyXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcclxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxyXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcclxuICAgIG1heFJlZGlyZWN0czogMTAsXHJcbiAgICAuLi5vcHRpb25zLFxyXG4gICAgc29ja2V0UGF0aDogdW5kZWZpbmVkLFxyXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcclxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXHJcbiAgICB0aW1lb3V0OiB1bmRlZmluZWQsXHJcbiAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgaG9zdDogdW5kZWZpbmVkLFxyXG4gICAgcGF0aDogdW5kZWZpbmVkLFxyXG4gICAgcG9ydDogdW5kZWZpbmVkXHJcbiAgfTtcclxuXHJcbiAgd2Vic29ja2V0Ll9hdXRvUG9uZyA9IG9wdHMuYXV0b1Bvbmc7XHJcblxyXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcclxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxyXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXHJcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgbGV0IHBhcnNlZFVybDtcclxuXHJcbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcclxuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcclxuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xyXG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzczonO1xyXG4gIH1cclxuXHJcbiAgd2Vic29ja2V0Ll91cmwgPSBwYXJzZWRVcmwuaHJlZjtcclxuXHJcbiAgY29uc3QgaXNTZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3c3M6JztcclxuICBjb25zdCBpc0lwY1VybCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcclxuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XHJcblxyXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICd3czonICYmICFpc1NlY3VyZSAmJiAhaXNJcGNVcmwpIHtcclxuICAgIGludmFsaWRVcmxNZXNzYWdlID1cclxuICAgICAgJ1RoZSBVUkxcXCdzIHByb3RvY29sIG11c3QgYmUgb25lIG9mIFwid3M6XCIsIFwid3NzOlwiLCAnICtcclxuICAgICAgJ1wiaHR0cDpcIiwgXCJodHRwczpcIiwgb3IgXCJ3cyt1bml4OlwiJztcclxuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcclxuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcclxuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XHJcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XHJcbiAgfVxyXG5cclxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XHJcblxyXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xyXG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcclxuICBjb25zdCBwcm90b2NvbFNldCA9IG5ldyBTZXQoKTtcclxuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XHJcblxyXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9XHJcbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xyXG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xyXG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xyXG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcclxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxyXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XHJcbiAgb3B0cy5oZWFkZXJzID0ge1xyXG4gICAgLi4ub3B0cy5oZWFkZXJzLFxyXG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxyXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxyXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxyXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCdcclxuICB9O1xyXG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XHJcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xyXG5cclxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xyXG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXHJcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICBvcHRzLm1heFBheWxvYWRcclxuICAgICk7XHJcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcclxuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcclxuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcclxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcclxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcclxuICB9XHJcbiAgaWYgKG9wdHMub3JpZ2luKSB7XHJcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xyXG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcclxuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcclxuICB9XHJcblxyXG4gIGlmIChpc0lwY1VybCkge1xyXG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcclxuXHJcbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcclxuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xyXG4gIH1cclxuXHJcbiAgbGV0IHJlcTtcclxuXHJcbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XHJcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcclxuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbElwYyA9IGlzSXBjVXJsO1xyXG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XHJcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcclxuICAgICAgICA/IG9wdHMuc29ja2V0UGF0aFxyXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XHJcblxyXG4gICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnM7XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHVzZXIgcHJvdmlkZWQgb3B0aW9ucyBzbyB0aGF0IGhlYWRlcnMgY2FuIGJlIGNoYW5nZWRcclxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gICAgICAvL1xyXG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7fSB9O1xyXG5cclxuICAgICAgaWYgKGhlYWRlcnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xyXG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xyXG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcclxuICAgICAgICA/IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcclxuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxyXG4gICAgICAgICAgOiBmYWxzZVxyXG4gICAgICAgIDogd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xyXG4gICAgICAgICAgPyBmYWxzZVxyXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XHJcblxyXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIGRyb3AgdGhlIGZvbGxvd2luZyBoZWFkZXJzLiBUaGVzZVxyXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xyXG5cclxuICAgICAgICBpZiAoIWlzU2FtZUhvc3QpIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcclxuXHJcbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cclxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XHJcbiAgICAvLyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cclxuICAgIC8vXHJcbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xyXG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9XHJcbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XHJcblxyXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xyXG4gICAgICAvLyB0cmlnZ2VyZWQgaGVyZSBpZiB0aGUgdXNlciBjYWxscyBgd2Vic29ja2V0LmNsb3NlKClgIG9yXHJcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXHJcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcclxuICAgICAgLy8gYmVmb3JlIGNhbGxpbmcgYHdlYnNvY2tldC5jbG9zZSgpYCBvciBgd2Vic29ja2V0LnRlcm1pbmF0ZSgpYCBhbmQgdGhpc1xyXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXHJcbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXHJcbiAgICAgIC8vXHJcbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcclxuICB9XHJcblxyXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcclxuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XHJcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcclxuXHJcbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XHJcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XHJcbiAgfSk7XHJcblxyXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XHJcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xyXG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgbG9jYXRpb24gJiZcclxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcclxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcclxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxyXG4gICAgKSB7XHJcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXEuYWJvcnQoKTtcclxuXHJcbiAgICAgIGxldCBhZGRyO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2xvY2F0aW9ufWApO1xyXG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZShcclxuICAgICAgICB3ZWJzb2NrZXQsXHJcbiAgICAgICAgcmVxLFxyXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xyXG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxyXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXHJcbiAgICAvL1xyXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xyXG5cclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcclxuXHJcbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcclxuXHJcbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcclxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxyXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcclxuXHJcbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcclxuICAgIGxldCBwcm90RXJyb3I7XHJcblxyXG4gICAgaWYgKHNlcnZlclByb3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcclxuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcclxuICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XHJcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sU2V0LnNpemUpIHtcclxuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvdEVycm9yKSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5fcHJvdG9jb2wgPSBzZXJ2ZXJQcm90O1xyXG5cclxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XHJcblxyXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XHJcbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXHJcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGV4dGVuc2lvbnM7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XHJcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9XHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcclxuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxyXG4gICAgICBnZW5lcmF0ZU1hc2s6IG9wdHMuZ2VuZXJhdGVNYXNrLFxyXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBpZiAob3B0cy5maW5pc2hSZXF1ZXN0KSB7XHJcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXEuZW5kKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcclxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XHJcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XHJcbiAgLy9cclxuICAvLyBUaGUgZm9sbG93aW5nIGFzc2lnbm1lbnQgaXMgcHJhY3RpY2FsbHkgdXNlbGVzcyBhbmQgaXMgZG9uZSBvbmx5IGZvclxyXG4gIC8vIGNvbnNpc3RlbmN5LlxyXG4gIC8vXHJcbiAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XHJcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XHJcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xyXG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcclxuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xyXG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xyXG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cclxuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcclxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuXHJcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xyXG5cclxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xyXG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XHJcbiAgICBzdHJlYW0uYWJvcnQoKTtcclxuXHJcbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXHJcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cclxuICAgICAgLy9cclxuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xyXG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcclxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXHJcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcclxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XHJcbiAgaWYgKGRhdGEpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGlzQmxvYihkYXRhKSA/IGRhdGEuc2l6ZSA6IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxyXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcclxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxyXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cclxuICAgIC8vXHJcbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcclxuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XHJcbiAgfVxyXG5cclxuICBpZiAoY2IpIHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcclxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcclxuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXHJcbiAgICApO1xyXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcclxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xyXG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xyXG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHJcbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xyXG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XHJcblxyXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcclxuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICBpZiAoIXdlYnNvY2tldC5pc1BhdXNlZCkgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cclxuICAgIC8vXHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xyXG5cclxuICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcclxuICB9XHJcblxyXG4gIGlmICghd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQpIHtcclxuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcclxuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xyXG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XHJcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIGlmICh3ZWJzb2NrZXQuX2F1dG9Qb25nKSB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIE5PT1ApO1xyXG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XHJcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cclxuICpcclxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcclxuICBzdHJlYW0ucmVzdW1lKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFNlbmRlcmAgZXJyb3IgZXZlbnQgaGFuZGxlci5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kZXJPbkVycm9yKGVycikge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xyXG4gIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICAvLyBgc29ja2V0LmVuZCgpYCBpcyB1c2VkIGluc3RlYWQgb2YgYHNvY2tldC5kZXN0cm95KClgIHRvIGFsbG93IHRoZSBvdGhlclxyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxyXG4gIC8vIGJlY2F1c2UgYENMT1NJTkdgIG1lYW5zIHRoYXQgaXQgaXMgYWxyZWFkeSBzZXQgb3Igbm90IG5lZWRlZC5cclxuICAvL1xyXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcclxuXHJcbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xyXG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2xvc2VUaW1lcih3ZWJzb2NrZXQpIHtcclxuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxyXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQuZGVzdHJveS5iaW5kKHdlYnNvY2tldC5fc29ja2V0KSxcclxuICAgIGNsb3NlVGltZW91dFxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xyXG5cclxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuXHJcbiAgbGV0IGNodW5rO1xyXG5cclxuICAvL1xyXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXHJcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxyXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xyXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXHJcbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcclxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcclxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cclxuICAvL1xyXG4gIGlmIChcclxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcclxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxyXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXHJcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXHJcbiAgKSB7XHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcclxuICB9XHJcblxyXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XHJcblxyXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XHJcblxyXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xyXG5cclxuICBpZiAoXHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxyXG4gICkge1xyXG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xyXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xyXG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XHJcbiAgICB0aGlzLnBhdXNlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XHJcbiAgdGhpcy5lbmQoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZXJyb3InYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcclxuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xyXG5cclxuICBpZiAod2Vic29ja2V0KSB7XHJcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket.js\n");

/***/ })

};
;