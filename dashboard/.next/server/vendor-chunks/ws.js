"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ws";
exports.ids = ["vendor-chunks/ws"];
exports.modules = {

/***/ "(rsc)/./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\r\n\r\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(rsc)/./node_modules/ws/lib/stream.js\");\r\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(rsc)/./node_modules/ws/lib/websocket-server.js\");\r\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\r\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(rsc)/./node_modules/ws/lib/sender.js\");\r\n\r\nWebSocket.WebSocket = WebSocket;\r\nWebSocket.WebSocketServer = WebSocket.Server;\r\n\r\nmodule.exports = WebSocket;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlFQUFpQjtBQUMzQztBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDJEQUFjO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLCtFQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMkRBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldCcpO1xyXG5cclxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xyXG5XZWJTb2NrZXQuU2VydmVyID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0LXNlcnZlcicpO1xyXG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xyXG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XHJcblxyXG5XZWJTb2NrZXQuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xyXG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nfunction concat(list, totalLength) {\r\n  if (list.length === 0) return EMPTY_BUFFER;\r\n  if (list.length === 1) return list[0];\r\n\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  let offset = 0;\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    target.set(buf, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  if (offset < totalLength) {\r\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Masks a buffer using the given mask.\r\n *\r\n * @param {Buffer} source The buffer to mask\r\n * @param {Buffer} mask The mask to use\r\n * @param {Buffer} output The buffer where to store the result\r\n * @param {Number} offset The offset at which to start writing\r\n * @param {Number} length The number of bytes to mask.\r\n * @public\r\n */\r\nfunction _mask(source, mask, output, offset, length) {\r\n  for (let i = 0; i < length; i++) {\r\n    output[offset + i] = source[i] ^ mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Unmasks a buffer using the given mask.\r\n *\r\n * @param {Buffer} buffer The buffer to unmask\r\n * @param {Buffer} mask The mask to use\r\n * @public\r\n */\r\nfunction _unmask(buffer, mask) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    buffer[i] ^= mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} buf The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n * @public\r\n */\r\nfunction toArrayBuffer(buf) {\r\n  if (buf.length === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n}\r\n\r\n/**\r\n * Converts `data` to a `Buffer`.\r\n *\r\n * @param {*} data The data to convert\r\n * @return {Buffer} The buffer\r\n * @throws {TypeError}\r\n * @public\r\n */\r\nfunction toBuffer(data) {\r\n  toBuffer.readOnly = true;\r\n\r\n  if (Buffer.isBuffer(data)) return data;\r\n\r\n  let buf;\r\n\r\n  if (data instanceof ArrayBuffer) {\r\n    buf = new FastBuffer(data);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\r\n  } else {\r\n    buf = Buffer.from(data);\r\n    toBuffer.readOnly = false;\r\n  }\r\n\r\n  return buf;\r\n}\r\n\r\nmodule.exports = {\r\n  concat,\r\n  mask: _mask,\r\n  toArrayBuffer,\r\n  toBuffer,\r\n  unmask: _unmask\r\n};\r\n\r\n/* istanbul ignore else  */\r\nif (!process.env.WS_NO_BUFFER_UTIL) {\r\n  try {\r\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?32c4\");\r\n\r\n    module.exports.mask = function (source, mask, output, offset, length) {\r\n      if (length < 48) _mask(source, mask, output, offset, length);\r\n      else bufferUtil.mask(source, mask, output, offset, length);\r\n    };\r\n\r\n    module.exports.unmask = function (buffer, mask) {\r\n      if (buffer.length < 32) _unmask(buffer, mask);\r\n      else bufferUtil.unmask(buffer, mask);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUJBQVk7QUFDM0M7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGJ1ZmZlci11dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcblxyXG4vKipcclxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcclxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcclxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XHJcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcclxuXHJcbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcclxuICBsZXQgb2Zmc2V0ID0gMDtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xyXG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XHJcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcclxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxyXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xyXG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgIHJldHVybiBidWYuYnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcclxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xyXG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcclxuXHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XHJcblxyXG4gIGxldCBidWY7XHJcblxyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XHJcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcclxuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnVmO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBjb25jYXQsXHJcbiAgbWFzazogX21hc2ssXHJcbiAgdG9BcnJheUJ1ZmZlcixcclxuICB0b0J1ZmZlcixcclxuICB1bm1hc2s6IF91bm1hc2tcclxufTtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xyXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XHJcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcclxuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\r\n\r\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\r\nconst hasBlob = typeof Blob !== 'undefined';\r\n\r\nif (hasBlob) BINARY_TYPES.push('blob');\r\n\r\nmodule.exports = {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER: Buffer.alloc(0),\r\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\r\n  hasBlob,\r\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\r\n  kListener: Symbol('kListener'),\r\n  kStatusCode: Symbol('status-code'),\r\n  kWebSocket: Symbol('websocket'),\r\n  NOOP: () => {}\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XHJcbmNvbnN0IGhhc0Jsb2IgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XHJcblxyXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIEJJTkFSWV9UWVBFUyxcclxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcclxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcclxuICBoYXNCbG9iLFxyXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcclxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXHJcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcclxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxyXG4gIE5PT1A6ICgpID0+IHt9XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst kCode = Symbol('kCode');\r\nconst kData = Symbol('kData');\r\nconst kError = Symbol('kError');\r\nconst kMessage = Symbol('kMessage');\r\nconst kReason = Symbol('kReason');\r\nconst kTarget = Symbol('kTarget');\r\nconst kType = Symbol('kType');\r\nconst kWasClean = Symbol('kWasClean');\r\n\r\n/**\r\n * Class representing an event.\r\n */\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\r\n  constructor(type) {\r\n    this[kTarget] = null;\r\n    this[kType] = type;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get target() {\r\n    return this[kTarget];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get type() {\r\n    return this[kType];\r\n  }\r\n}\r\n\r\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\r\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\r\n\r\n/**\r\n * Class representing a close event.\r\n *\r\n * @extends Event\r\n */\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kCode] = options.code === undefined ? 0 : options.code;\r\n    this[kReason] = options.reason === undefined ? '' : options.reason;\r\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get code() {\r\n    return this[kCode];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get reason() {\r\n    return this[kReason];\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get wasClean() {\r\n    return this[kWasClean];\r\n  }\r\n}\r\n\r\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\r\n\r\n/**\r\n * Class representing an error event.\r\n *\r\n * @extends Event\r\n */\r\nclass ErrorEvent extends Event {\r\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kError] = options.error === undefined ? null : options.error;\r\n    this[kMessage] = options.message === undefined ? '' : options.message;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get error() {\r\n    return this[kError];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get message() {\r\n    return this[kMessage];\r\n  }\r\n}\r\n\r\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\r\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\r\n\r\n/**\r\n * Class representing a message event.\r\n *\r\n * @extends Event\r\n */\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kData] = options.data === undefined ? null : options.data;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get data() {\r\n    return this[kData];\r\n  }\r\n}\r\n\r\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\r\n\r\n/**\r\n * This provides methods for emulating the `EventTarget` interface. It's not\r\n * meant to be used directly.\r\n *\r\n * @mixin\r\n */\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\r\n  addEventListener(type, handler, options = {}) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (\r\n        !options[kForOnEventAttribute] &&\r\n        listener[kListener] === handler &&\r\n        !listener[kForOnEventAttribute]\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    let wrapper;\r\n\r\n    if (type === 'message') {\r\n      wrapper = function onMessage(data, isBinary) {\r\n        const event = new MessageEvent('message', {\r\n          data: isBinary ? data : data.toString()\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'close') {\r\n      wrapper = function onClose(code, message) {\r\n        const event = new CloseEvent('close', {\r\n          code,\r\n          reason: message.toString(),\r\n          wasClean: this._closeFrameReceived && this._closeFrameSent\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'error') {\r\n      wrapper = function onError(error) {\r\n        const event = new ErrorEvent('error', {\r\n          error,\r\n          message: error.message\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'open') {\r\n      wrapper = function onOpen() {\r\n        const event = new Event('open');\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\r\n    wrapper[kListener] = handler;\r\n\r\n    if (options.once) {\r\n      this.once(type, wrapper);\r\n    } else {\r\n      this.on(type, wrapper);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener(type, handler) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\r\n        this.removeListener(type, listener);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  CloseEvent,\r\n  ErrorEvent,\r\n  Event,\r\n  EventTarget,\r\n  MessageEvent\r\n};\r\n\r\n/**\r\n * Call an event listener\r\n *\r\n * @param {(Function|Object)} listener The listener to call\r\n * @param {*} thisArg The value to use as `this`` when calling the listener\r\n * @param {Event} event The event to pass to the listener\r\n * @private\r\n */\r\nfunction callListener(listener, thisArg, event) {\r\n  if (typeof listener === 'object' && listener.handleEvent) {\r\n    listener.handleEvent.call(listener, event);\r\n  } else {\r\n    listener.call(thisArg, event);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekUseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGV2ZW50LXRhcmdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IGtGb3JPbkV2ZW50QXR0cmlidXRlLCBrTGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcclxuY29uc3Qga0RhdGEgPSBTeW1ib2woJ2tEYXRhJyk7XHJcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XHJcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xyXG5jb25zdCBrUmVhc29uID0gU3ltYm9sKCdrUmVhc29uJyk7XHJcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcclxuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XHJcbmNvbnN0IGtXYXNDbGVhbiA9IFN5bWJvbCgna1dhc0NsZWFuJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XHJcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcclxuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHsqfVxyXG4gICAqL1xyXG4gIGdldCB0YXJnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndHlwZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cclxuICpcclxuICogQGV4dGVuZHMgRXZlbnRcclxuICovXHJcbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xyXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxyXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxyXG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxyXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIodHlwZSk7XHJcblxyXG4gICAgdGhpc1trQ29kZV0gPSBvcHRpb25zLmNvZGUgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmNvZGU7XHJcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XHJcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBjb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba0NvZGVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgcmVhc29uKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgd2FzQ2xlYW4oKSB7XHJcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnY29kZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcclxuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xyXG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICovXHJcbiAgZ2V0IGVycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IG1lc3NhZ2UoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnbWVzc2FnZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtZXNzYWdlIGV2ZW50LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBFdmVudFxyXG4gKi9cclxuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xyXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXHJcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICovXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgJ2RhdGEnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxyXG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAbWl4aW5cclxuICovXHJcbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcclxuICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXHJcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxyXG4gICAqICAgICB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXSAmJlxyXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcclxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCB3cmFwcGVyO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcclxuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHtcclxuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XHJcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xyXG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XHJcbiAgICAgICAgICBjb2RlLFxyXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcclxuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XHJcbiAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xyXG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xyXG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XHJcblxyXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcclxuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcclxuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xyXG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XHJcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIENsb3NlRXZlbnQsXHJcbiAgRXJyb3JFdmVudCxcclxuICBFdmVudCxcclxuICBFdmVudFRhcmdldCxcclxuICBNZXNzYWdlRXZlbnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYGAgd2hlbiBjYWxsaW5nIHRoZSBsaXN0ZW5lclxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcclxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG4gICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbChsaXN0ZW5lciwgZXZlbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Adds an offer to the map of extension offers or a parameter to the map of\r\n * parameters.\r\n *\r\n * @param {Object} dest The map of extension offers or parameters\r\n * @param {String} name The extension or parameter name\r\n * @param {(Object|Boolean|String)} elem The extension parameters or the\r\n *     parameter value\r\n * @private\r\n */\r\nfunction push(dest, name, elem) {\r\n  if (dest[name] === undefined) dest[name] = [elem];\r\n  else dest[name].push(elem);\r\n}\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Extensions` header into an object.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Object} The parsed object\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const offers = Object.create(null);\r\n  let params = Object.create(null);\r\n  let mustUnescape = false;\r\n  let isEscaping = false;\r\n  let inQuotes = false;\r\n  let extensionName;\r\n  let paramName;\r\n  let start = -1;\r\n  let code = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (; i < header.length; i++) {\r\n    code = header.charCodeAt(i);\r\n\r\n    if (extensionName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (\r\n        i !== 0 &&\r\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n      ) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 0x2c) {\r\n          push(offers, name, params);\r\n          params = Object.create(null);\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20 || code === 0x09) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      //\r\n      // The value of a quoted-string after unescaping must conform to the\r\n      // token ABNF, so only token characters are valid.\r\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\r\n      //\r\n      if (isEscaping) {\r\n        if (tokenChars[code] !== 1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1) start = i;\r\n        else if (!mustUnescape) mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars[code] === 1) {\r\n          if (start === -1) start = i;\r\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 0x5c /* '\\' */) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\r\n        if (end === -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        let value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, '');\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        paramName = undefined;\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  if (end === -1) end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === undefined) {\r\n    push(offers, token, params);\r\n  } else {\r\n    if (paramName === undefined) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, ''));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n\r\n  return offers;\r\n}\r\n\r\n/**\r\n * Builds the `Sec-WebSocket-Extensions` header field value.\r\n *\r\n * @param {Object} extensions The map of extensions and parameters to format\r\n * @return {String} A string representing the given object\r\n * @public\r\n */\r\nfunction format(extensions) {\r\n  return Object.keys(extensions)\r\n    .map((extension) => {\r\n      let configurations = extensions[extension];\r\n      if (!Array.isArray(configurations)) configurations = [configurations];\r\n      return configurations\r\n        .map((params) => {\r\n          return [extension]\r\n            .concat(\r\n              Object.keys(params).map((k) => {\r\n                let values = params[k];\r\n                if (!Array.isArray(values)) values = [values];\r\n                return values\r\n                  .map((v) => (v === true ? k : `${k}=${v}`))\r\n                  .join('; ');\r\n              })\r\n            )\r\n            .join('; ');\r\n        })\r\n        .join(', ');\r\n    })\r\n    .join(', ');\r\n}\r\n\r\nmodule.exports = { format, parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxleHRlbnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIG9mZmVyIHRvIHRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBhIHBhcmFtZXRlciB0byB0aGUgbWFwIG9mXHJcbiAqIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcclxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXHJcbiAqICAgICBwYXJhbWV0ZXIgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xyXG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XHJcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xyXG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xyXG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XHJcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XHJcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XHJcbiAgbGV0IHBhcmFtTmFtZTtcclxuICBsZXQgc3RhcnQgPSAtMTtcclxuICBsZXQgY29kZSA9IC0xO1xyXG4gIGxldCBlbmQgPSAtMTtcclxuICBsZXQgaSA9IDA7XHJcblxyXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XHJcblxyXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIGkgIT09IDAgJiZcclxuICAgICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcclxuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xyXG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcclxuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xyXG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcclxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cclxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xyXG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XHJcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XHJcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcclxuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XHJcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XHJcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xyXG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xyXG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzIHx8IGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XHJcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcclxuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XHJcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuLnJlcGxhY2UoL1xcXFwvZywgJycpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcclxuICAgIH1cclxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9mZmVycztcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XHJcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucylcclxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcclxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl1cclxuICAgICAgICAgICAgLmNvbmNhdChcclxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHBhcmFtc1trXTtcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApKVxyXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmpvaW4oJywgJyk7XHJcbiAgICB9KVxyXG4gICAgLmpvaW4oJywgJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\r\n\r\nconst kDone = Symbol('kDone');\r\nconst kRun = Symbol('kRun');\r\n\r\n/**\r\n * A very simple job queue with adjustable concurrency. Adapted from\r\n * https://github.com/STRML/async-limiter\r\n */\r\nclass Limiter {\r\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\r\n  constructor(concurrency) {\r\n    this[kDone] = () => {\r\n      this.pending--;\r\n      this[kRun]();\r\n    };\r\n    this.concurrency = concurrency || Infinity;\r\n    this.jobs = [];\r\n    this.pending = 0;\r\n  }\r\n\r\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\r\n  add(job) {\r\n    this.jobs.push(job);\r\n    this[kRun]();\r\n  }\r\n\r\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\r\n  [kRun]() {\r\n    if (this.pending === this.concurrency) return;\r\n\r\n    if (this.jobs.length) {\r\n      const job = this.jobs.shift();\r\n\r\n      this.pending++;\r\n      job(this[kDone]);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Limiter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxsaW1pdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xyXG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XHJcblxyXG4vKipcclxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcclxuICovXHJcbmNsYXNzIExpbWl0ZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxyXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcclxuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLnBlbmRpbmctLTtcclxuICAgICAgdGhpc1trUnVuXSgpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcclxuICAgIHRoaXMuam9icyA9IFtdO1xyXG4gICAgdGhpcy5wZW5kaW5nID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZChqb2IpIHtcclxuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XHJcbiAgICB0aGlzW2tSdW5dKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBba1J1bl0oKSB7XHJcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcclxuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XHJcblxyXG4gICAgICB0aGlzLnBlbmRpbmcrKztcclxuICAgICAgam9iKHRoaXNba0RvbmVdKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\n\r\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\r\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/ws/lib/limiter.js\");\r\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst kPerMessageDeflate = Symbol('permessage-deflate');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\r\n  constructor(options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold =\r\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency =\r\n        this._options.concurrencyLimit !== undefined\r\n          ? this._options.concurrencyLimit\r\n          : 10;\r\n      zlibLimiter = new Limiter(concurrency);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName() {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer() {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept(configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n\r\n    this.params = this._isServer\r\n      ? this.acceptAsServer(configurations)\r\n      : this.acceptAsClient(configurations);\r\n\r\n    return this.params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup() {\r\n    if (this._inflate) {\r\n      this._inflate.close();\r\n      this._inflate = null;\r\n    }\r\n\r\n    if (this._deflate) {\r\n      const callback = this._deflate[kCallback];\r\n\r\n      this._deflate.close();\r\n      this._deflate = null;\r\n\r\n      if (callback) {\r\n        callback(\r\n          new Error(\r\n            'The deflate stream was closed while data was being processed'\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer(offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (\r\n        (opts.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (params.server_max_window_bits &&\r\n          (opts.serverMaxWindowBits === false ||\r\n            (typeof opts.serverMaxWindowBits === 'number' &&\r\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\r\n        (typeof opts.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    if (!accepted) {\r\n      throw new Error('None of the extension offers can be accepted');\r\n    }\r\n\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === 'number') {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === 'number') {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (\r\n      accepted.client_max_window_bits === true ||\r\n      opts.clientMaxWindowBits === false\r\n    ) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient(response) {\r\n    const params = response[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (\r\n      this._options.clientMaxWindowBits === false ||\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\r\n    ) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams(configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        let value = params[key];\r\n\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        if (key === 'client_max_window_bits') {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === 'server_max_window_bits') {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (\r\n          key === 'client_no_context_takeover' ||\r\n          key === 'server_no_context_takeover'\r\n        ) {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n\r\n        params[key] = value;\r\n      });\r\n    });\r\n\r\n    return configurations;\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw({\r\n        ...this._options.zlibInflateOptions,\r\n        windowBits\r\n      });\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (this._inflate._readableState.endEmitted) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n\r\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n          this._inflate.reset();\r\n        }\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw({\r\n        ...this._options.zlibDeflateOptions,\r\n        windowBits\r\n      });\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kCallback] = callback;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      if (!this._deflate) {\r\n        //\r\n        // The deflate stream was closed while data was being processed.\r\n        //\r\n        return;\r\n      }\r\n\r\n      let data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) {\r\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\r\n      }\r\n\r\n      //\r\n      // Ensure that the callback will not be called again in\r\n      // `PerMessageDeflate#cleanup()`.\r\n      //\r\n      this._deflate[kCallback] = null;\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n        this._deflate.reset();\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData(chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData(chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kPerMessageDeflate]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new RangeError('Max payload size exceeded');\r\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\r\n  this[kError][kStatusCode] = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n\r\n  //\r\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\r\n  // fact that in Node.js versions prior to 13.10.0, the callback for\r\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\r\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\r\n  // emitted.\r\n  //\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError(err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kPerMessageDeflate]._inflate = null;\r\n\r\n  if (this[kError]) {\r\n    this[kCallback](this[kError]);\r\n    return;\r\n  }\r\n\r\n  err[kStatusCode] = 1007;\r\n  this[kCallback](err);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMseURBQVc7QUFDbkMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHBlcm1lc3NhZ2UtZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xyXG5cclxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcclxuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xyXG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xyXG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xyXG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XHJcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XHJcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcclxuXHJcbi8vXHJcbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxyXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXHJcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxyXG4vL1xyXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cclxuLy9cclxubGV0IHpsaWJMaW1pdGVyO1xyXG5cclxuLyoqXHJcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcclxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXHJcbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcclxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxyXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcclxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcclxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxyXG4gICAqICAgICBkZWZsYXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cclxuICAgKiAgICAgaW5mbGF0ZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcclxuICAgKiAgICAgY2xpZW50IG1vZGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XHJcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XHJcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMuX3RocmVzaG9sZCA9XHJcbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XHJcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcclxuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XHJcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cclxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcclxuICAgICAgICAgIDogMTA7XHJcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XHJcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBvZmZlcigpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xyXG5cclxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XHJcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xyXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xyXG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcclxuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XHJcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XHJcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcclxuXHJcbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXHJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcclxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjbGVhbnVwKCkge1xyXG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcclxuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xyXG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcclxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayhcclxuICAgICAgICAgIG5ldyBFcnJvcihcclxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xyXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcclxuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXHJcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XHJcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXHJcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxyXG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFhY2NlcHRlZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcclxuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcclxuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcclxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxyXG4gICAgKSB7XHJcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2NlcHRlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcclxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XHJcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXHJcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xyXG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xyXG5cclxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcclxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcclxuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcclxuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFsdWUgPSBudW07XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxyXG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcclxuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xyXG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XHJcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcclxuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb21wcmVzcyBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xyXG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cclxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcclxuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xyXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xyXG5cclxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XHJcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXHJcbiAgICAgICAgd2luZG93Qml0c1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcclxuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XHJcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xyXG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xyXG5cclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XHJcblxyXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xyXG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXByZXNzIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xyXG5cclxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcclxuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XHJcbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXHJcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcclxuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xyXG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxyXG4gICAgICAgIHdpbmRvd0JpdHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xyXG5cclxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xyXG5cclxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XHJcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxyXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxyXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGZpbikge1xyXG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXHJcbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxyXG4gICAgICAvL1xyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcclxuXHJcbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xyXG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcclxuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcclxuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcclxuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xyXG5cclxuICBpZiAoXHJcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XHJcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXHJcbiAgKSB7XHJcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XHJcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcclxuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XHJcblxyXG4gIC8vXHJcbiAgLy8gVGhlIGNob2ljZSB0byBlbXBsb3kgYHpsaWIucmVzZXQoKWAgb3ZlciBgemxpYi5jbG9zZSgpYCBpcyBkaWN0YXRlZCBieSB0aGVcclxuICAvLyBmYWN0IHRoYXQgaW4gTm9kZS5qcyB2ZXJzaW9ucyBwcmlvciB0byAxMy4xMC4wLCB0aGUgY2FsbGJhY2sgZm9yXHJcbiAgLy8gYHpsaWIuZmx1c2goKWAgaXMgbm90IGNhbGxlZCBpZiBgemxpYi5jbG9zZSgpYCBpcyB1c2VkLiBVdGlsaXppbmdcclxuICAvLyBgemxpYi5yZXNldCgpYCBlbnN1cmVzIHRoYXQgZWl0aGVyIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkIG9yIGFuIGVycm9yIGlzXHJcbiAgLy8gZW1pdHRlZC5cclxuICAvL1xyXG4gIHRoaXMucmVzZXQoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcclxuICAvL1xyXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcclxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxyXG4gIC8vXHJcbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcclxuXHJcbiAgaWYgKHRoaXNba0Vycm9yXSkge1xyXG4gICAgdGhpc1trQ2FsbGJhY2tdKHRoaXNba0Vycm9yXSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcclxuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  kStatusCode,\r\n  kWebSocket\r\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\r\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\nconst DEFER_EVENT = 6;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends Writable\r\n */\r\nclass Receiver extends Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    this._allowSynchronousEvents =\r\n      options.allowSynchronousEvents !== undefined\r\n        ? options.allowSynchronousEvents\r\n        : true;\r\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\r\n    this._extensions = options.extensions || {};\r\n    this._isServer = !!options.isServer;\r\n    this._maxPayload = options.maxPayload | 0;\r\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\r\n    this[kWebSocket] = undefined;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = undefined;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._errored = false;\r\n    this._loop = false;\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  _write(chunk, encoding, cb) {\r\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\r\n\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume(n) {\r\n    this._bufferedBytes -= n;\r\n\r\n    if (n === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = new FastBuffer(\r\n        buf.buffer,\r\n        buf.byteOffset + n,\r\n        buf.length - n\r\n      );\r\n\r\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\r\n    }\r\n\r\n    const dst = Buffer.allocUnsafe(n);\r\n\r\n    do {\r\n      const buf = this._buffers[0];\r\n      const offset = dst.length - n;\r\n\r\n      if (n >= buf.length) {\r\n        dst.set(this._buffers.shift(), offset);\r\n      } else {\r\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\r\n        this._buffers[0] = new FastBuffer(\r\n          buf.buffer,\r\n          buf.byteOffset + n,\r\n          buf.length - n\r\n        );\r\n      }\r\n\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop(cb) {\r\n    this._loop = true;\r\n\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          this.getInfo(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          this.getPayloadLength16(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          this.getPayloadLength64(cb);\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          this.getData(cb);\r\n          break;\r\n        case INFLATING:\r\n        case DEFER_EVENT:\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n\r\n    if (!this._errored) cb();\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getInfo(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV2 and RSV3 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_2_3'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV1 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_1'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'invalid opcode 0',\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid opcode ${this._opcode}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'FIN must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_FIN'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        this._payloadLength > 0x7d ||\r\n        (this._opcode === 0x08 && this._payloadLength === 1)\r\n      ) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else {\r\n      const error = this.createError(\r\n        RangeError,\r\n        `invalid opcode ${this._opcode}`,\r\n        true,\r\n        1002,\r\n        'WS_ERR_INVALID_OPCODE'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._isServer) {\r\n      if (!this._masked) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'MASK must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_MASK'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else if (this._masked) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'MASK must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_MASK'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength16(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength64(cb) {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\r\n        false,\r\n        1009,\r\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  haveLength(cb) {\r\n    if (this._payloadLength && this._opcode < 0x08) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'Max payload size exceeded',\r\n          false,\r\n          1009,\r\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask() {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getData(cb) {\r\n    let data = EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n\r\n      data = this.consume(this._payloadLength);\r\n\r\n      if (\r\n        this._masked &&\r\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\r\n      ) {\r\n        unmask(data, this._mask);\r\n      }\r\n    }\r\n\r\n    if (this._opcode > 0x07) {\r\n      this.controlMessage(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (data.length) {\r\n      //\r\n      // This message is not compressed so its length is the sum of the payload\r\n      // length of all fragments.\r\n      //\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n\r\n    this.dataMessage(cb);\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress(data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) return cb(err);\r\n\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            'Max payload size exceeded',\r\n            false,\r\n            1009,\r\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._fragments.push(buf);\r\n      }\r\n\r\n      this.dataMessage(cb);\r\n      if (this._state === GET_INFO) this.startLoop(cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  dataMessage(cb) {\r\n    if (!this._fin) {\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    const messageLength = this._messageLength;\r\n    const fragments = this._fragments;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragmented = 0;\r\n    this._fragments = [];\r\n\r\n    if (this._opcode === 2) {\r\n      let data;\r\n\r\n      if (this._binaryType === 'nodebuffer') {\r\n        data = concat(fragments, messageLength);\r\n      } else if (this._binaryType === 'arraybuffer') {\r\n        data = toArrayBuffer(concat(fragments, messageLength));\r\n      } else if (this._binaryType === 'blob') {\r\n        data = new Blob(fragments);\r\n      } else {\r\n        data = fragments;\r\n      }\r\n\r\n      if (this._allowSynchronousEvents) {\r\n        this.emit('message', data, true);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', data, true);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    } else {\r\n      const buf = concat(fragments, messageLength);\r\n\r\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n        const error = this.createError(\r\n          Error,\r\n          'invalid UTF-8 sequence',\r\n          true,\r\n          1007,\r\n          'WS_ERR_INVALID_UTF8'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\r\n        this.emit('message', buf, false);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', buf, false);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage(data, cb) {\r\n    if (this._opcode === 0x08) {\r\n      if (data.length === 0) {\r\n        this._loop = false;\r\n        this.emit('conclude', 1005, EMPTY_BUFFER);\r\n        this.end();\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n\r\n        if (!isValidStatusCode(code)) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            `invalid status code ${code}`,\r\n            true,\r\n            1002,\r\n            'WS_ERR_INVALID_CLOSE_CODE'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        const buf = new FastBuffer(\r\n          data.buffer,\r\n          data.byteOffset + 2,\r\n          data.length - 2\r\n        );\r\n\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          const error = this.createError(\r\n            Error,\r\n            'invalid UTF-8 sequence',\r\n            true,\r\n            1007,\r\n            'WS_ERR_INVALID_UTF8'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._loop = false;\r\n        this.emit('conclude', code, buf);\r\n        this.end();\r\n      }\r\n\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    if (this._allowSynchronousEvents) {\r\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n      this._state = GET_INFO;\r\n    } else {\r\n      this._state = DEFER_EVENT;\r\n      setImmediate(() => {\r\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n        this._state = GET_INFO;\r\n        this.startLoop(cb);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds an error object.\r\n   *\r\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\r\n   * @param {String} message The error message\r\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n   *     `message`\r\n   * @param {Number} statusCode The status code\r\n   * @param {String} errorCode The exposed error code\r\n   * @return {(Error|RangeError)} The error\r\n   * @private\r\n   */\r\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\r\n    this._loop = false;\r\n    this._errored = true;\r\n\r\n    const err = new ErrorCtor(\r\n      prefix ? `Invalid WebSocket frame: ${message}` : message\r\n    );\r\n\r\n    Error.captureStackTrace(err, this.createError);\r\n    err.code = errorCode;\r\n    err[kStatusCode] = statusCode;\r\n    return err;\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QixRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDakUsUUFBUSxpQ0FBaUMsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxccmVjZWl2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcblxyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IHtcclxuICBCSU5BUllfVFlQRVMsXHJcbiAgRU1QVFlfQlVGRkVSLFxyXG4gIGtTdGF0dXNDb2RlLFxyXG4gIGtXZWJTb2NrZXRcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcclxuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcblxyXG5jb25zdCBHRVRfSU5GTyA9IDA7XHJcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XHJcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XHJcbmNvbnN0IEdFVF9NQVNLID0gMztcclxuY29uc3QgR0VUX0RBVEEgPSA0O1xyXG5jb25zdCBJTkZMQVRJTkcgPSA1O1xyXG5jb25zdCBERUZFUl9FVkVOVCA9IDY7XHJcblxyXG4vKipcclxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4dGVuZHMgV3JpdGFibGVcclxuICovXHJcbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcclxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxyXG4gICAqICAgICBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxyXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxyXG4gICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXHJcbiAgICAgICAgOiB0cnVlO1xyXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XHJcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xyXG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcclxuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XHJcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xyXG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xyXG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcclxuICAgIHRoaXMuX29wY29kZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XHJcblxyXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcclxuXHJcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcclxuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XHJcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjb25zdW1lKG4pIHtcclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcclxuXHJcbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XHJcblxyXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xyXG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXHJcbiAgICAgICAgYnVmLmJ1ZmZlcixcclxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXHJcbiAgICAgICAgYnVmLmxlbmd0aCAtIG5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcclxuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XHJcblxyXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XHJcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxyXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcclxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcclxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xyXG4gICAgfSB3aGlsZSAobiA+IDApO1xyXG5cclxuICAgIHJldHVybiBkc3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGFydExvb3AoY2IpIHtcclxuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgR0VUX0lORk86XHJcbiAgICAgICAgICB0aGlzLmdldEluZm8oY2IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XHJcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGgxNihjYik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcclxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KGNiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgR0VUX01BU0s6XHJcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XHJcbiAgICAgICAgICB0aGlzLmdldERhdGEoY2IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XHJcbiAgICAgICAgY2FzZSBERUZFUl9FVkVOVDpcclxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldEluZm8oY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XHJcblxyXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xyXG5cclxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgICAgMTAwMixcclxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XHJcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xyXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XHJcblxyXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xyXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xyXG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCB8fFxyXG4gICAgICAgICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNiKGVycm9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xyXG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xyXG5cclxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xyXG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcclxuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XHJcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcclxuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XHJcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcclxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cclxuICAgIC8vXHJcbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIDEwMDksXHJcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XHJcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBoYXZlTGVuZ3RoKGNiKSB7XHJcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XHJcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xyXG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXHJcbiAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgIDEwMDksXHJcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xyXG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgbWFzayBieXRlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0TWFzaygpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0RGF0YShjYikge1xyXG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcclxuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcclxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHtcclxuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcclxuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXHJcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxyXG4gICAgICAvL1xyXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xyXG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcclxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcclxuXHJcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XHJcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xyXG5cclxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIDEwMDksXHJcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xyXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEdFVF9JTkZPKSB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGF0YU1lc3NhZ2UoY2IpIHtcclxuICAgIGlmICghdGhpcy5fZmluKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcclxuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcclxuXHJcbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcclxuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xyXG5cclxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcclxuICAgICAgbGV0IGRhdGE7XHJcblxyXG4gICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XHJcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcclxuICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgZGF0YSA9IG5ldyBCbG9iKGZyYWdtZW50cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIEVycm9yLFxyXG4gICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDcsXHJcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcclxuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxyXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XHJcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XHJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgRU1QVFlfQlVGRkVSKTtcclxuICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xyXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgMTAwMixcclxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKFxyXG4gICAgICAgICAgZGF0YS5idWZmZXIsXHJcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxyXG4gICAgICAgICAgZGF0YS5sZW5ndGggLSAyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcclxuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgICAgRXJyb3IsXHJcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgMTAwNyxcclxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcclxuICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcclxuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xyXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXHJcbiAgICogICAgIGBtZXNzYWdlYFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxyXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XHJcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICB0aGlzLl9lcnJvcmVkID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxyXG4gICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxyXG4gICAgKTtcclxuXHJcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY3JlYXRlRXJyb3IpO1xyXG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XHJcbiAgICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcclxuICAgIHJldHVybiBlcnI7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\r\n * HyBi Sender implementation.\r\n */ class Sender {\n    /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {Duplex} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === 'string') {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n            throw new TypeError('First argument must be a valid error code number');\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError('The message must not be greater than 123 bytes');\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === 'string') {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\r\n   * Gets the contents of a blob as binary data.\r\n   *\r\n   * @param {Blob} blob The blob\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     the data\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while the blob was being read');\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while data was being compressed');\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {(Buffer | String)[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\r\n * Calls queued callbacks with an error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error to call the callbacks with\r\n * @param {Function} [cb] The first callback\r\n * @private\r\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === 'function') cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === 'function') callback(err);\n    }\n}\n/**\r\n * Handles a `Sender` error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error\r\n * @param {Function} [cb] The first pending callback\r\n * @private\r\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0UsR0FFM0Q7QUFFYixNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNuQyxNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUUzQyxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDLCtFQUFzQjtBQUN4RCxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsNkRBQWE7QUFDaEUsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLCtEQUFjO0FBQzVELE1BQU0sRUFBRVEsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsaUVBQWU7QUFFN0QsTUFBTVcsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFFdEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7O0dBT0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUM1QyxJQUFJLENBQUNDLFdBQVcsR0FBR0YsY0FBYyxDQUFDO1FBRWxDLElBQUlDLGNBQWM7WUFDaEIsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1lBQ3JCLElBQUksQ0FBQ0csV0FBVyxHQUFHZixPQUFPQyxLQUFLLENBQUM7UUFDbEM7UUFFQSxJQUFJLENBQUNlLE9BQU8sR0FBR047UUFFZixJQUFJLENBQUNPLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVq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QUFNQyxXQUFXN0IsTUFBTSxDQUFDQSxPQUFPL0IsTUFBTSxHQUFHLEVBQUU7UUFFMUMsSUFBSSxPQUFPNEQsYUFBYSxZQUFZQSxTQUFTckI7SUFDL0M7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTyxRQUFRWSxNQUFNLEVBQUVuQixHQUFHLEVBQUUzQixFQUFFO0lBQzlCK0IsY0FBY2UsUUFBUW5CLEtBQUszQjtJQUMzQjhDLE9BQU9wRSxPQUFPLENBQUNpRDtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCB7IEVNUFRZX0JVRkZFUiwga1dlYlNvY2tldCwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XHJcblxyXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcclxuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuY29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xyXG5sZXQgcmFuZG9tUG9vbDtcclxubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcclxuXHJcbmNvbnN0IERFRkFVTFQgPSAwO1xyXG5jb25zdCBERUZMQVRJTkcgPSAxO1xyXG5jb25zdCBHRVRfQkxPQl9EQVRBID0gMjtcclxuXHJcbi8qKlxyXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFNlbmRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcclxuICAgKiAgICAga2V5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcclxuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcclxuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xyXG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcclxuXHJcbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XHJcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xyXG4gICAgdGhpcy5vbmVycm9yID0gTk9PUDtcclxuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIEZJTiBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gICAqICAgICBtYXNraW5nIGtleVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xyXG4gICAqICAgICBrZXlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcclxuICAgKiAgICAgbW9kaWZpZWRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIFJTVjEgYml0XHJcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgbGV0IG1hc2s7XHJcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcclxuICAgIGxldCBvZmZzZXQgPSAyO1xyXG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xyXG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcclxuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xyXG4gICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxyXG4gICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XHJcbiAgICAgICAgICByYW5kb21Qb29sUG9pbnRlciA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXNrWzBdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzNdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XHJcbiAgICAgIG9mZnNldCA9IDY7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGFMZW5ndGg7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXHJcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxyXG4gICAgICApIHtcclxuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xyXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XHJcblxyXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcclxuICAgICAgb2Zmc2V0ICs9IDg7XHJcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcclxuICAgICAgb2Zmc2V0ICs9IDI7XHJcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XHJcblxyXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcclxuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xyXG5cclxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XHJcblxyXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xyXG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcclxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XHJcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XHJcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xyXG5cclxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xyXG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcclxuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XHJcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xyXG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcclxuXHJcbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcclxuXHJcbiAgICBpZiAobWVyZ2UpIHtcclxuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xyXG4gICAgfVxyXG5cclxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcclxuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxyXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XHJcbiAgICBsZXQgYnVmO1xyXG5cclxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XHJcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcclxuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcclxuXHJcbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XHJcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcclxuICAgICAgZmluOiB0cnVlLFxyXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcclxuICAgICAgbWFzayxcclxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcclxuICAgICAgb3Bjb2RlOiAweDA4LFxyXG4gICAgICByZWFkT25seTogZmFsc2UsXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xyXG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgbGV0IGJ5dGVMZW5ndGg7XHJcbiAgICBsZXQgcmVhZE9ubHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2ssXHJcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXHJcbiAgICAgIG9wY29kZTogMHgwOSxcclxuICAgICAgcmVhZE9ubHksXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgbGV0IGJ5dGVMZW5ndGg7XHJcbiAgICBsZXQgcmVhZE9ubHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2ssXHJcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXHJcbiAgICAgIG9wY29kZTogMHgwYSxcclxuICAgICAgcmVhZE9ubHksXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcclxuICAgKiAgICAgb3IgdGV4dFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xyXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxyXG4gICAqICAgICBsYXN0IG9uZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XHJcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XHJcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcclxuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcclxuXHJcbiAgICBsZXQgYnl0ZUxlbmd0aDtcclxuICAgIGxldCByZWFkT25seTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcclxuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xyXG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XHJcbiAgICAgIGlmIChcclxuICAgICAgICByc3YxICYmXHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcclxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXHJcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXHJcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xyXG4gICAgICAgIF1cclxuICAgICAgKSB7XHJcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByc3YxID0gZmFsc2U7XHJcbiAgICAgIG9wY29kZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBvcHRzID0ge1xyXG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxyXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxyXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcclxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxyXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxyXG4gICAgICBvcGNvZGUsXHJcbiAgICAgIHJlYWRPbmx5LFxyXG4gICAgICByc3YxXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBUaGUgYmxvYlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcclxuICAgKiAgICAgdGhlIGRhdGFcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBGSU4gYml0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcclxuICAgKiAgICAgbWFza2luZyBrZXlcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcclxuICAgKiAgICAga2V5XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXHJcbiAgICogICAgIG1vZGlmaWVkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBSU1YxIGJpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcclxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcclxuXHJcbiAgICBibG9iXHJcbiAgICAgIC5hcnJheUJ1ZmZlcigpXHJcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgZXJyb3JzXHJcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cclxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRvQnVmZmVyKGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xyXG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XHJcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGBvbkVycm9yYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayBmb3IgdGhlIHNhbWUgcmVhc29uIHRoYXRcclxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRXJyb3IsIHRoaXMsIGVyciwgY2IpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgRklOIGJpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXHJcbiAgICogICAgIG1hc2tpbmcga2V5XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xyXG4gICAqICAgICBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXHJcbiAgICogICAgIGtleVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxyXG4gICAqICAgICBtb2RpZmllZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgUlNWMSBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcclxuICAgIGlmICghY29tcHJlc3MpIHtcclxuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XHJcblxyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcclxuICAgIHRoaXMuX3N0YXRlID0gREVGTEFUSU5HO1xyXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcclxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcclxuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgICB0aGlzLmRlcXVldWUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGVxdWV1ZSgpIHtcclxuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcclxuXHJcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcclxuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBlbnF1ZXVlKHBhcmFtcykge1xyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xyXG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBmcmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7KEJ1ZmZlciB8IFN0cmluZylbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xyXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XHJcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcclxuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcclxuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIHF1ZXVlZCBjYWxsYmFja3Mgd2l0aCBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcclxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcclxuICBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYik7XHJcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcclxufVxyXG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsInJhbmRvbUZpbGxTeW5jIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFTVBUWV9CVUZGRVIiLCJrV2ViU29ja2V0IiwiTk9PUCIsImlzQmxvYiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJSQU5ET01fUE9PTF9TSVpFIiwicmFuZG9tUG9vbCIsInJhbmRvbVBvb2xQb2ludGVyIiwiREVGQVVMVCIsIkRFRkxBVElORyIsIkdFVF9CTE9CX0RBVEEiLCJTZW5kZXIiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJnZW5lcmF0ZU1hc2siLCJfZXh0ZW5zaW9ucyIsIl9nZW5lcmF0ZU1hc2siLCJfbWFza0J1ZmZlciIsIl9zb2NrZXQiLCJfZmlyc3RGcmFnbWVudCIsIl9jb21wcmVzcyIsIl9idWZmZXJlZEJ5dGVzIiwiX3F1ZXVlIiwiX3N0YXRlIiwib25lcnJvciIsInVuZGVmaW5lZCIsImZyYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJtZXJnZSIsIm9mZnNldCIsInNraXBNYXNraW5nIiwiZGF0YUxlbmd0aCIsImZyb20iLCJsZW5ndGgiLCJyZWFkT25seSIsInBheWxvYWRMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsIlR5cGVFcnJvciIsImJ5dGVMZW5ndGgiLCJSYW5nZUVycm9yIiwid3JpdGUiLCJzZXQiLCJlbnF1ZXVlIiwiZGlzcGF0Y2giLCJzZW5kRnJhbWUiLCJwaW5nIiwic2l6ZSIsImdldEJsb2JEYXRhIiwicG9uZyIsInNlbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImV4dGVuc2lvbk5hbWUiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBhcmFtcyIsIl9pc1NlcnZlciIsIl90aHJlc2hvbGQiLCJvcHRzIiwiYmxvYiIsImFycmF5QnVmZmVyIiwidGhlbiIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbENhbGxiYWNrcyIsImRlcXVldWUiLCJjYXRjaCIsIm9uRXJyb3IiLCJfIiwic2hpZnQiLCJSZWZsZWN0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwiY29yayIsInVuY29yayIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZW5kZXIiLCJpIiwiY2FsbGJhY2siXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\r\n\r\n\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\n/**\r\n * Emits the `'close'` event on a stream.\r\n *\r\n * @param {Duplex} stream The stream.\r\n * @private\r\n */\r\nfunction emitClose(stream) {\r\n  stream.emit('close');\r\n}\r\n\r\n/**\r\n * The listener of the `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction duplexOnEnd() {\r\n  if (!this.destroyed && this._writableState.finished) {\r\n    this.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `'error'` event.\r\n *\r\n * @param {Error} err The error\r\n * @private\r\n */\r\nfunction duplexOnError(err) {\r\n  this.removeListener('error', duplexOnError);\r\n  this.destroy();\r\n  if (this.listenerCount('error') === 0) {\r\n    // Do not suppress the throwing behavior.\r\n    this.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Wraps a `WebSocket` in a duplex stream.\r\n *\r\n * @param {WebSocket} ws The `WebSocket` to wrap\r\n * @param {Object} [options] The options for the `Duplex` constructor\r\n * @return {Duplex} The duplex stream\r\n * @public\r\n */\r\nfunction createWebSocketStream(ws, options) {\r\n  let terminateOnDestroy = true;\r\n\r\n  const duplex = new Duplex({\r\n    ...options,\r\n    autoDestroy: false,\r\n    emitClose: false,\r\n    objectMode: false,\r\n    writableObjectMode: false\r\n  });\r\n\r\n  ws.on('message', function message(msg, isBinary) {\r\n    const data =\r\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\r\n\r\n    if (!duplex.push(data)) ws.pause();\r\n  });\r\n\r\n  ws.once('error', function error(err) {\r\n    if (duplex.destroyed) return;\r\n\r\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\r\n    //\r\n    // - If the `'error'` event is emitted before the `'open'` event, then\r\n    //   `ws.terminate()` is a noop as no socket is assigned.\r\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\r\n    //   event of the `Receiver` object. The listener already closes the\r\n    //   connection by calling `ws.close()`. This allows a close frame to be\r\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\r\n    //   then the close frame might not be sent.\r\n    terminateOnDestroy = false;\r\n    duplex.destroy(err);\r\n  });\r\n\r\n  ws.once('close', function close() {\r\n    if (duplex.destroyed) return;\r\n\r\n    duplex.push(null);\r\n  });\r\n\r\n  duplex._destroy = function (err, callback) {\r\n    if (ws.readyState === ws.CLOSED) {\r\n      callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n      return;\r\n    }\r\n\r\n    let called = false;\r\n\r\n    ws.once('error', function error(err) {\r\n      called = true;\r\n      callback(err);\r\n    });\r\n\r\n    ws.once('close', function close() {\r\n      if (!called) callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n    });\r\n\r\n    if (terminateOnDestroy) ws.terminate();\r\n  };\r\n\r\n  duplex._final = function (callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._final(callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    // If the value of the `_socket` property is `null` it means that `ws` is a\r\n    // client websocket and the handshake failed. In fact, when this happens, a\r\n    // socket is never assigned to the websocket. Wait for the `'error'` event\r\n    // that will be emitted by the websocket.\r\n    if (ws._socket === null) return;\r\n\r\n    if (ws._socket._writableState.finished) {\r\n      callback();\r\n      if (duplex._readableState.endEmitted) duplex.destroy();\r\n    } else {\r\n      ws._socket.once('finish', function finish() {\r\n        // `duplex` is not destroyed here because the `'end'` event will be\r\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\r\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\r\n        callback();\r\n      });\r\n      ws.close();\r\n    }\r\n  };\r\n\r\n  duplex._read = function () {\r\n    if (ws.isPaused) ws.resume();\r\n  };\r\n\r\n  duplex._write = function (chunk, encoding, callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._write(chunk, encoding, callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    ws.send(chunk, callback);\r\n  };\r\n\r\n  duplex.on('end', duplexOnEnd);\r\n  duplex.on('error', duplexOnError);\r\n  return duplex;\r\n}\r\n\r\nmodule.exports = createWebSocketStream;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msb0NBQW9DO0FBQzdEO0FBQ2I7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBYTtBQUN2QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXldlYlNvY2tldCRcIiB9XSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcblxyXG4vKipcclxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cclxuICpcclxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xyXG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XHJcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XHJcbiAgICB0aGlzLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xyXG4gIHRoaXMuZGVzdHJveSgpO1xyXG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcclxuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXHJcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxyXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xyXG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xyXG5cclxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXHJcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxyXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXHJcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXHJcbiAgfSk7XHJcblxyXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XHJcbiAgICBjb25zdCBkYXRhID1cclxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XHJcblxyXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcclxuICB9KTtcclxuXHJcbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcclxuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XHJcblxyXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXHJcbiAgICAvL1xyXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxyXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXHJcbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcclxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXHJcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcclxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcclxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXHJcbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcclxuICAgIGR1cGxleC5kZXN0cm95KGVycik7XHJcbiAgfSk7XHJcblxyXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xyXG5cclxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xyXG4gICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuXHJcbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XHJcbiAgfTtcclxuXHJcbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XHJcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXHJcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcclxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XHJcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxyXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXHJcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXHJcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9KTtcclxuICAgICAgd3MuY2xvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xyXG4gIH07XHJcblxyXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XHJcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XHJcbiAgfTtcclxuXHJcbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XHJcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xyXG4gIHJldHVybiBkdXBsZXg7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Set} The subprotocol names\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const protocols = new Set();\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (i; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n\r\n    if (end === -1 && tokenChars[code] === 1) {\r\n      if (start === -1) start = i;\r\n    } else if (\r\n      i !== 0 &&\r\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n    ) {\r\n      if (end === -1 && start !== -1) end = i;\r\n    } else if (code === 0x2c /* ',' */) {\r\n      if (start === -1) {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n\r\n      if (end === -1) end = i;\r\n\r\n      const protocol = header.slice(start, end);\r\n\r\n      if (protocols.has(protocol)) {\r\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n      }\r\n\r\n      protocols.add(protocol);\r\n      start = end = -1;\r\n    } else {\r\n      throw new SyntaxError(`Unexpected character at index ${i}`);\r\n    }\r\n  }\r\n\r\n  if (start === -1 || end !== -1) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  const protocol = header.slice(start, i);\r\n\r\n  if (protocols.has(protocol)) {\r\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n  }\r\n\r\n  protocols.add(protocol);\r\n  return protocols;\r\n}\r\n\r\nmodule.exports = { parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxzdWJwcm90b2NvbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXHJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xyXG4gIGNvbnN0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcclxuICBsZXQgc3RhcnQgPSAtMTtcclxuICBsZXQgZW5kID0gLTE7XHJcbiAgbGV0IGkgPSAwO1xyXG5cclxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGkgIT09IDAgJiZcclxuICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXHJcbiAgICApIHtcclxuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xyXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xyXG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG5cclxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcclxuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XHJcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XHJcblxyXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcclxuICB9XHJcblxyXG4gIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xyXG4gIHJldHVybiBwcm90b2NvbHM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\r\n\r\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\n\r\n//\r\n// Allowed token characters:\r\n//\r\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\r\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\r\n//\r\n// tokenChars[32] === 0 // ' '\r\n// tokenChars[33] === 1 // '!'\r\n// tokenChars[34] === 0 // '\"'\r\n// ...\r\n//\r\n// prettier-ignore\r\nconst tokenChars = [\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\r\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\r\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\r\n];\r\n\r\n/**\r\n * Checks if a status code is allowed in a close frame.\r\n *\r\n * @param {Number} code The status code\r\n * @return {Boolean} `true` if the status code is valid, else `false`\r\n * @public\r\n */\r\nfunction isValidStatusCode(code) {\r\n  return (\r\n    (code >= 1000 &&\r\n      code <= 1014 &&\r\n      code !== 1004 &&\r\n      code !== 1005 &&\r\n      code !== 1006) ||\r\n    (code >= 3000 && code <= 4999)\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if a given buffer contains only correct UTF-8.\r\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\r\n * Markus Kuhn.\r\n *\r\n * @param {Buffer} buf The buffer to check\r\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\r\n * @public\r\n */\r\nfunction _isValidUTF8(buf) {\r\n  const len = buf.length;\r\n  let i = 0;\r\n\r\n  while (i < len) {\r\n    if ((buf[i] & 0x80) === 0) {\r\n      // 0xxxxxxx\r\n      i++;\r\n    } else if ((buf[i] & 0xe0) === 0xc0) {\r\n      // 110xxxxx 10xxxxxx\r\n      if (\r\n        i + 1 === len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i] & 0xfe) === 0xc0 // Overlong\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 2;\r\n    } else if ((buf[i] & 0xf0) === 0xe0) {\r\n      // 1110xxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 2 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\r\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 3;\r\n    } else if ((buf[i] & 0xf8) === 0xf0) {\r\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 3 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i + 3] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\r\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\r\n        buf[i] > 0xf4 // > U+10FFFF\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 4;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines whether a value is a `Blob`.\r\n *\r\n * @param {*} value The value to be tested\r\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\r\n * @private\r\n */\r\nfunction isBlob(value) {\r\n  return (\r\n    hasBlob &&\r\n    typeof value === 'object' &&\r\n    typeof value.arrayBuffer === 'function' &&\r\n    typeof value.type === 'string' &&\r\n    typeof value.stream === 'function' &&\r\n    (value[Symbol.toStringTag] === 'Blob' ||\r\n      value[Symbol.toStringTag] === 'File')\r\n  );\r\n}\r\n\r\nmodule.exports = {\r\n  isBlob,\r\n  isValidStatusCode,\r\n  isValidUTF8: _isValidUTF8,\r\n  tokenChars\r\n};\r\n\r\nif (isUtf8) {\r\n  module.exports.isValidUTF8 = function (buf) {\r\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\r\n  };\r\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\r\n  try {\r\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\r\n\r\n    module.exports.isValidUTF8 = function (buf) {\r\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMEJBQTBCO0FBQzVCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyw2QkFBZ0I7QUFDaEQ7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcdmFsaWRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XHJcblxyXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG4vL1xyXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XHJcbi8vXHJcbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXHJcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcclxuLy9cclxuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXHJcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xyXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXHJcbi8vIC4uLlxyXG4vL1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgdG9rZW5DaGFycyA9IFtcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXHJcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcclxuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XHJcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXHJcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICAoY29kZSA+PSAxMDAwICYmXHJcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxyXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXHJcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcclxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcclxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxyXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxyXG4gKiBNYXJrdXMgS3Vobi5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XHJcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcclxuICBsZXQgaSA9IDA7XHJcblxyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XHJcbiAgICAgIC8vIDB4eHh4eHh4XHJcbiAgICAgIGkrKztcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XHJcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGkgKz0gMjtcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XHJcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcclxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcclxuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGkgKz0gMztcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XHJcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcclxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcclxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXHJcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcclxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpICs9IDQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGhhc0Jsb2IgJiZcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcclxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXHJcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Jsb2InIHx8XHJcbiAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJylcclxuICApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc0Jsb2IsXHJcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXHJcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcclxuICB0b2tlbkNoYXJzXHJcbn07XHJcblxyXG5pZiAoaXNVdGY4KSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XHJcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcclxuICB9O1xyXG59IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xyXG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGOChidWYpO1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/ws/lib/subprotocol.js\");\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ws/lib/websocket.js\");\r\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\r\n\r\nconst RUNNING = 0;\r\nconst CLOSING = 1;\r\nconst CLOSED = 2;\r\n\r\n/**\r\n * Class representing a WebSocket server.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n   *     automatically send a pong in response to a ping\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\r\n  constructor(options, callback) {\r\n    super();\r\n\r\n    options = {\r\n      allowSynchronousEvents: true,\r\n      autoPong: true,\r\n      maxPayload: 100 * 1024 * 1024,\r\n      skipUTF8Validation: false,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null, // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null,\r\n      WebSocket,\r\n      ...options\r\n    };\r\n\r\n    if (\r\n      (options.port == null && !options.server && !options.noServer) ||\r\n      (options.port != null && (options.server || options.noServer)) ||\r\n      (options.server && options.noServer)\r\n    ) {\r\n      throw new TypeError(\r\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\r\n          'must be specified'\r\n      );\r\n    }\r\n\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n\r\n        res.writeHead(426, {\r\n          'Content-Length': body.length,\r\n          'Content-Type': 'text/plain'\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(\r\n        options.port,\r\n        options.host,\r\n        options.backlog,\r\n        callback\r\n      );\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n\r\n    if (this._server) {\r\n      const emitConnection = this.emit.bind(this, 'connection');\r\n\r\n      this._removeListeners = addListeners(this._server, {\r\n        listening: this.emit.bind(this, 'listening'),\r\n        error: this.emit.bind(this, 'error'),\r\n        upgrade: (req, socket, head) => {\r\n          this.handleUpgrade(req, socket, head, emitConnection);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\r\n    if (options.clientTracking) {\r\n      this.clients = new Set();\r\n      this._shouldEmitClose = false;\r\n    }\r\n\r\n    this.options = options;\r\n    this._state = RUNNING;\r\n  }\r\n\r\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\r\n  address() {\r\n    if (this.options.noServer) {\r\n      throw new Error('The server is operating in \"noServer\" mode');\r\n    }\r\n\r\n    if (!this._server) return null;\r\n    return this._server.address();\r\n  }\r\n\r\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\r\n  close(cb) {\r\n    if (this._state === CLOSED) {\r\n      if (cb) {\r\n        this.once('close', () => {\r\n          cb(new Error('The server is not running'));\r\n        });\r\n      }\r\n\r\n      process.nextTick(emitClose, this);\r\n      return;\r\n    }\r\n\r\n    if (cb) this.once('close', cb);\r\n\r\n    if (this._state === CLOSING) return;\r\n    this._state = CLOSING;\r\n\r\n    if (this.options.noServer || this.options.server) {\r\n      if (this._server) {\r\n        this._removeListeners();\r\n        this._removeListeners = this._server = null;\r\n      }\r\n\r\n      if (this.clients) {\r\n        if (!this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        } else {\r\n          this._shouldEmitClose = true;\r\n        }\r\n      } else {\r\n        process.nextTick(emitClose, this);\r\n      }\r\n    } else {\r\n      const server = this._server;\r\n\r\n      this._removeListeners();\r\n      this._removeListeners = this._server = null;\r\n\r\n      //\r\n      // The HTTP/S server was created internally. Close it, and rely on its\r\n      // `'close'` event.\r\n      //\r\n      server.close(() => {\r\n        emitClose(this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle(req) {\r\n    if (this.options.path) {\r\n      const index = req.url.indexOf('?');\r\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\r\n\r\n      if (pathname !== this.options.path) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade(req, socket, head, cb) {\r\n    socket.on('error', socketOnError);\r\n\r\n    const key = req.headers['sec-websocket-key'];\r\n    const upgrade = req.headers.upgrade;\r\n    const version = +req.headers['sec-websocket-version'];\r\n\r\n    if (req.method !== 'GET') {\r\n      const message = 'Invalid HTTP method';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\r\n      return;\r\n    }\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      const message = 'Invalid Upgrade header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (key === undefined || !keyRegex.test(key)) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (version !== 8 && version !== 13) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (!this.shouldHandle(req)) {\r\n      abortHandshake(socket, 400);\r\n      return;\r\n    }\r\n\r\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\r\n    let protocols = new Set();\r\n\r\n    if (secWebSocketProtocol !== undefined) {\r\n      try {\r\n        protocols = subprotocol.parse(secWebSocketProtocol);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Protocol header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\r\n    const extensions = {};\r\n\r\n    if (\r\n      this.options.perMessageDeflate &&\r\n      secWebSocketExtensions !== undefined\r\n    ) {\r\n      const perMessageDeflate = new PerMessageDeflate(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n\r\n      try {\r\n        const offers = extension.parse(secWebSocketExtensions);\r\n\r\n        if (offers[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\r\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        const message =\r\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Optionally call external client verification handler.\r\n    //\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin:\r\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\r\n        secure: !!(req.socket.authorized || req.socket.encrypted),\r\n        req\r\n      };\r\n\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message, headers) => {\r\n          if (!verified) {\r\n            return abortHandshake(socket, code || 401, message, headers);\r\n          }\r\n\r\n          this.completeUpgrade(\r\n            extensions,\r\n            key,\r\n            protocols,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\r\n    }\r\n\r\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\r\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\r\n    //\r\n    // Destroy the socket if the client has already sent a FIN packet.\r\n    //\r\n    if (!socket.readable || !socket.writable) return socket.destroy();\r\n\r\n    if (socket[kWebSocket]) {\r\n      throw new Error(\r\n        'server.handleUpgrade() was called more than once with the same ' +\r\n          'socket, possibly due to a misconfiguration'\r\n      );\r\n    }\r\n\r\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    const headers = [\r\n      'HTTP/1.1 101 Switching Protocols',\r\n      'Upgrade: websocket',\r\n      'Connection: Upgrade',\r\n      `Sec-WebSocket-Accept: ${digest}`\r\n    ];\r\n\r\n    const ws = new this.options.WebSocket(null, undefined, this.options);\r\n\r\n    if (protocols.size) {\r\n      //\r\n      // Optionally call external protocol selection handler.\r\n      //\r\n      const protocol = this.options.handleProtocols\r\n        ? this.options.handleProtocols(protocols, req)\r\n        : protocols.values().next().value;\r\n\r\n      if (protocol) {\r\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n        ws._protocol = protocol;\r\n      }\r\n    }\r\n\r\n    if (extensions[PerMessageDeflate.extensionName]) {\r\n      const params = extensions[PerMessageDeflate.extensionName].params;\r\n      const value = extension.format({\r\n        [PerMessageDeflate.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n      ws._extensions = extensions;\r\n    }\r\n\r\n    //\r\n    // Allow external modification/inspection of handshake headers.\r\n    //\r\n    this.emit('headers', headers, req);\r\n\r\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\r\n    socket.removeListener('error', socketOnError);\r\n\r\n    ws.setSocket(socket, head, {\r\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\r\n      maxPayload: this.options.maxPayload,\r\n      skipUTF8Validation: this.options.skipUTF8Validation\r\n    });\r\n\r\n    if (this.clients) {\r\n      this.clients.add(ws);\r\n      ws.on('close', () => {\r\n        this.clients.delete(ws);\r\n\r\n        if (this._shouldEmitClose && !this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        }\r\n      });\r\n    }\r\n\r\n    cb(ws, req);\r\n  }\r\n}\r\n\r\nmodule.exports = WebSocketServer;\r\n\r\n/**\r\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\r\n * pairs.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @param {Object.<String, Function>} map The listeners to add\r\n * @return {Function} A function that will remove the added listeners when\r\n *     called\r\n * @private\r\n */\r\nfunction addListeners(server, map) {\r\n  for (const event of Object.keys(map)) server.on(event, map[event]);\r\n\r\n  return function removeListeners() {\r\n    for (const event of Object.keys(map)) {\r\n      server.removeListener(event, map[event]);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Emit a `'close'` event on an `EventEmitter`.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @private\r\n */\r\nfunction emitClose(server) {\r\n  server._state = CLOSED;\r\n  server.emit('close');\r\n}\r\n\r\n/**\r\n * Handle socket errors.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  this.destroy();\r\n}\r\n\r\n/**\r\n * Close the connection when preconditions are not fulfilled.\r\n *\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} [message] The HTTP response body\r\n * @param {Object} [headers] Additional HTTP response headers\r\n * @private\r\n */\r\nfunction abortHandshake(socket, code, message, headers) {\r\n  //\r\n  // The socket is writable unless the user destroyed or ended it before calling\r\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\r\n  // error. Handling this does not make much sense as the worst that can happen\r\n  // is that some of the data written by the user might be discarded due to the\r\n  // call to `socket.end()` below, which triggers an `'error'` event that in\r\n  // turn causes the socket to be destroyed.\r\n  //\r\n  message = message || http.STATUS_CODES[code];\r\n  headers = {\r\n    Connection: 'close',\r\n    'Content-Type': 'text/html',\r\n    'Content-Length': Buffer.byteLength(message),\r\n    ...headers\r\n  };\r\n\r\n  socket.once('finish', socket.destroy);\r\n\r\n  socket.end(\r\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\r\n      Object.keys(headers)\r\n        .map((h) => `${h}: ${headers[h]}`)\r\n        .join('\\r\\n') +\r\n      '\\r\\n\\r\\n' +\r\n      message\r\n  );\r\n}\r\n\r\n/**\r\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\r\n * one listener for it, otherwise call `abortHandshake()`.\r\n *\r\n * @param {WebSocketServer} server The WebSocket server\r\n * @param {http.IncomingMessage} req The request object\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} message The HTTP response body\r\n * @private\r\n */\r\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\r\n  if (server.listenerCount('wsClientError')) {\r\n    const err = new Error(message);\r\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\r\n\r\n    server.emit('wsClientError', err, socket, req);\r\n  } else {\r\n    abortHandshake(socket, code, message);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDtBQUMvRjtBQUNhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkRBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLGlFQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUNsRDtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNu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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFx3ZWJzb2NrZXQtc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleCRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xyXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcblxyXG5jb25zdCBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xyXG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xyXG5cclxuY29uc3QgUlVOTklORyA9IDA7XHJcbmNvbnN0IENMT1NJTkcgPSAxO1xyXG5jb25zdCBDTE9TRUQgPSAyO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxyXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cclxuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcclxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXHJcbiAgICogICAgIHRyYWNrIGNsaWVudHNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxyXG4gICAqICAgICBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXHJcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3J0XSBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXHJcbiAgICogICAgIHNlcnZlciB0byB1c2VcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5XZWJTb2NrZXQ9V2ViU29ja2V0XSBTcGVjaWZpZXMgdGhlIGBXZWJTb2NrZXRgXHJcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxyXG4gICAgICBhdXRvUG9uZzogdHJ1ZSxcclxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXHJcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcclxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxyXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcclxuICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxyXG4gICAgICBub1NlcnZlcjogZmFsc2UsXHJcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxyXG4gICAgICBzZXJ2ZXI6IG51bGwsXHJcbiAgICAgIGhvc3Q6IG51bGwsXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHBvcnQ6IG51bGwsXHJcbiAgICAgIFdlYlNvY2tldCxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHx8XHJcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XHJcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcclxuICAgICAgICAgICdtdXN0IGJlIHNwZWNpZmllZCdcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XHJcblxyXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XHJcbiAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aCxcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXMuZW5kKGJvZHkpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcclxuICAgICAgICBvcHRpb25zLnBvcnQsXHJcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxyXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcclxuICAgICAgICBjYWxsYmFja1xyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xyXG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc2VydmVyKSB7XHJcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcclxuXHJcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IGFkZExpc3RlbmVycyh0aGlzLl9zZXJ2ZXIsIHtcclxuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcclxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXHJcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XHJcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xyXG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXHJcbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcclxuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZHJlc3MoKSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxyXG4gICAqIHdoZW4gYWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xvc2UoY2IpIHtcclxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEKSB7XHJcbiAgICAgIGlmIChjYikge1xyXG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcnKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcclxuXHJcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcclxuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcclxuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XHJcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xyXG5cclxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXHJcbiAgICAgIC8vIGAnY2xvc2UnYCBldmVudC5cclxuICAgICAgLy9cclxuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcclxuICAgICAgICBlbWl0Q2xvc2UodGhpcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xyXG5cclxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xyXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG5cclxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xyXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcS5oZWFkZXJzLnVwZ3JhZGU7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcclxuXHJcbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcclxuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwZ3JhZGUgPT09IHVuZGVmaW5lZCB8fCB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCAha2V5UmVnZXgudGVzdChrZXkpKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSkpIHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xyXG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyJztcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcclxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxyXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcclxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcclxuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xyXG4gICAgICAgICAgZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XHJcbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxyXG4gICAgLy9cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XHJcbiAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgb3JpZ2luOlxyXG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcclxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXHJcbiAgICAgICAgcmVxXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xyXG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXHJcbiAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgcHJvdG9jb2xzLFxyXG4gICAgICAgICAgICByZXEsXHJcbiAgICAgICAgICAgIHNvY2tldCxcclxuICAgICAgICAgICAgaGVhZCxcclxuICAgICAgICAgICAgY2JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXHJcbiAgICogQHBhcmFtIHtTZXR9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xyXG4gICAgLy9cclxuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxyXG4gICAgLy9cclxuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xyXG5cclxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcclxuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3N0YXRlID4gUlVOTklORykgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNTAzKTtcclxuXHJcbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcclxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxyXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcclxuXHJcbiAgICBjb25zdCBoZWFkZXJzID0gW1xyXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxyXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcclxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxyXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcclxuICAgIF07XHJcblxyXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cclxuICAgICAgLy9cclxuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXHJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxyXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuXHJcbiAgICAgIGlmIChwcm90b2NvbCkge1xyXG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcclxuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xyXG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cclxuICAgICAgfSk7XHJcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xyXG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxyXG4gICAgLy9cclxuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XHJcblxyXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XHJcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XHJcblxyXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcclxuICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRpb25zLm1heFBheWxvYWQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xyXG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcclxuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkRW1pdENsb3NlICYmICF0aGlzLmNsaWVudHMuc2l6ZSkge1xyXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2Iod3MsIHJlcSk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcclxuXHJcbi8qKlxyXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XHJcbiAqIHBhaXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFkZGVkIGxpc3RlbmVycyB3aGVuXHJcbiAqICAgICBjYWxsZWRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xyXG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcclxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xyXG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XHJcbiAgc2VydmVyLl9zdGF0ZSA9IENMT1NFRDtcclxuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcclxuICB0aGlzLmRlc3Ryb3koKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cclxuICpcclxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xyXG4gIC8vXHJcbiAgLy8gVGhlIHNvY2tldCBpcyB3cml0YWJsZSB1bmxlc3MgdGhlIHVzZXIgZGVzdHJveWVkIG9yIGVuZGVkIGl0IGJlZm9yZSBjYWxsaW5nXHJcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXHJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cclxuICAvLyBpcyB0aGF0IHNvbWUgb2YgdGhlIGRhdGEgd3JpdHRlbiBieSB0aGUgdXNlciBtaWdodCBiZSBkaXNjYXJkZWQgZHVlIHRvIHRoZVxyXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXHJcbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXHJcbiAgLy9cclxuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcclxuICBoZWFkZXJzID0ge1xyXG4gICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcclxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcclxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxyXG4gICAgLi4uaGVhZGVyc1xyXG4gIH07XHJcblxyXG4gIHNvY2tldC5vbmNlKCdmaW5pc2gnLCBzb2NrZXQuZGVzdHJveSk7XHJcblxyXG4gIHNvY2tldC5lbmQoXHJcbiAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xyXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxyXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcclxuICAgICAgICAuam9pbignXFxyXFxuJykgK1xyXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXHJcbiAgICAgIG1lc3NhZ2VcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcclxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXHJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcclxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcclxuICBpZiAoc2VydmVyLmxpc3RlbmVyQ291bnQoJ3dzQ2xpZW50RXJyb3InKSkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xyXG5cclxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst tls = __webpack_require__(/*! tls */ \"tls\");\r\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { URL } = __webpack_require__(/*! url */ \"url\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/ws/lib/receiver.js\");\r\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/ws/lib/sender.js\");\r\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  GUID,\r\n  kForOnEventAttribute,\r\n  kListener,\r\n  kStatusCode,\r\n  kWebSocket,\r\n  NOOP\r\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ws/lib/constants.js\");\r\nconst {\r\n  EventTarget: { addEventListener, removeEventListener }\r\n} = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/ws/lib/event-target.js\");\r\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ws/lib/extension.js\");\r\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ws/lib/buffer-util.js\");\r\n\r\nconst closeTimeout = 30 * 1000;\r\nconst kAborted = Symbol('kAborted');\r\nconst protocolVersions = [8, 13];\r\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\r\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\r\n\r\n/**\r\n * Class representing a WebSocket.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocket extends EventEmitter {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\r\n  constructor(address, protocols, options) {\r\n    super();\r\n\r\n    this._binaryType = BINARY_TYPES[0];\r\n    this._closeCode = 1006;\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = EMPTY_BUFFER;\r\n    this._closeTimer = null;\r\n    this._errorEmitted = false;\r\n    this._extensions = {};\r\n    this._paused = false;\r\n    this._protocol = '';\r\n    this._readyState = WebSocket.CONNECTING;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n\r\n    if (address !== null) {\r\n      this._bufferedAmount = 0;\r\n      this._isServer = false;\r\n      this._redirects = 0;\r\n\r\n      if (protocols === undefined) {\r\n        protocols = [];\r\n      } else if (!Array.isArray(protocols)) {\r\n        if (typeof protocols === 'object' && protocols !== null) {\r\n          options = protocols;\r\n          protocols = [];\r\n        } else {\r\n          protocols = [protocols];\r\n        }\r\n      }\r\n\r\n      initAsClient(this, address, protocols, options);\r\n    } else {\r\n      this._autoPong = options.autoPong;\r\n      this._isServer = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\r\n   * instead of \"blob\".\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType() {\r\n    return this._binaryType;\r\n  }\r\n\r\n  set binaryType(type) {\r\n    if (!BINARY_TYPES.includes(type)) return;\r\n\r\n    this._binaryType = type;\r\n\r\n    //\r\n    // Allow to change `binaryType` on the fly.\r\n    //\r\n    if (this._receiver) this._receiver._binaryType = type;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount() {\r\n    if (!this._socket) return this._bufferedAmount;\r\n\r\n    return this._socket._writableState.length + this._sender._bufferedBytes;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get extensions() {\r\n    return Object.keys(this._extensions).join();\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onclose() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onerror() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onopen() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onmessage() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get protocol() {\r\n    return this._protocol;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get readyState() {\r\n    return this._readyState;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\r\n  setSocket(socket, head, options) {\r\n    const receiver = new Receiver({\r\n      allowSynchronousEvents: options.allowSynchronousEvents,\r\n      binaryType: this.binaryType,\r\n      extensions: this._extensions,\r\n      isServer: this._isServer,\r\n      maxPayload: options.maxPayload,\r\n      skipUTF8Validation: options.skipUTF8Validation\r\n    });\r\n\r\n    const sender = new Sender(socket, this._extensions, options.generateMask);\r\n\r\n    this._receiver = receiver;\r\n    this._sender = sender;\r\n    this._socket = socket;\r\n\r\n    receiver[kWebSocket] = this;\r\n    sender[kWebSocket] = this;\r\n    socket[kWebSocket] = this;\r\n\r\n    receiver.on('conclude', receiverOnConclude);\r\n    receiver.on('drain', receiverOnDrain);\r\n    receiver.on('error', receiverOnError);\r\n    receiver.on('message', receiverOnMessage);\r\n    receiver.on('ping', receiverOnPing);\r\n    receiver.on('pong', receiverOnPong);\r\n\r\n    sender.onerror = senderOnError;\r\n\r\n    //\r\n    // These methods may not be available if `socket` is just a `Duplex`.\r\n    //\r\n    if (socket.setTimeout) socket.setTimeout(0);\r\n    if (socket.setNoDelay) socket.setNoDelay();\r\n\r\n    if (head.length > 0) socket.unshift(head);\r\n\r\n    socket.on('close', socketOnClose);\r\n    socket.on('data', socketOnData);\r\n    socket.on('end', socketOnEnd);\r\n    socket.on('error', socketOnError);\r\n\r\n    this._readyState = WebSocket.OPEN;\r\n    this.emit('open');\r\n  }\r\n\r\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose() {\r\n    if (!this._socket) {\r\n      this._readyState = WebSocket.CLOSED;\r\n      this.emit('close', this._closeCode, this._closeMessage);\r\n      return;\r\n    }\r\n\r\n    if (this._extensions[PerMessageDeflate.extensionName]) {\r\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\r\n    }\r\n\r\n    this._receiver.removeAllListeners();\r\n    this._readyState = WebSocket.CLOSED;\r\n    this.emit('close', this._closeCode, this._closeMessage);\r\n  }\r\n\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\r\n  close(code, data) {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (\r\n        this._closeFrameSent &&\r\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this._readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      //\r\n      // This error is handled by the `'error'` listener on the socket. We only\r\n      // want to know if the close frame has been sent here.\r\n      //\r\n      if (err) return;\r\n\r\n      this._closeFrameSent = true;\r\n\r\n      if (\r\n        this._closeFrameReceived ||\r\n        this._receiver._writableState.errorEmitted\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n    });\r\n\r\n    setCloseTimer(this);\r\n  }\r\n\r\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\r\n  pause() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = true;\r\n    this._socket.pause();\r\n  }\r\n\r\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\r\n  ping(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\r\n  pong(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\r\n  resume() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = false;\r\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\r\n  }\r\n\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof options === 'function') {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    const opts = {\r\n      binary: typeof data !== 'string',\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true,\r\n      ...options\r\n    };\r\n\r\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n\r\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\r\n  }\r\n\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate() {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this._socket) {\r\n      this._readyState = WebSocket.CLOSING;\r\n      this._socket.destroy();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n[\r\n  'binaryType',\r\n  'bufferedAmount',\r\n  'extensions',\r\n  'isPaused',\r\n  'protocol',\r\n  'readyState',\r\n  'url'\r\n].forEach((property) => {\r\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\r\n});\r\n\r\n//\r\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\r\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\r\n//\r\n['open', 'error', 'close', 'message'].forEach((method) => {\r\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\r\n    enumerable: true,\r\n    get() {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) return listener[kListener];\r\n      }\r\n\r\n      return null;\r\n    },\r\n    set(handler) {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) {\r\n          this.removeListener(method, listener);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (typeof handler !== 'function') return;\r\n\r\n      this.addEventListener(method, handler, {\r\n        [kForOnEventAttribute]: true\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nWebSocket.prototype.addEventListener = addEventListener;\r\nWebSocket.prototype.removeEventListener = removeEventListener;\r\n\r\nmodule.exports = WebSocket;\r\n\r\n/**\r\n * Initialize a WebSocket client.\r\n *\r\n * @param {WebSocket} websocket The client to initialize\r\n * @param {(String|URL)} address The URL to which to connect\r\n * @param {Array} protocols The subprotocols\r\n * @param {Object} [options] Connection options\r\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\r\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\r\n *     times in the same tick\r\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n *     automatically send a pong in response to a ping\r\n * @param {Function} [options.finishRequest] A function which can be used to\r\n *     customize the headers of each http request before it is sent\r\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\r\n *     redirects\r\n * @param {Function} [options.generateMask] The function used to generate the\r\n *     masking key\r\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\r\n *     handshake request\r\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n *     size\r\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\r\n *     allowed\r\n * @param {String} [options.origin] Value of the `Origin` or\r\n *     `Sec-WebSocket-Origin` header\r\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\r\n *     permessage-deflate\r\n * @param {Number} [options.protocolVersion=13] Value of the\r\n *     `Sec-WebSocket-Version` header\r\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n *     not to skip UTF-8 validation for text and close messages\r\n * @private\r\n */\r\nfunction initAsClient(websocket, address, protocols, options) {\r\n  const opts = {\r\n    allowSynchronousEvents: true,\r\n    autoPong: true,\r\n    protocolVersion: protocolVersions[1],\r\n    maxPayload: 100 * 1024 * 1024,\r\n    skipUTF8Validation: false,\r\n    perMessageDeflate: true,\r\n    followRedirects: false,\r\n    maxRedirects: 10,\r\n    ...options,\r\n    socketPath: undefined,\r\n    hostname: undefined,\r\n    protocol: undefined,\r\n    timeout: undefined,\r\n    method: 'GET',\r\n    host: undefined,\r\n    path: undefined,\r\n    port: undefined\r\n  };\r\n\r\n  websocket._autoPong = opts.autoPong;\r\n\r\n  if (!protocolVersions.includes(opts.protocolVersion)) {\r\n    throw new RangeError(\r\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\r\n        `(supported versions: ${protocolVersions.join(', ')})`\r\n    );\r\n  }\r\n\r\n  let parsedUrl;\r\n\r\n  if (address instanceof URL) {\r\n    parsedUrl = address;\r\n  } else {\r\n    try {\r\n      parsedUrl = new URL(address);\r\n    } catch (e) {\r\n      throw new SyntaxError(`Invalid URL: ${address}`);\r\n    }\r\n  }\r\n\r\n  if (parsedUrl.protocol === 'http:') {\r\n    parsedUrl.protocol = 'ws:';\r\n  } else if (parsedUrl.protocol === 'https:') {\r\n    parsedUrl.protocol = 'wss:';\r\n  }\r\n\r\n  websocket._url = parsedUrl.href;\r\n\r\n  const isSecure = parsedUrl.protocol === 'wss:';\r\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\r\n  let invalidUrlMessage;\r\n\r\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\r\n    invalidUrlMessage =\r\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\r\n      '\"http:\", \"https:\", or \"ws+unix:\"';\r\n  } else if (isIpcUrl && !parsedUrl.pathname) {\r\n    invalidUrlMessage = \"The URL's pathname is empty\";\r\n  } else if (parsedUrl.hash) {\r\n    invalidUrlMessage = 'The URL contains a fragment identifier';\r\n  }\r\n\r\n  if (invalidUrlMessage) {\r\n    const err = new SyntaxError(invalidUrlMessage);\r\n\r\n    if (websocket._redirects === 0) {\r\n      throw err;\r\n    } else {\r\n      emitErrorAndClose(websocket, err);\r\n      return;\r\n    }\r\n  }\r\n\r\n  const defaultPort = isSecure ? 443 : 80;\r\n  const key = randomBytes(16).toString('base64');\r\n  const request = isSecure ? https.request : http.request;\r\n  const protocolSet = new Set();\r\n  let perMessageDeflate;\r\n\r\n  opts.createConnection =\r\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\r\n  opts.defaultPort = opts.defaultPort || defaultPort;\r\n  opts.port = parsedUrl.port || defaultPort;\r\n  opts.host = parsedUrl.hostname.startsWith('[')\r\n    ? parsedUrl.hostname.slice(1, -1)\r\n    : parsedUrl.hostname;\r\n  opts.headers = {\r\n    ...opts.headers,\r\n    'Sec-WebSocket-Version': opts.protocolVersion,\r\n    'Sec-WebSocket-Key': key,\r\n    Connection: 'Upgrade',\r\n    Upgrade: 'websocket'\r\n  };\r\n  opts.path = parsedUrl.pathname + parsedUrl.search;\r\n  opts.timeout = opts.handshakeTimeout;\r\n\r\n  if (opts.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate(\r\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\r\n      false,\r\n      opts.maxPayload\r\n    );\r\n    opts.headers['Sec-WebSocket-Extensions'] = format({\r\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (protocols.length) {\r\n    for (const protocol of protocols) {\r\n      if (\r\n        typeof protocol !== 'string' ||\r\n        !subprotocolRegex.test(protocol) ||\r\n        protocolSet.has(protocol)\r\n      ) {\r\n        throw new SyntaxError(\r\n          'An invalid or duplicated subprotocol was specified'\r\n        );\r\n      }\r\n\r\n      protocolSet.add(protocol);\r\n    }\r\n\r\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\r\n  }\r\n  if (opts.origin) {\r\n    if (opts.protocolVersion < 13) {\r\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\r\n    } else {\r\n      opts.headers.Origin = opts.origin;\r\n    }\r\n  }\r\n  if (parsedUrl.username || parsedUrl.password) {\r\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\r\n  }\r\n\r\n  if (isIpcUrl) {\r\n    const parts = opts.path.split(':');\r\n\r\n    opts.socketPath = parts[0];\r\n    opts.path = parts[1];\r\n  }\r\n\r\n  let req;\r\n\r\n  if (opts.followRedirects) {\r\n    if (websocket._redirects === 0) {\r\n      websocket._originalIpc = isIpcUrl;\r\n      websocket._originalSecure = isSecure;\r\n      websocket._originalHostOrSocketPath = isIpcUrl\r\n        ? opts.socketPath\r\n        : parsedUrl.host;\r\n\r\n      const headers = options && options.headers;\r\n\r\n      //\r\n      // Shallow copy the user provided options so that headers can be changed\r\n      // without mutating the original object.\r\n      //\r\n      options = { ...options, headers: {} };\r\n\r\n      if (headers) {\r\n        for (const [key, value] of Object.entries(headers)) {\r\n          options.headers[key.toLowerCase()] = value;\r\n        }\r\n      }\r\n    } else if (websocket.listenerCount('redirect') === 0) {\r\n      const isSameHost = isIpcUrl\r\n        ? websocket._originalIpc\r\n          ? opts.socketPath === websocket._originalHostOrSocketPath\r\n          : false\r\n        : websocket._originalIpc\r\n          ? false\r\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\r\n\r\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\r\n        //\r\n        // Match curl 7.77.0 behavior and drop the following headers. These\r\n        // headers are also dropped when following a redirect to a subdomain.\r\n        //\r\n        delete opts.headers.authorization;\r\n        delete opts.headers.cookie;\r\n\r\n        if (!isSameHost) delete opts.headers.host;\r\n\r\n        opts.auth = undefined;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\r\n    // If the `Authorization` header is set, then there is nothing to do as it\r\n    // will take precedence.\r\n    //\r\n    if (opts.auth && !options.headers.authorization) {\r\n      options.headers.authorization =\r\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\r\n    }\r\n\r\n    req = websocket._req = request(opts);\r\n\r\n    if (websocket._redirects) {\r\n      //\r\n      // Unlike what is done for the `'upgrade'` event, no early exit is\r\n      // triggered here if the user calls `websocket.close()` or\r\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\r\n      // is because the user can also call `request.destroy()` with an error\r\n      // before calling `websocket.close()` or `websocket.terminate()` and this\r\n      // would result in an error being emitted on the `request` object with no\r\n      // `'error'` event listeners attached.\r\n      //\r\n      websocket.emit('redirect', websocket.url, req);\r\n    }\r\n  } else {\r\n    req = websocket._req = request(opts);\r\n  }\r\n\r\n  if (opts.timeout) {\r\n    req.on('timeout', () => {\r\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\r\n    });\r\n  }\r\n\r\n  req.on('error', (err) => {\r\n    if (req === null || req[kAborted]) return;\r\n\r\n    req = websocket._req = null;\r\n    emitErrorAndClose(websocket, err);\r\n  });\r\n\r\n  req.on('response', (res) => {\r\n    const location = res.headers.location;\r\n    const statusCode = res.statusCode;\r\n\r\n    if (\r\n      location &&\r\n      opts.followRedirects &&\r\n      statusCode >= 300 &&\r\n      statusCode < 400\r\n    ) {\r\n      if (++websocket._redirects > opts.maxRedirects) {\r\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\r\n        return;\r\n      }\r\n\r\n      req.abort();\r\n\r\n      let addr;\r\n\r\n      try {\r\n        addr = new URL(location, address);\r\n      } catch (e) {\r\n        const err = new SyntaxError(`Invalid URL: ${location}`);\r\n        emitErrorAndClose(websocket, err);\r\n        return;\r\n      }\r\n\r\n      initAsClient(websocket, addr, protocols, options);\r\n    } else if (!websocket.emit('unexpected-response', req, res)) {\r\n      abortHandshake(\r\n        websocket,\r\n        req,\r\n        `Unexpected server response: ${res.statusCode}`\r\n      );\r\n    }\r\n  });\r\n\r\n  req.on('upgrade', (res, socket, head) => {\r\n    websocket.emit('upgrade', res);\r\n\r\n    //\r\n    // The user may have closed the connection from a listener of the\r\n    // `'upgrade'` event.\r\n    //\r\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\r\n\r\n    req = websocket._req = null;\r\n\r\n    const upgrade = res.headers.upgrade;\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\r\n      return;\r\n    }\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    if (res.headers['sec-websocket-accept'] !== digest) {\r\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\r\n      return;\r\n    }\r\n\r\n    const serverProt = res.headers['sec-websocket-protocol'];\r\n    let protError;\r\n\r\n    if (serverProt !== undefined) {\r\n      if (!protocolSet.size) {\r\n        protError = 'Server sent a subprotocol but none was requested';\r\n      } else if (!protocolSet.has(serverProt)) {\r\n        protError = 'Server sent an invalid subprotocol';\r\n      }\r\n    } else if (protocolSet.size) {\r\n      protError = 'Server sent no subprotocol';\r\n    }\r\n\r\n    if (protError) {\r\n      abortHandshake(websocket, socket, protError);\r\n      return;\r\n    }\r\n\r\n    if (serverProt) websocket._protocol = serverProt;\r\n\r\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\r\n\r\n    if (secWebSocketExtensions !== undefined) {\r\n      if (!perMessageDeflate) {\r\n        const message =\r\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\r\n          'was requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      let extensions;\r\n\r\n      try {\r\n        extensions = parse(secWebSocketExtensions);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      const extensionNames = Object.keys(extensions);\r\n\r\n      if (\r\n        extensionNames.length !== 1 ||\r\n        extensionNames[0] !== PerMessageDeflate.extensionName\r\n      ) {\r\n        const message = 'Server indicated an extension that was not requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      websocket._extensions[PerMessageDeflate.extensionName] =\r\n        perMessageDeflate;\r\n    }\r\n\r\n    websocket.setSocket(socket, head, {\r\n      allowSynchronousEvents: opts.allowSynchronousEvents,\r\n      generateMask: opts.generateMask,\r\n      maxPayload: opts.maxPayload,\r\n      skipUTF8Validation: opts.skipUTF8Validation\r\n    });\r\n  });\r\n\r\n  if (opts.finishRequest) {\r\n    opts.finishRequest(req, websocket);\r\n  } else {\r\n    req.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Emit the `'error'` and `'close'` events.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {Error} The error to emit\r\n * @private\r\n */\r\nfunction emitErrorAndClose(websocket, err) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  //\r\n  // The following assignment is practically useless and is done only for\r\n  // consistency.\r\n  //\r\n  websocket._errorEmitted = true;\r\n  websocket.emit('error', err);\r\n  websocket.emitClose();\r\n}\r\n\r\n/**\r\n * Create a `net.Socket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {net.Socket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction netConnect(options) {\r\n  options.path = options.socketPath;\r\n  return net.connect(options);\r\n}\r\n\r\n/**\r\n * Create a `tls.TLSSocket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {tls.TLSSocket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction tlsConnect(options) {\r\n  options.path = undefined;\r\n\r\n  if (!options.servername && options.servername !== '') {\r\n    options.servername = net.isIP(options.host) ? '' : options.host;\r\n  }\r\n\r\n  return tls.connect(options);\r\n}\r\n\r\n/**\r\n * Abort the handshake and emit an error.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\r\n *     abort or the socket to destroy\r\n * @param {String} message The error message\r\n * @private\r\n */\r\nfunction abortHandshake(websocket, stream, message) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  const err = new Error(message);\r\n  Error.captureStackTrace(err, abortHandshake);\r\n\r\n  if (stream.setHeader) {\r\n    stream[kAborted] = true;\r\n    stream.abort();\r\n\r\n    if (stream.socket && !stream.socket.destroyed) {\r\n      //\r\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\r\n      // called after the request completed. See\r\n      // https://github.com/websockets/ws/issues/1869.\r\n      //\r\n      stream.socket.destroy();\r\n    }\r\n\r\n    process.nextTick(emitErrorAndClose, websocket, err);\r\n  } else {\r\n    stream.destroy(err);\r\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\r\n    stream.once('close', websocket.emitClose.bind(websocket));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\r\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {*} [data] The data to send\r\n * @param {Function} [cb] Callback\r\n * @private\r\n */\r\nfunction sendAfterClose(websocket, data, cb) {\r\n  if (data) {\r\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\r\n\r\n    //\r\n    // The `_bufferedAmount` property is used only when the peer is a client and\r\n    // the opening handshake fails. Under these circumstances, in fact, the\r\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\r\n    // properties are set to `null`.\r\n    //\r\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\r\n    else websocket._bufferedAmount += length;\r\n  }\r\n\r\n  if (cb) {\r\n    const err = new Error(\r\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\r\n        `(${readyStates[websocket.readyState]})`\r\n    );\r\n    process.nextTick(cb, err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'conclude'` event.\r\n *\r\n * @param {Number} code The status code\r\n * @param {Buffer} reason The reason for closing\r\n * @private\r\n */\r\nfunction receiverOnConclude(code, reason) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._closeFrameReceived = true;\r\n  websocket._closeMessage = reason;\r\n  websocket._closeCode = code;\r\n\r\n  if (websocket._socket[kWebSocket] === undefined) return;\r\n\r\n  websocket._socket.removeListener('data', socketOnData);\r\n  process.nextTick(resume, websocket._socket);\r\n\r\n  if (code === 1005) websocket.close();\r\n  else websocket.close(code, reason);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'drain'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnDrain() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (!websocket.isPaused) websocket._socket.resume();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'error'` event.\r\n *\r\n * @param {(RangeError|Error)} err The emitted error\r\n * @private\r\n */\r\nfunction receiverOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._socket[kWebSocket] !== undefined) {\r\n    websocket._socket.removeListener('data', socketOnData);\r\n\r\n    //\r\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\r\n    // https://github.com/websockets/ws/issues/1940.\r\n    //\r\n    process.nextTick(resume, websocket._socket);\r\n\r\n    websocket.close(err[kStatusCode]);\r\n  }\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'finish'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnFinish() {\r\n  this[kWebSocket].emitClose();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'message'` event.\r\n *\r\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\r\n * @param {Boolean} isBinary Specifies whether the message is binary or not\r\n * @private\r\n */\r\nfunction receiverOnMessage(data, isBinary) {\r\n  this[kWebSocket].emit('message', data, isBinary);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'ping'` event.\r\n *\r\n * @param {Buffer} data The data included in the ping frame\r\n * @private\r\n */\r\nfunction receiverOnPing(data) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\r\n  websocket.emit('ping', data);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'pong'` event.\r\n *\r\n * @param {Buffer} data The data included in the pong frame\r\n * @private\r\n */\r\nfunction receiverOnPong(data) {\r\n  this[kWebSocket].emit('pong', data);\r\n}\r\n\r\n/**\r\n * Resume a readable stream\r\n *\r\n * @param {Readable} stream The readable stream\r\n * @private\r\n */\r\nfunction resume(stream) {\r\n  stream.resume();\r\n}\r\n\r\n/**\r\n * The `Sender` error event handler.\r\n *\r\n * @param {Error} The error\r\n * @private\r\n */\r\nfunction senderOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket.readyState === WebSocket.CLOSED) return;\r\n  if (websocket.readyState === WebSocket.OPEN) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    setCloseTimer(websocket);\r\n  }\r\n\r\n  //\r\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\r\n  // peer to finish sending queued data. There is no need to set a timer here\r\n  // because `CLOSING` means that it is already set or not needed.\r\n  //\r\n  this._socket.end();\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Set a timer to destroy the underlying raw socket of a WebSocket.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @private\r\n */\r\nfunction setCloseTimer(websocket) {\r\n  websocket._closeTimer = setTimeout(\r\n    websocket._socket.destroy.bind(websocket._socket),\r\n    closeTimeout\r\n  );\r\n}\r\n\r\n/**\r\n * The listener of the socket `'close'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnClose() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('close', socketOnClose);\r\n  this.removeListener('data', socketOnData);\r\n  this.removeListener('end', socketOnEnd);\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  let chunk;\r\n\r\n  //\r\n  // The close frame might not have been received or the `'end'` event emitted,\r\n  // for example, if the socket was destroyed due to an error. Ensure that the\r\n  // `receiver` stream is closed after writing any remaining buffered data to\r\n  // it. If the readable side of the socket is in flowing mode then there is no\r\n  // buffered data as everything has been already written and `readable.read()`\r\n  // will return `null`. If instead, the socket is paused, any possible buffered\r\n  // data will be read as a single chunk.\r\n  //\r\n  if (\r\n    !this._readableState.endEmitted &&\r\n    !websocket._closeFrameReceived &&\r\n    !websocket._receiver._writableState.errorEmitted &&\r\n    (chunk = websocket._socket.read()) !== null\r\n  ) {\r\n    websocket._receiver.write(chunk);\r\n  }\r\n\r\n  websocket._receiver.end();\r\n\r\n  this[kWebSocket] = undefined;\r\n\r\n  clearTimeout(websocket._closeTimer);\r\n\r\n  if (\r\n    websocket._receiver._writableState.finished ||\r\n    websocket._receiver._writableState.errorEmitted\r\n  ) {\r\n    websocket.emitClose();\r\n  } else {\r\n    websocket._receiver.on('error', receiverOnFinish);\r\n    websocket._receiver.on('finish', receiverOnFinish);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction socketOnData(chunk) {\r\n  if (!this[kWebSocket]._receiver.write(chunk)) {\r\n    this.pause();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnEnd() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  websocket._receiver.end();\r\n  this.end();\r\n}\r\n\r\n/**\r\n * The listener of the socket `'error'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', NOOP);\r\n\r\n  if (websocket) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    this.destroy();\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msa0VBQWtFO0FBQ3hHO0FBQ2E7QUFDYjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDcEQsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0I7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsMkRBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHVEQUFVO0FBQ2pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDNUIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQy9DLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsNENBQTRDO0FBQ3ZEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHdlYnNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXh8UmVhZGFibGUkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcclxuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xyXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcclxuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XHJcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5jb25zdCB7IER1cGxleCwgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XHJcblxyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xyXG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xyXG5jb25zdCB7IGlzQmxvYiB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XHJcblxyXG5jb25zdCB7XHJcbiAgQklOQVJZX1RZUEVTLFxyXG4gIEVNUFRZX0JVRkZFUixcclxuICBHVUlELFxyXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxyXG4gIGtMaXN0ZW5lcixcclxuICBrU3RhdHVzQ29kZSxcclxuICBrV2ViU29ja2V0LFxyXG4gIE5PT1BcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHtcclxuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cclxufSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XHJcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcclxuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xyXG5cclxuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xyXG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcclxuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XHJcbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcclxuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcclxuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XHJcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSBFTVBUWV9CVUZGRVI7XHJcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcclxuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xyXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XHJcblxyXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwO1xyXG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xyXG5cclxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHJvdG9jb2xzID0gW107XHJcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcclxuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XHJcbiAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcclxuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcclxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxyXG4gICAqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgYmluYXJ5VHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xyXG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxyXG4gICAgLy9cclxuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgZXh0ZW5zaW9ucygpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNQYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgZ2V0IG9uY2xvc2UoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIGdldCBvbmVycm9yKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBnZXQgb25vcGVuKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBnZXQgb25tZXNzYWdlKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBwcm90b2NvbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHVybCgpIHtcclxuICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXHJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXHJcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gICAqICAgICBtYXNraW5nIGtleVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XHJcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcclxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxyXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxyXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXHJcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcclxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcclxuXHJcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xyXG5cclxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcclxuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XHJcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xyXG5cclxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XHJcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xyXG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcclxuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xyXG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XHJcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcclxuXHJcbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxyXG4gICAgLy9cclxuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XHJcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XHJcblxyXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XHJcblxyXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xyXG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcclxuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xyXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG5cclxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcclxuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBlbWl0Q2xvc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xyXG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcclxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XHJcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cclxuICAgKlxyXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcclxuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cclxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XHJcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcclxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXHJcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcclxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XHJcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXHJcbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xyXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXHJcbiAgICogICAgICAgICAgICAgICstLS0rXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXHJcbiAgICogICAgIGNsb3NpbmdcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xvc2UoY29kZSwgZGF0YSkge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcclxuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcclxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XHJcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoZXJyKSByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XHJcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgYSBwaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gZGF0YTtcclxuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gbWFzaztcclxuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZCBhIHBvbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2IgPSBkYXRhO1xyXG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2IgPSBtYXNrO1xyXG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcclxuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXN1bWUoKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxyXG4gICAqICAgICB0ZXh0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcclxuICAgKiAgICAgbGFzdCBvbmVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gb3B0aW9ucztcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXHJcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcclxuICAgICAgY29tcHJlc3M6IHRydWUsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcclxuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICB0ZXJtaW5hdGUoKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xyXG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcclxuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cclxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcclxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcclxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxyXG59KTtcclxuXHJcbltcclxuICAnYmluYXJ5VHlwZScsXHJcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcclxuICAnZXh0ZW5zaW9ucycsXHJcbiAgJ2lzUGF1c2VkJyxcclxuICAncHJvdG9jb2wnLFxyXG4gICdyZWFkeVN0YXRlJyxcclxuICAndXJsJ1xyXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbn0pO1xyXG5cclxuLy9cclxuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxyXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxyXG4vL1xyXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0KCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcclxuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgc2V0KGhhbmRsZXIpIHtcclxuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XHJcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xyXG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXHJcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XHJcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXHJcbiAqICAgICB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXHJcbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5pc2hSZXF1ZXN0XSBBIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvXHJcbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xyXG4gKiAgICAgcmVkaXJlY3RzXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXHJcbiAqICAgICBtYXNraW5nIGtleVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxyXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcclxuICogICAgIHNpemVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xyXG4gKiAgICAgYWxsb3dlZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXHJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcclxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcclxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcclxuICBjb25zdCBvcHRzID0ge1xyXG4gICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcclxuICAgIGF1dG9Qb25nOiB0cnVlLFxyXG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxyXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXHJcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxyXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXHJcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxyXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXHJcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxyXG4gICAgcHJvdG9jb2w6IHVuZGVmaW5lZCxcclxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcclxuICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICBob3N0OiB1bmRlZmluZWQsXHJcbiAgICBwYXRoOiB1bmRlZmluZWQsXHJcbiAgICBwb3J0OiB1bmRlZmluZWRcclxuICB9O1xyXG5cclxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcclxuXHJcbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXHJcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcclxuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBsZXQgcGFyc2VkVXJsO1xyXG5cclxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xyXG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcclxuICB9IGVsc2Uge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xyXG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzOic7XHJcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XHJcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XHJcbiAgfVxyXG5cclxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xyXG5cclxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xyXG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xyXG4gIGxldCBpbnZhbGlkVXJsTWVzc2FnZTtcclxuXHJcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xyXG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPVxyXG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xyXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzOlwiLCBvciBcIndzK3VuaXg6XCInO1xyXG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xyXG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcclxuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcclxuICB9XHJcblxyXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcclxuXHJcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XHJcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuICBjb25zdCByZXF1ZXN0ID0gaXNTZWN1cmUgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xyXG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xyXG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcclxuXHJcbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cclxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XHJcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XHJcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XHJcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxyXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXHJcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcclxuICBvcHRzLmhlYWRlcnMgPSB7XHJcbiAgICAuLi5vcHRzLmhlYWRlcnMsXHJcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXHJcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXHJcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXHJcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xyXG4gIH07XHJcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcclxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XHJcblxyXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XHJcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcclxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxyXG4gICAgKTtcclxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xyXG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xyXG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxyXG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxyXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xyXG4gIH1cclxuICBpZiAob3B0cy5vcmlnaW4pIHtcclxuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XHJcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xyXG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzSXBjVXJsKSB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xyXG5cclxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xyXG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XHJcbiAgfVxyXG5cclxuICBsZXQgcmVxO1xyXG5cclxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcclxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xyXG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XHJcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcclxuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGggPSBpc0lwY1VybFxyXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXHJcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcclxuXHJcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcclxuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxyXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgIC8vXHJcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XHJcblxyXG4gICAgICBpZiAoaGVhZGVycykge1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XHJcbiAgICAgIGNvbnN0IGlzU2FtZUhvc3QgPSBpc0lwY1VybFxyXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xyXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXHJcbiAgICAgICAgICA6IGZhbHNlXHJcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXHJcbiAgICAgICAgICA/IGZhbHNlXHJcbiAgICAgICAgICA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcclxuXHJcbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXHJcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXHJcbiAgICAgICAgLy9cclxuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XHJcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XHJcblxyXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xyXG5cclxuICAgICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxyXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcclxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxyXG4gICAgLy9cclxuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XHJcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cclxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcclxuXHJcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVW5saWtlIHdoYXQgaXMgZG9uZSBmb3IgdGhlIGAndXBncmFkZSdgIGV2ZW50LCBubyBlYXJseSBleGl0IGlzXHJcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcclxuICAgICAgLy8gaXMgYmVjYXVzZSB0aGUgdXNlciBjYW4gYWxzbyBjYWxsIGByZXF1ZXN0LmRlc3Ryb3koKWAgd2l0aCBhbiBlcnJvclxyXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXHJcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cclxuICAgICAgLy8gYCdlcnJvcidgIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZC5cclxuICAgICAgLy9cclxuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9wdHMudGltZW91dCkge1xyXG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxW2tBYm9ydGVkXSkgcmV0dXJuO1xyXG5cclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcclxuICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcclxuICB9KTtcclxuXHJcbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XHJcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBsb2NhdGlvbiAmJlxyXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxyXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxyXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXHJcbiAgICApIHtcclxuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlcS5hYm9ydCgpO1xyXG5cclxuICAgICAgbGV0IGFkZHI7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XHJcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxyXG4gICAgICAgIHdlYnNvY2tldCxcclxuICAgICAgICByZXEsXHJcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXHJcbiAgICAvLyBgJ3VwZ3JhZGUnYCBldmVudC5cclxuICAgIC8vXHJcbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XHJcblxyXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXMuaGVhZGVycy51cGdyYWRlO1xyXG5cclxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxyXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXHJcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG5cclxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xyXG4gICAgbGV0IHByb3RFcnJvcjtcclxuXHJcbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xyXG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xyXG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcclxuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xyXG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcm90RXJyb3IpIHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcclxuXHJcbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID1cclxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcclxuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcclxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cclxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRzLmFsbG93U3luY2hyb25vdXNFdmVudHMsXHJcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcclxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcclxuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlcS5lbmQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbWl0IHRoZSBgJ2Vycm9yJ2AgYW5kIGAnY2xvc2UnYCBldmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcclxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuICAvL1xyXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXNzaWdubWVudCBpcyBwcmFjdGljYWxseSB1c2VsZXNzIGFuZCBpcyBkb25lIG9ubHkgZm9yXHJcbiAgLy8gY29uc2lzdGVuY3kuXHJcbiAgLy9cclxuICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XHJcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXHJcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcclxuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XHJcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XHJcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xyXG5cclxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XHJcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcclxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xyXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xyXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG5cclxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XHJcblxyXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XHJcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcclxuICAgIHN0cmVhbS5hYm9ydCgpO1xyXG5cclxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcclxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXHJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxyXG4gICAgICAvL1xyXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XHJcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xyXG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcclxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcclxuICBpZiAoZGF0YSkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gaXNCbG9iKGRhdGEpID8gZGF0YS5zaXplIDogdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXHJcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxyXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXHJcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxyXG4gICAgLy9cclxuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xyXG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcclxuICB9XHJcblxyXG4gIGlmIChjYikge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxyXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xyXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcclxuICAgICk7XHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XHJcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XHJcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xyXG5cclxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XHJcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcclxuXHJcbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xyXG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxyXG4gICAgLy9cclxuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XHJcblxyXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xyXG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XHJcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcclxuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XHJcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcclxuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xyXG4gIHN0cmVhbS5yZXN1bWUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNlbmRlck9uRXJyb3IoZXJyKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XHJcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XHJcbiAgICBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXHJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXHJcbiAgLy8gYmVjYXVzZSBgQ0xPU0lOR2AgbWVhbnMgdGhhdCBpdCBpcyBhbHJlYWR5IHNldCBvciBub3QgbmVlZGVkLlxyXG4gIC8vXHJcbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xyXG5cclxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XHJcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xyXG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXHJcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95LmJpbmQod2Vic29ja2V0Ll9zb2NrZXQpLFxyXG4gICAgY2xvc2VUaW1lb3V0XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnY2xvc2UnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XHJcblxyXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG5cclxuICBsZXQgY2h1bms7XHJcblxyXG4gIC8vXHJcbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcclxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXHJcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXHJcbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cclxuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxyXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxyXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxyXG4gIC8vXHJcbiAgaWYgKFxyXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxyXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXHJcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcclxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcclxuICApIHtcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xyXG4gIH1cclxuXHJcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcclxuXHJcbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XHJcblxyXG4gIGlmIChcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXHJcbiAgKSB7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2RhdGEnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XHJcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcclxuICAgIHRoaXMucGF1c2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2VuZCdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XHJcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcclxuICB0aGlzLmVuZCgpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XHJcblxyXG4gIGlmICh3ZWJzb2NrZXQpIHtcclxuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\n\r\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(ssr)/./node_modules/ws/lib/stream.js\");\r\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(ssr)/./node_modules/ws/lib/websocket-server.js\");\r\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\r\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(ssr)/./node_modules/ws/lib/sender.js\");\r\n\r\nWebSocket.WebSocket = WebSocket;\r\nWebSocket.WebSocketServer = WebSocket.Server;\r\n\r\nmodule.exports = WebSocket;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlFQUFpQjtBQUMzQztBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDJEQUFjO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLCtFQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywrREFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsMkRBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldCcpO1xyXG5cclxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xyXG5XZWJTb2NrZXQuU2VydmVyID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0LXNlcnZlcicpO1xyXG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xyXG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XHJcblxyXG5XZWJTb2NrZXQuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xyXG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\n/**\r\n * Merges an array of buffers into a new buffer.\r\n *\r\n * @param {Buffer[]} list The array of buffers to concat\r\n * @param {Number} totalLength The total length of buffers in the list\r\n * @return {Buffer} The resulting buffer\r\n * @public\r\n */\r\nfunction concat(list, totalLength) {\r\n  if (list.length === 0) return EMPTY_BUFFER;\r\n  if (list.length === 1) return list[0];\r\n\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  let offset = 0;\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    target.set(buf, offset);\r\n    offset += buf.length;\r\n  }\r\n\r\n  if (offset < totalLength) {\r\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Masks a buffer using the given mask.\r\n *\r\n * @param {Buffer} source The buffer to mask\r\n * @param {Buffer} mask The mask to use\r\n * @param {Buffer} output The buffer where to store the result\r\n * @param {Number} offset The offset at which to start writing\r\n * @param {Number} length The number of bytes to mask.\r\n * @public\r\n */\r\nfunction _mask(source, mask, output, offset, length) {\r\n  for (let i = 0; i < length; i++) {\r\n    output[offset + i] = source[i] ^ mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Unmasks a buffer using the given mask.\r\n *\r\n * @param {Buffer} buffer The buffer to unmask\r\n * @param {Buffer} mask The mask to use\r\n * @public\r\n */\r\nfunction _unmask(buffer, mask) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    buffer[i] ^= mask[i & 3];\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} buf The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n * @public\r\n */\r\nfunction toArrayBuffer(buf) {\r\n  if (buf.length === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n}\r\n\r\n/**\r\n * Converts `data` to a `Buffer`.\r\n *\r\n * @param {*} data The data to convert\r\n * @return {Buffer} The buffer\r\n * @throws {TypeError}\r\n * @public\r\n */\r\nfunction toBuffer(data) {\r\n  toBuffer.readOnly = true;\r\n\r\n  if (Buffer.isBuffer(data)) return data;\r\n\r\n  let buf;\r\n\r\n  if (data instanceof ArrayBuffer) {\r\n    buf = new FastBuffer(data);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\r\n  } else {\r\n    buf = Buffer.from(data);\r\n    toBuffer.readOnly = false;\r\n  }\r\n\r\n  return buf;\r\n}\r\n\r\nmodule.exports = {\r\n  concat,\r\n  mask: _mask,\r\n  toArrayBuffer,\r\n  toBuffer,\r\n  unmask: _unmask\r\n};\r\n\r\n/* istanbul ignore else  */\r\nif (!process.env.WS_NO_BUFFER_UTIL) {\r\n  try {\r\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"?32c4\");\r\n\r\n    module.exports.mask = function (source, mask, output, offset, length) {\r\n      if (length < 48) _mask(source, mask, output, offset, length);\r\n      else bufferUtil.mask(source, mask, output, offset, length);\r\n    };\r\n\r\n    module.exports.unmask = function (buffer, mask) {\r\n      if (buffer.length < 32) _unmask(buffer, mask);\r\n      else bufferUtil.unmask(buffer, mask);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMseUJBQVk7QUFDM0M7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGJ1ZmZlci11dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcblxyXG4vKipcclxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcclxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcclxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XHJcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcclxuXHJcbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcclxuICBsZXQgb2Zmc2V0ID0gMDtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xyXG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XHJcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcclxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcclxuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxyXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xyXG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgIHJldHVybiBidWYuYnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcclxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xyXG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcclxuXHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XHJcblxyXG4gIGxldCBidWY7XHJcblxyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XHJcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcclxuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnVmO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBjb25jYXQsXHJcbiAgbWFzazogX21hc2ssXHJcbiAgdG9BcnJheUJ1ZmZlcixcclxuICB0b0J1ZmZlcixcclxuICB1bm1hc2s6IF91bm1hc2tcclxufTtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xyXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XHJcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcclxuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

eval("\r\n\r\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\r\nconst hasBlob = typeof Blob !== 'undefined';\r\n\r\nif (hasBlob) BINARY_TYPES.push('blob');\r\n\r\nmodule.exports = {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER: Buffer.alloc(0),\r\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\r\n  hasBlob,\r\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\r\n  kListener: Symbol('kListener'),\r\n  kStatusCode: Symbol('status-code'),\r\n  kWebSocket: Symbol('websocket'),\r\n  NOOP: () => {}\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XHJcbmNvbnN0IGhhc0Jsb2IgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XHJcblxyXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIEJJTkFSWV9UWVBFUyxcclxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcclxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcclxuICBoYXNCbG9iLFxyXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcclxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXHJcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcclxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxyXG4gIE5PT1A6ICgpID0+IHt9XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst kCode = Symbol('kCode');\r\nconst kData = Symbol('kData');\r\nconst kError = Symbol('kError');\r\nconst kMessage = Symbol('kMessage');\r\nconst kReason = Symbol('kReason');\r\nconst kTarget = Symbol('kTarget');\r\nconst kType = Symbol('kType');\r\nconst kWasClean = Symbol('kWasClean');\r\n\r\n/**\r\n * Class representing an event.\r\n */\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\r\n  constructor(type) {\r\n    this[kTarget] = null;\r\n    this[kType] = type;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get target() {\r\n    return this[kTarget];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get type() {\r\n    return this[kType];\r\n  }\r\n}\r\n\r\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\r\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\r\n\r\n/**\r\n * Class representing a close event.\r\n *\r\n * @extends Event\r\n */\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kCode] = options.code === undefined ? 0 : options.code;\r\n    this[kReason] = options.reason === undefined ? '' : options.reason;\r\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get code() {\r\n    return this[kCode];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get reason() {\r\n    return this[kReason];\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get wasClean() {\r\n    return this[kWasClean];\r\n  }\r\n}\r\n\r\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\r\n\r\n/**\r\n * Class representing an error event.\r\n *\r\n * @extends Event\r\n */\r\nclass ErrorEvent extends Event {\r\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kError] = options.error === undefined ? null : options.error;\r\n    this[kMessage] = options.message === undefined ? '' : options.message;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get error() {\r\n    return this[kError];\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get message() {\r\n    return this[kMessage];\r\n  }\r\n}\r\n\r\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\r\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\r\n\r\n/**\r\n * Class representing a message event.\r\n *\r\n * @extends Event\r\n */\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n\r\n    this[kData] = options.data === undefined ? null : options.data;\r\n  }\r\n\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get data() {\r\n    return this[kData];\r\n  }\r\n}\r\n\r\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\r\n\r\n/**\r\n * This provides methods for emulating the `EventTarget` interface. It's not\r\n * meant to be used directly.\r\n *\r\n * @mixin\r\n */\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\r\n  addEventListener(type, handler, options = {}) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (\r\n        !options[kForOnEventAttribute] &&\r\n        listener[kListener] === handler &&\r\n        !listener[kForOnEventAttribute]\r\n      ) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    let wrapper;\r\n\r\n    if (type === 'message') {\r\n      wrapper = function onMessage(data, isBinary) {\r\n        const event = new MessageEvent('message', {\r\n          data: isBinary ? data : data.toString()\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'close') {\r\n      wrapper = function onClose(code, message) {\r\n        const event = new CloseEvent('close', {\r\n          code,\r\n          reason: message.toString(),\r\n          wasClean: this._closeFrameReceived && this._closeFrameSent\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'error') {\r\n      wrapper = function onError(error) {\r\n        const event = new ErrorEvent('error', {\r\n          error,\r\n          message: error.message\r\n        });\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === 'open') {\r\n      wrapper = function onOpen() {\r\n        const event = new Event('open');\r\n\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\r\n    wrapper[kListener] = handler;\r\n\r\n    if (options.once) {\r\n      this.once(type, wrapper);\r\n    } else {\r\n      this.on(type, wrapper);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener(type, handler) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\r\n        this.removeListener(type, listener);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  CloseEvent,\r\n  ErrorEvent,\r\n  Event,\r\n  EventTarget,\r\n  MessageEvent\r\n};\r\n\r\n/**\r\n * Call an event listener\r\n *\r\n * @param {(Function|Object)} listener The listener to call\r\n * @param {*} thisArg The value to use as `this`` when calling the listener\r\n * @param {Event} event The event to pass to the listener\r\n * @private\r\n */\r\nfunction callListener(listener, thisArg, event) {\r\n  if (typeof listener === 'object' && listener.handleEvent) {\r\n    listener.handleEvent.call(listener, event);\r\n  } else {\r\n    listener.call(thisArg, event);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekUseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXGV2ZW50LXRhcmdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IGtGb3JPbkV2ZW50QXR0cmlidXRlLCBrTGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcclxuY29uc3Qga0RhdGEgPSBTeW1ib2woJ2tEYXRhJyk7XHJcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XHJcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xyXG5jb25zdCBrUmVhc29uID0gU3ltYm9sKCdrUmVhc29uJyk7XHJcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcclxuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XHJcbmNvbnN0IGtXYXNDbGVhbiA9IFN5bWJvbCgna1dhc0NsZWFuJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XHJcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XHJcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcclxuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHsqfVxyXG4gICAqL1xyXG4gIGdldCB0YXJnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHR5cGUoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndHlwZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cclxuICpcclxuICogQGV4dGVuZHMgRXZlbnRcclxuICovXHJcbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xyXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxyXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxyXG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxyXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIodHlwZSk7XHJcblxyXG4gICAgdGhpc1trQ29kZV0gPSBvcHRpb25zLmNvZGUgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmNvZGU7XHJcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XHJcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBjb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba0NvZGVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgcmVhc29uKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgd2FzQ2xlYW4oKSB7XHJcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnY29kZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcclxuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxyXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xyXG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICovXHJcbiAgZ2V0IGVycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IG1lc3NhZ2UoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnbWVzc2FnZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtZXNzYWdlIGV2ZW50LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBFdmVudFxyXG4gKi9cclxuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xyXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXHJcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKHR5cGUpO1xyXG5cclxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUgeyp9XHJcbiAgICovXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgJ2RhdGEnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxyXG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAbWl4aW5cclxuICovXHJcbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcclxuICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXHJcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxyXG4gICAqICAgICB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXSAmJlxyXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcclxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCB3cmFwcGVyO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcclxuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudCgnbWVzc2FnZScsIHtcclxuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XHJcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xyXG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XHJcbiAgICAgICAgICBjb2RlLFxyXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcclxuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XHJcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XHJcbiAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xyXG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xyXG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdvcGVuJyk7XHJcblxyXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcclxuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcclxuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xyXG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XHJcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIENsb3NlRXZlbnQsXHJcbiAgRXJyb3JFdmVudCxcclxuICBFdmVudCxcclxuICBFdmVudFRhcmdldCxcclxuICBNZXNzYWdlRXZlbnRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYGAgd2hlbiBjYWxsaW5nIHRoZSBsaXN0ZW5lclxyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcclxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG4gICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbChsaXN0ZW5lciwgZXZlbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Adds an offer to the map of extension offers or a parameter to the map of\r\n * parameters.\r\n *\r\n * @param {Object} dest The map of extension offers or parameters\r\n * @param {String} name The extension or parameter name\r\n * @param {(Object|Boolean|String)} elem The extension parameters or the\r\n *     parameter value\r\n * @private\r\n */\r\nfunction push(dest, name, elem) {\r\n  if (dest[name] === undefined) dest[name] = [elem];\r\n  else dest[name].push(elem);\r\n}\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Extensions` header into an object.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Object} The parsed object\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const offers = Object.create(null);\r\n  let params = Object.create(null);\r\n  let mustUnescape = false;\r\n  let isEscaping = false;\r\n  let inQuotes = false;\r\n  let extensionName;\r\n  let paramName;\r\n  let start = -1;\r\n  let code = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (; i < header.length; i++) {\r\n    code = header.charCodeAt(i);\r\n\r\n    if (extensionName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (\r\n        i !== 0 &&\r\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n      ) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 0x2c) {\r\n          push(offers, name, params);\r\n          params = Object.create(null);\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === undefined) {\r\n      if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (code === 0x20 || code === 0x09) {\r\n        if (end === -1 && start !== -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        start = end = -1;\r\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      //\r\n      // The value of a quoted-string after unescaping must conform to the\r\n      // token ABNF, so only token characters are valid.\r\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\r\n      //\r\n      if (isEscaping) {\r\n        if (tokenChars[code] !== 1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1) start = i;\r\n        else if (!mustUnescape) mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars[code] === 1) {\r\n          if (start === -1) start = i;\r\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 0x5c /* '\\' */) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars[code] === 1) {\r\n        if (start === -1) start = i;\r\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\r\n        if (end === -1) end = i;\r\n      } else if (code === 0x3b || code === 0x2c) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n\r\n        if (end === -1) end = i;\r\n        let value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, '');\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 0x2c) {\r\n          push(offers, extensionName, params);\r\n          params = Object.create(null);\r\n          extensionName = undefined;\r\n        }\r\n\r\n        paramName = undefined;\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  if (end === -1) end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === undefined) {\r\n    push(offers, token, params);\r\n  } else {\r\n    if (paramName === undefined) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, ''));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n\r\n  return offers;\r\n}\r\n\r\n/**\r\n * Builds the `Sec-WebSocket-Extensions` header field value.\r\n *\r\n * @param {Object} extensions The map of extensions and parameters to format\r\n * @return {String} A string representing the given object\r\n * @public\r\n */\r\nfunction format(extensions) {\r\n  return Object.keys(extensions)\r\n    .map((extension) => {\r\n      let configurations = extensions[extension];\r\n      if (!Array.isArray(configurations)) configurations = [configurations];\r\n      return configurations\r\n        .map((params) => {\r\n          return [extension]\r\n            .concat(\r\n              Object.keys(params).map((k) => {\r\n                let values = params[k];\r\n                if (!Array.isArray(values)) values = [values];\r\n                return values\r\n                  .map((v) => (v === true ? k : `${k}=${v}`))\r\n                  .join('; ');\r\n              })\r\n            )\r\n            .join('; ');\r\n        })\r\n        .join(', ');\r\n    })\r\n    .join(', ');\r\n}\r\n\r\nmodule.exports = { format, parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQywrREFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxleHRlbnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIG9mZmVyIHRvIHRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBhIHBhcmFtZXRlciB0byB0aGUgbWFwIG9mXHJcbiAqIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IFRoZSBtYXAgb2YgZXh0ZW5zaW9uIG9mZmVycyBvciBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcclxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXHJcbiAqICAgICBwYXJhbWV0ZXIgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xyXG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XHJcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBpbnRvIGFuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgb2JqZWN0XHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xyXG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xyXG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XHJcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XHJcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XHJcbiAgbGV0IHBhcmFtTmFtZTtcclxuICBsZXQgc3RhcnQgPSAtMTtcclxuICBsZXQgY29kZSA9IC0xO1xyXG4gIGxldCBlbmQgPSAtMTtcclxuICBsZXQgaSA9IDA7XHJcblxyXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XHJcblxyXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIGkgIT09IDAgJiZcclxuICAgICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcclxuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xyXG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XHJcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcclxuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xyXG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcclxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cclxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xyXG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xyXG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XHJcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XHJcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcclxuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcclxuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XHJcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XHJcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcclxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcclxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xyXG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xyXG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzIHx8IGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XHJcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcclxuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XHJcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuLnJlcGxhY2UoL1xcXFwvZywgJycpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcclxuICAgIH1cclxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9mZmVycztcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XHJcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucylcclxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xyXG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcclxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl1cclxuICAgICAgICAgICAgLmNvbmNhdChcclxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IHBhcmFtc1trXTtcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApKVxyXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmpvaW4oJywgJyk7XHJcbiAgICB9KVxyXG4gICAgLmpvaW4oJywgJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

eval("\r\n\r\nconst kDone = Symbol('kDone');\r\nconst kRun = Symbol('kRun');\r\n\r\n/**\r\n * A very simple job queue with adjustable concurrency. Adapted from\r\n * https://github.com/STRML/async-limiter\r\n */\r\nclass Limiter {\r\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\r\n  constructor(concurrency) {\r\n    this[kDone] = () => {\r\n      this.pending--;\r\n      this[kRun]();\r\n    };\r\n    this.concurrency = concurrency || Infinity;\r\n    this.jobs = [];\r\n    this.pending = 0;\r\n  }\r\n\r\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\r\n  add(job) {\r\n    this.jobs.push(job);\r\n    this[kRun]();\r\n  }\r\n\r\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\r\n  [kRun]() {\r\n    if (this.pending === this.concurrency) return;\r\n\r\n    if (this.jobs.length) {\r\n      const job = this.jobs.shift();\r\n\r\n      this.pending++;\r\n      job(this[kDone]);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Limiter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxsaW1pdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xyXG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XHJcblxyXG4vKipcclxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcclxuICovXHJcbmNsYXNzIExpbWl0ZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxyXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcclxuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLnBlbmRpbmctLTtcclxuICAgICAgdGhpc1trUnVuXSgpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcclxuICAgIHRoaXMuam9icyA9IFtdO1xyXG4gICAgdGhpcy5wZW5kaW5nID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZChqb2IpIHtcclxuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XHJcbiAgICB0aGlzW2tSdW5dKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBba1J1bl0oKSB7XHJcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcclxuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XHJcblxyXG4gICAgICB0aGlzLnBlbmRpbmcrKztcclxuICAgICAgam9iKHRoaXNba0RvbmVdKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\n\r\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/./node_modules/ws/lib/limiter.js\");\r\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst kPerMessageDeflate = Symbol('permessage-deflate');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\r\n  constructor(options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold =\r\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency =\r\n        this._options.concurrencyLimit !== undefined\r\n          ? this._options.concurrencyLimit\r\n          : 10;\r\n      zlibLimiter = new Limiter(concurrency);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName() {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer() {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept(configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n\r\n    this.params = this._isServer\r\n      ? this.acceptAsServer(configurations)\r\n      : this.acceptAsClient(configurations);\r\n\r\n    return this.params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup() {\r\n    if (this._inflate) {\r\n      this._inflate.close();\r\n      this._inflate = null;\r\n    }\r\n\r\n    if (this._deflate) {\r\n      const callback = this._deflate[kCallback];\r\n\r\n      this._deflate.close();\r\n      this._deflate = null;\r\n\r\n      if (callback) {\r\n        callback(\r\n          new Error(\r\n            'The deflate stream was closed while data was being processed'\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer(offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (\r\n        (opts.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (params.server_max_window_bits &&\r\n          (opts.serverMaxWindowBits === false ||\r\n            (typeof opts.serverMaxWindowBits === 'number' &&\r\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\r\n        (typeof opts.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    if (!accepted) {\r\n      throw new Error('None of the extension offers can be accepted');\r\n    }\r\n\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === 'number') {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === 'number') {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (\r\n      accepted.client_max_window_bits === true ||\r\n      opts.clientMaxWindowBits === false\r\n    ) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient(response) {\r\n    const params = response[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (\r\n      this._options.clientMaxWindowBits === false ||\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\r\n    ) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams(configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        let value = params[key];\r\n\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        if (key === 'client_max_window_bits') {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === 'server_max_window_bits') {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (\r\n          key === 'client_no_context_takeover' ||\r\n          key === 'server_no_context_takeover'\r\n        ) {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n\r\n        params[key] = value;\r\n      });\r\n    });\r\n\r\n    return configurations;\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw({\r\n        ...this._options.zlibInflateOptions,\r\n        windowBits\r\n      });\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (this._inflate._readableState.endEmitted) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n\r\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n          this._inflate.reset();\r\n        }\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress(data, fin, callback) {\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits =\r\n        typeof this.params[key] !== 'number'\r\n          ? zlib.Z_DEFAULT_WINDOWBITS\r\n          : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw({\r\n        ...this._options.zlibDeflateOptions,\r\n        windowBits\r\n      });\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kCallback] = callback;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      if (!this._deflate) {\r\n        //\r\n        // The deflate stream was closed while data was being processed.\r\n        //\r\n        return;\r\n      }\r\n\r\n      let data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) {\r\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\r\n      }\r\n\r\n      //\r\n      // Ensure that the callback will not be called again in\r\n      // `PerMessageDeflate#cleanup()`.\r\n      //\r\n      this._deflate[kCallback] = null;\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n        this._deflate.reset();\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData(chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData(chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kPerMessageDeflate]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new RangeError('Max payload size exceeded');\r\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\r\n  this[kError][kStatusCode] = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n\r\n  //\r\n  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\r\n  // fact that in Node.js versions prior to 13.10.0, the callback for\r\n  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\r\n  // `zlib.reset()` ensures that either the callback is invoked or an error is\r\n  // emitted.\r\n  //\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError(err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kPerMessageDeflate]._inflate = null;\r\n\r\n  if (this[kError]) {\r\n    this[kCallback](this[kError]);\r\n    return;\r\n  }\r\n\r\n  err[kStatusCode] = 1007;\r\n  this[kCallback](err);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMseURBQVc7QUFDbkMsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHBlcm1lc3NhZ2UtZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xyXG5cclxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcclxuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xyXG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xyXG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xyXG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XHJcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XHJcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcclxuXHJcbi8vXHJcbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxyXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXHJcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxyXG4vL1xyXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cclxuLy9cclxubGV0IHpsaWJMaW1pdGVyO1xyXG5cclxuLyoqXHJcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcclxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXHJcbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcclxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxyXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcclxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcclxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxyXG4gICAqICAgICBkZWZsYXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cclxuICAgKiAgICAgaW5mbGF0ZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcclxuICAgKiAgICAgY2xpZW50IG1vZGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XHJcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XHJcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMuX3RocmVzaG9sZCA9XHJcbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XHJcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcclxuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XHJcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cclxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcclxuICAgICAgICAgIDogMTA7XHJcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XHJcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBvZmZlcigpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xyXG5cclxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XHJcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xyXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xyXG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcclxuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XHJcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XHJcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcclxuXHJcbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXHJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcclxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjbGVhbnVwKCkge1xyXG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcclxuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xyXG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcclxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XHJcblxyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayhcclxuICAgICAgICAgIG5ldyBFcnJvcihcclxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xyXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcclxuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXHJcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XHJcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXHJcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxyXG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFhY2NlcHRlZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcclxuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcclxuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcclxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxyXG4gICAgKSB7XHJcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2NlcHRlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcclxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XHJcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXHJcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xyXG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xyXG5cclxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcclxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcclxuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcclxuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFsdWUgPSBudW07XHJcbiAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxyXG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcclxuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xyXG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XHJcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcclxuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb21wcmVzcyBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xyXG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cclxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcclxuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xyXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xyXG5cclxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XHJcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXHJcbiAgICAgICAgd2luZG93Qml0c1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcclxuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XHJcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xyXG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcclxuXHJcbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xyXG5cclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xyXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XHJcblxyXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xyXG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXByZXNzIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xyXG5cclxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcclxuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XHJcbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXHJcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcclxuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcclxuXHJcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xyXG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxyXG4gICAgICAgIHdpbmRvd0JpdHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xyXG5cclxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xyXG5cclxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XHJcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxyXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxyXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGZpbikge1xyXG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXHJcbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxyXG4gICAgICAvL1xyXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcclxuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcclxuXHJcbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xyXG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcclxuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcclxuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcclxuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xyXG5cclxuICBpZiAoXHJcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XHJcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXHJcbiAgKSB7XHJcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XHJcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcclxuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XHJcblxyXG4gIC8vXHJcbiAgLy8gVGhlIGNob2ljZSB0byBlbXBsb3kgYHpsaWIucmVzZXQoKWAgb3ZlciBgemxpYi5jbG9zZSgpYCBpcyBkaWN0YXRlZCBieSB0aGVcclxuICAvLyBmYWN0IHRoYXQgaW4gTm9kZS5qcyB2ZXJzaW9ucyBwcmlvciB0byAxMy4xMC4wLCB0aGUgY2FsbGJhY2sgZm9yXHJcbiAgLy8gYHpsaWIuZmx1c2goKWAgaXMgbm90IGNhbGxlZCBpZiBgemxpYi5jbG9zZSgpYCBpcyB1c2VkLiBVdGlsaXppbmdcclxuICAvLyBgemxpYi5yZXNldCgpYCBlbnN1cmVzIHRoYXQgZWl0aGVyIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkIG9yIGFuIGVycm9yIGlzXHJcbiAgLy8gZW1pdHRlZC5cclxuICAvL1xyXG4gIHRoaXMucmVzZXQoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcclxuICAvL1xyXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcclxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxyXG4gIC8vXHJcbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcclxuXHJcbiAgaWYgKHRoaXNba0Vycm9yXSkge1xyXG4gICAgdGhpc1trQ2FsbGJhY2tdKHRoaXNba0Vycm9yXSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcclxuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  kStatusCode,\r\n  kWebSocket\r\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst FastBuffer = Buffer[Symbol.species];\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\nconst DEFER_EVENT = 6;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends Writable\r\n */\r\nclass Receiver extends Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    this._allowSynchronousEvents =\r\n      options.allowSynchronousEvents !== undefined\r\n        ? options.allowSynchronousEvents\r\n        : true;\r\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\r\n    this._extensions = options.extensions || {};\r\n    this._isServer = !!options.isServer;\r\n    this._maxPayload = options.maxPayload | 0;\r\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\r\n    this[kWebSocket] = undefined;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = undefined;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._errored = false;\r\n    this._loop = false;\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  _write(chunk, encoding, cb) {\r\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\r\n\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume(n) {\r\n    this._bufferedBytes -= n;\r\n\r\n    if (n === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = new FastBuffer(\r\n        buf.buffer,\r\n        buf.byteOffset + n,\r\n        buf.length - n\r\n      );\r\n\r\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\r\n    }\r\n\r\n    const dst = Buffer.allocUnsafe(n);\r\n\r\n    do {\r\n      const buf = this._buffers[0];\r\n      const offset = dst.length - n;\r\n\r\n      if (n >= buf.length) {\r\n        dst.set(this._buffers.shift(), offset);\r\n      } else {\r\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\r\n        this._buffers[0] = new FastBuffer(\r\n          buf.buffer,\r\n          buf.byteOffset + n,\r\n          buf.length - n\r\n        );\r\n      }\r\n\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop(cb) {\r\n    this._loop = true;\r\n\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          this.getInfo(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          this.getPayloadLength16(cb);\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          this.getPayloadLength64(cb);\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          this.getData(cb);\r\n          break;\r\n        case INFLATING:\r\n        case DEFER_EVENT:\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n\r\n    if (!this._errored) cb();\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getInfo(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV2 and RSV3 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_2_3'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'RSV1 must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_RSV_1'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'invalid opcode 0',\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid opcode ${this._opcode}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_OPCODE'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'FIN must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_FIN'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (compressed) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'RSV1 must be clear',\r\n          true,\r\n          1002,\r\n          'WS_ERR_UNEXPECTED_RSV_1'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        this._payloadLength > 0x7d ||\r\n        (this._opcode === 0x08 && this._payloadLength === 1)\r\n      ) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002,\r\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else {\r\n      const error = this.createError(\r\n        RangeError,\r\n        `invalid opcode ${this._opcode}`,\r\n        true,\r\n        1002,\r\n        'WS_ERR_INVALID_OPCODE'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._isServer) {\r\n      if (!this._masked) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'MASK must be set',\r\n          true,\r\n          1002,\r\n          'WS_ERR_EXPECTED_MASK'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    } else if (this._masked) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'MASK must be clear',\r\n        true,\r\n        1002,\r\n        'WS_ERR_UNEXPECTED_MASK'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength16(cb) {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getPayloadLength64(cb) {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      const error = this.createError(\r\n        RangeError,\r\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\r\n        false,\r\n        1009,\r\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\r\n      );\r\n\r\n      cb(error);\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    this.haveLength(cb);\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  haveLength(cb) {\r\n    if (this._payloadLength && this._opcode < 0x08) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        const error = this.createError(\r\n          RangeError,\r\n          'Max payload size exceeded',\r\n          false,\r\n          1009,\r\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask() {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  getData(cb) {\r\n    let data = EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n\r\n      data = this.consume(this._payloadLength);\r\n\r\n      if (\r\n        this._masked &&\r\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\r\n      ) {\r\n        unmask(data, this._mask);\r\n      }\r\n    }\r\n\r\n    if (this._opcode > 0x07) {\r\n      this.controlMessage(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (data.length) {\r\n      //\r\n      // This message is not compressed so its length is the sum of the payload\r\n      // length of all fragments.\r\n      //\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n\r\n    this.dataMessage(cb);\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress(data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) return cb(err);\r\n\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            'Max payload size exceeded',\r\n            false,\r\n            1009,\r\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._fragments.push(buf);\r\n      }\r\n\r\n      this.dataMessage(cb);\r\n      if (this._state === GET_INFO) this.startLoop(cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  dataMessage(cb) {\r\n    if (!this._fin) {\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    const messageLength = this._messageLength;\r\n    const fragments = this._fragments;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragmented = 0;\r\n    this._fragments = [];\r\n\r\n    if (this._opcode === 2) {\r\n      let data;\r\n\r\n      if (this._binaryType === 'nodebuffer') {\r\n        data = concat(fragments, messageLength);\r\n      } else if (this._binaryType === 'arraybuffer') {\r\n        data = toArrayBuffer(concat(fragments, messageLength));\r\n      } else if (this._binaryType === 'blob') {\r\n        data = new Blob(fragments);\r\n      } else {\r\n        data = fragments;\r\n      }\r\n\r\n      if (this._allowSynchronousEvents) {\r\n        this.emit('message', data, true);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', data, true);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    } else {\r\n      const buf = concat(fragments, messageLength);\r\n\r\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n        const error = this.createError(\r\n          Error,\r\n          'invalid UTF-8 sequence',\r\n          true,\r\n          1007,\r\n          'WS_ERR_INVALID_UTF8'\r\n        );\r\n\r\n        cb(error);\r\n        return;\r\n      }\r\n\r\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\r\n        this.emit('message', buf, false);\r\n        this._state = GET_INFO;\r\n      } else {\r\n        this._state = DEFER_EVENT;\r\n        setImmediate(() => {\r\n          this.emit('message', buf, false);\r\n          this._state = GET_INFO;\r\n          this.startLoop(cb);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage(data, cb) {\r\n    if (this._opcode === 0x08) {\r\n      if (data.length === 0) {\r\n        this._loop = false;\r\n        this.emit('conclude', 1005, EMPTY_BUFFER);\r\n        this.end();\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n\r\n        if (!isValidStatusCode(code)) {\r\n          const error = this.createError(\r\n            RangeError,\r\n            `invalid status code ${code}`,\r\n            true,\r\n            1002,\r\n            'WS_ERR_INVALID_CLOSE_CODE'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        const buf = new FastBuffer(\r\n          data.buffer,\r\n          data.byteOffset + 2,\r\n          data.length - 2\r\n        );\r\n\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          const error = this.createError(\r\n            Error,\r\n            'invalid UTF-8 sequence',\r\n            true,\r\n            1007,\r\n            'WS_ERR_INVALID_UTF8'\r\n          );\r\n\r\n          cb(error);\r\n          return;\r\n        }\r\n\r\n        this._loop = false;\r\n        this.emit('conclude', code, buf);\r\n        this.end();\r\n      }\r\n\r\n      this._state = GET_INFO;\r\n      return;\r\n    }\r\n\r\n    if (this._allowSynchronousEvents) {\r\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n      this._state = GET_INFO;\r\n    } else {\r\n      this._state = DEFER_EVENT;\r\n      setImmediate(() => {\r\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\r\n        this._state = GET_INFO;\r\n        this.startLoop(cb);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds an error object.\r\n   *\r\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\r\n   * @param {String} message The error message\r\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n   *     `message`\r\n   * @param {Number} statusCode The status code\r\n   * @param {String} errorCode The exposed error code\r\n   * @return {(Error|RangeError)} The error\r\n   * @private\r\n   */\r\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\r\n    this._loop = false;\r\n    this._errored = true;\r\n\r\n    const err = new ErrorCtor(\r\n      prefix ? `Invalid WebSocket frame: ${message}` : message\r\n    );\r\n\r\n    Error.captureStackTrace(err, this.createError);\r\n    err.code = errorCode;\r\n    err[kStatusCode] = statusCode;\r\n    return err;\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QixRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDakUsUUFBUSxpQ0FBaUMsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxccmVjZWl2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcblxyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IHtcclxuICBCSU5BUllfVFlQRVMsXHJcbiAgRU1QVFlfQlVGRkVSLFxyXG4gIGtTdGF0dXNDb2RlLFxyXG4gIGtXZWJTb2NrZXRcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcclxuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5cclxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XHJcblxyXG5jb25zdCBHRVRfSU5GTyA9IDA7XHJcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XHJcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XHJcbmNvbnN0IEdFVF9NQVNLID0gMztcclxuY29uc3QgR0VUX0RBVEEgPSA0O1xyXG5jb25zdCBJTkZMQVRJTkcgPSA1O1xyXG5jb25zdCBERUZFUl9FVkVOVCA9IDY7XHJcblxyXG4vKipcclxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4dGVuZHMgV3JpdGFibGVcclxuICovXHJcbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcclxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxyXG4gICAqICAgICBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxyXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxyXG4gICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXHJcbiAgICAgICAgOiB0cnVlO1xyXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XHJcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xyXG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcclxuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XHJcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xyXG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xyXG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcclxuICAgIHRoaXMuX29wY29kZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XHJcblxyXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XHJcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcclxuXHJcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcclxuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XHJcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjb25zdW1lKG4pIHtcclxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcclxuXHJcbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XHJcblxyXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xyXG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXHJcbiAgICAgICAgYnVmLmJ1ZmZlcixcclxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXHJcbiAgICAgICAgYnVmLmxlbmd0aCAtIG5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcclxuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XHJcblxyXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XHJcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxyXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcclxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcclxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xyXG4gICAgfSB3aGlsZSAobiA+IDApO1xyXG5cclxuICAgIHJldHVybiBkc3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGFydExvb3AoY2IpIHtcclxuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xyXG5cclxuICAgIGRvIHtcclxuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgR0VUX0lORk86XHJcbiAgICAgICAgICB0aGlzLmdldEluZm8oY2IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XHJcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGgxNihjYik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcclxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KGNiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgR0VUX01BU0s6XHJcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XHJcbiAgICAgICAgICB0aGlzLmdldERhdGEoY2IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XHJcbiAgICAgICAgY2FzZSBERUZFUl9FVkVOVDpcclxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldEluZm8oY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XHJcblxyXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xyXG5cclxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgICAgMTAwMixcclxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XHJcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xyXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XHJcblxyXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xyXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xyXG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAxMDAyLFxyXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCB8fFxyXG4gICAgICAgICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDIsXHJcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNiKGVycm9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xyXG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xyXG5cclxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xyXG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgMTAwMixcclxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgUmFuZ2VFcnJvcixcclxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEwMDIsXHJcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjYihlcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcclxuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XHJcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcclxuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XHJcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcclxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cclxuICAgIC8vXHJcbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIDEwMDksXHJcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgY2IoZXJyb3IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XHJcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBoYXZlTGVuZ3RoKGNiKSB7XHJcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XHJcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xyXG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXHJcbiAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgIDEwMDksXHJcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xyXG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgbWFzayBieXRlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0TWFzaygpIHtcclxuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xyXG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZ2V0RGF0YShjYikge1xyXG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcclxuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcclxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHtcclxuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcclxuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXHJcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxyXG4gICAgICAvL1xyXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xyXG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcclxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcclxuXHJcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XHJcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xyXG5cclxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXHJcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXHJcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIDEwMDksXHJcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xyXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEdFVF9JTkZPKSB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGF0YU1lc3NhZ2UoY2IpIHtcclxuICAgIGlmICghdGhpcy5fZmluKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcclxuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcclxuXHJcbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcclxuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xyXG5cclxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcclxuICAgICAgbGV0IGRhdGE7XHJcblxyXG4gICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XHJcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcclxuICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XHJcbiAgICAgICAgZGF0YSA9IG5ldyBCbG9iKGZyYWdtZW50cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XHJcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgIEVycm9yLFxyXG4gICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxyXG4gICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgIDEwMDcsXHJcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjYihlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcclxuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxyXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XHJcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XHJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgRU1QVFlfQlVGRkVSKTtcclxuICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xyXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxyXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxyXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgMTAwMixcclxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKFxyXG4gICAgICAgICAgZGF0YS5idWZmZXIsXHJcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxyXG4gICAgICAgICAgZGF0YS5sZW5ndGggLSAyXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcclxuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcclxuICAgICAgICAgICAgRXJyb3IsXHJcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcclxuICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgMTAwNyxcclxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGNiKGVycm9yKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcclxuICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcclxuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xyXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XHJcbiAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXHJcbiAgICogICAgIGBtZXNzYWdlYFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxyXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XHJcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICB0aGlzLl9lcnJvcmVkID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxyXG4gICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxyXG4gICAgKTtcclxuXHJcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY3JlYXRlRXJyb3IpO1xyXG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XHJcbiAgICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcclxuICAgIHJldHVybiBlcnI7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\r\n * HyBi Sender implementation.\r\n */ class Sender {\n    /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {Duplex} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === 'string') {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n            throw new TypeError('First argument must be a valid error code number');\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError('The message must not be greater than 123 bytes');\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === 'string') {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError('The data size must not be greater than 125 bytes');\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === 'string') {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\r\n   * Gets the contents of a blob as binary data.\r\n   *\r\n   * @param {Blob} blob The blob\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     the data\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while the blob was being read');\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error('The socket was closed while data was being compressed');\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {(Buffer | String)[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\r\n * Calls queued callbacks with an error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error to call the callbacks with\r\n * @param {Function} [cb] The first callback\r\n * @private\r\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === 'function') cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === 'function') callback(err);\n    }\n}\n/**\r\n * Handles a `Sender` error.\r\n *\r\n * @param {Sender} sender The `Sender` instance\r\n * @param {Error} err The error\r\n * @param {Function} [cb] The first pending callback\r\n * @private\r\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0UsR0FFM0Q7QUFFYixNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNuQyxNQUFNLEVBQUVDLGNBQWMsRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUUzQyxNQUFNRSxvQkFBb0JGLG1CQUFPQSxDQUFDLCtFQUFzQjtBQUN4RCxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUMsNkRBQWE7QUFDaEUsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDLCtEQUFjO0FBQzVELE1BQU0sRUFBRVEsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1YsbUJBQU9BLENBQUMsaUVBQWU7QUFFN0QsTUFBTVcsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFFdEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7O0dBT0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUM1QyxJQUFJLENBQUNDLFdBQVcsR0FBR0YsY0FBYyxDQUFDO1FBRWxDLElBQUlDLGNBQWM7WUFDaEIsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1lBQ3JCLElBQUksQ0FBQ0csV0FBVyxHQUFHZixPQUFPQyxLQUFLLENBQUM7UUFDbEM7UUFFQSxJQUFJLENBQUNlLE9BQU8sR0FBR047UUFFZixJQUFJLENBQUNPLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVq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QUFNQyxXQUFXN0IsTUFBTSxDQUFDQSxPQUFPL0IsTUFBTSxHQUFHLEVBQUU7UUFFMUMsSUFBSSxPQUFPNEQsYUFBYSxZQUFZQSxTQUFTckI7SUFDL0M7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTyxRQUFRWSxNQUFNLEVBQUVuQixHQUFHLEVBQUUzQixFQUFFO0lBQzlCK0IsY0FBY2UsUUFBUW5CLEtBQUszQjtJQUMzQjhDLE9BQU9wRSxPQUFPLENBQUNpRDtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xyXG5jb25zdCB7IEVNUFRZX0JVRkZFUiwga1dlYlNvY2tldCwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcclxuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcclxuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XHJcblxyXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcclxuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcclxuY29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xyXG5sZXQgcmFuZG9tUG9vbDtcclxubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcclxuXHJcbmNvbnN0IERFRkFVTFQgPSAwO1xyXG5jb25zdCBERUZMQVRJTkcgPSAxO1xyXG5jb25zdCBHRVRfQkxPQl9EQVRBID0gMjtcclxuXHJcbi8qKlxyXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFNlbmRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcclxuICAgKiAgICAga2V5XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcclxuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcclxuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xyXG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcclxuXHJcbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcclxuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XHJcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xyXG4gICAgdGhpcy5vbmVycm9yID0gTk9PUDtcclxuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIEZJTiBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gICAqICAgICBtYXNraW5nIGtleVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xyXG4gICAqICAgICBrZXlcclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcclxuICAgKiAgICAgbW9kaWZpZWRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXHJcbiAgICogICAgIFJTVjEgYml0XHJcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgbGV0IG1hc2s7XHJcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcclxuICAgIGxldCBvZmZzZXQgPSAyO1xyXG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xyXG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcclxuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xyXG4gICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxyXG4gICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XHJcbiAgICAgICAgICByYW5kb21Qb29sUG9pbnRlciA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXNrWzBdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgICBtYXNrWzNdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XHJcbiAgICAgIG9mZnNldCA9IDY7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGFMZW5ndGg7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXHJcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxyXG4gICAgICApIHtcclxuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xyXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xyXG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XHJcblxyXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcclxuICAgICAgb2Zmc2V0ICs9IDg7XHJcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcclxuICAgICAgb2Zmc2V0ICs9IDI7XHJcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XHJcblxyXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcclxuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xyXG5cclxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XHJcblxyXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xyXG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcclxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XHJcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XHJcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xyXG5cclxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xyXG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcclxuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XHJcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xyXG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcclxuXHJcbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcclxuXHJcbiAgICBpZiAobWVyZ2UpIHtcclxuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xyXG4gICAgfVxyXG5cclxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcclxuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxyXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XHJcbiAgICBsZXQgYnVmO1xyXG5cclxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XHJcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcclxuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcclxuXHJcbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XHJcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcclxuICAgICAgZmluOiB0cnVlLFxyXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcclxuICAgICAgbWFzayxcclxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcclxuICAgICAgb3Bjb2RlOiAweDA4LFxyXG4gICAgICByZWFkT25seTogZmFsc2UsXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xyXG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgbGV0IGJ5dGVMZW5ndGg7XHJcbiAgICBsZXQgcmVhZE9ubHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2ssXHJcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXHJcbiAgICAgIG9wY29kZTogMHgwOSxcclxuICAgICAgcmVhZE9ubHksXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgbGV0IGJ5dGVMZW5ndGg7XHJcbiAgICBsZXQgcmVhZE9ubHk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xyXG4gICAgICByZWFkT25seSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xyXG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XHJcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1hc2ssXHJcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXHJcbiAgICAgIG9wY29kZTogMHgwYSxcclxuICAgICAgcmVhZE9ubHksXHJcbiAgICAgIHJzdjE6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcclxuICAgKiAgICAgb3IgdGV4dFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xyXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxyXG4gICAqICAgICBsYXN0IG9uZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XHJcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XHJcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcclxuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcclxuXHJcbiAgICBsZXQgYnl0ZUxlbmd0aDtcclxuICAgIGxldCByZWFkT25seTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcclxuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XHJcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XHJcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcclxuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xyXG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XHJcbiAgICAgIGlmIChcclxuICAgICAgICByc3YxICYmXHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcclxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXHJcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXJcclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXHJcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xyXG4gICAgICAgIF1cclxuICAgICAgKSB7XHJcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByc3YxID0gZmFsc2U7XHJcbiAgICAgIG9wY29kZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCBvcHRzID0ge1xyXG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxyXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxyXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcclxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxyXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxyXG4gICAgICBvcGNvZGUsXHJcbiAgICAgIHJlYWRPbmx5LFxyXG4gICAgICByc3YxXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcclxuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYiBUaGUgYmxvYlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcclxuICAgKiAgICAgdGhlIGRhdGFcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBGSU4gYml0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcclxuICAgKiAgICAgbWFza2luZyBrZXlcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcclxuICAgKiAgICAga2V5XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXHJcbiAgICogICAgIG1vZGlmaWVkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxyXG4gICAqICAgICBSU1YxIGJpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcclxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcclxuXHJcbiAgICBibG9iXHJcbiAgICAgIC5hcnJheUJ1ZmZlcigpXHJcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgZXJyb3JzXHJcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cclxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRvQnVmZmVyKGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xyXG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XHJcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGBvbkVycm9yYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayBmb3IgdGhlIHNhbWUgcmVhc29uIHRoYXRcclxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG9uRXJyb3IsIHRoaXMsIGVyciwgY2IpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcclxuICAgKiAgICAgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgRklOIGJpdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXHJcbiAgICogICAgIG1hc2tpbmcga2V5XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xyXG4gICAqICAgICBgZGF0YWBcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXHJcbiAgICogICAgIGtleVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxyXG4gICAqICAgICBtb2RpZmllZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcclxuICAgKiAgICAgUlNWMSBiaXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcclxuICAgIGlmICghY29tcHJlc3MpIHtcclxuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XHJcblxyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcclxuICAgIHRoaXMuX3N0YXRlID0gREVGTEFUSU5HO1xyXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcclxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XHJcbiAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcclxuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xyXG4gICAgICB0aGlzLmRlcXVldWUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZGVxdWV1ZSgpIHtcclxuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcclxuXHJcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcclxuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBlbnF1ZXVlKHBhcmFtcykge1xyXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xyXG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZHMgYSBmcmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7KEJ1ZmZlciB8IFN0cmluZylbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xyXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XHJcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcclxuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcclxuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xyXG5cclxuLyoqXHJcbiAqIENhbGxzIHF1ZXVlZCBjYWxsYmFja3Mgd2l0aCBhbiBlcnJvci5cclxuICpcclxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcclxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcclxuICBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYik7XHJcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcclxufVxyXG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsInJhbmRvbUZpbGxTeW5jIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJFTVBUWV9CVUZGRVIiLCJrV2ViU29ja2V0IiwiTk9PUCIsImlzQmxvYiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJSQU5ET01fUE9PTF9TSVpFIiwicmFuZG9tUG9vbCIsInJhbmRvbVBvb2xQb2ludGVyIiwiREVGQVVMVCIsIkRFRkxBVElORyIsIkdFVF9CTE9CX0RBVEEiLCJTZW5kZXIiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJnZW5lcmF0ZU1hc2siLCJfZXh0ZW5zaW9ucyIsIl9nZW5lcmF0ZU1hc2siLCJfbWFza0J1ZmZlciIsIl9zb2NrZXQiLCJfZmlyc3RGcmFnbWVudCIsIl9jb21wcmVzcyIsIl9idWZmZXJlZEJ5dGVzIiwiX3F1ZXVlIiwiX3N0YXRlIiwib25lcnJvciIsInVuZGVmaW5lZCIsImZyYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJtZXJnZSIsIm9mZnNldCIsInNraXBNYXNraW5nIiwiZGF0YUxlbmd0aCIsImZyb20iLCJsZW5ndGgiLCJyZWFkT25seSIsInBheWxvYWRMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsIlR5cGVFcnJvciIsImJ5dGVMZW5ndGgiLCJSYW5nZUVycm9yIiwid3JpdGUiLCJzZXQiLCJlbnF1ZXVlIiwiZGlzcGF0Y2giLCJzZW5kRnJhbWUiLCJwaW5nIiwic2l6ZSIsImdldEJsb2JEYXRhIiwicG9uZyIsInNlbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImV4dGVuc2lvbk5hbWUiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBhcmFtcyIsIl9pc1NlcnZlciIsIl90aHJlc2hvbGQiLCJvcHRzIiwiYmxvYiIsImFycmF5QnVmZmVyIiwidGhlbiIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbENhbGxiYWNrcyIsImRlcXVldWUiLCJjYXRjaCIsIm9uRXJyb3IiLCJfIiwic2hpZnQiLCJSZWZsZWN0IiwiYXBwbHkiLCJzbGljZSIsInB1c2giLCJsaXN0IiwiY29yayIsInVuY29yayIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZW5kZXIiLCJpIiwiY2FsbGJhY2siXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\r\n\r\n\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\n\r\n/**\r\n * Emits the `'close'` event on a stream.\r\n *\r\n * @param {Duplex} stream The stream.\r\n * @private\r\n */\r\nfunction emitClose(stream) {\r\n  stream.emit('close');\r\n}\r\n\r\n/**\r\n * The listener of the `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction duplexOnEnd() {\r\n  if (!this.destroyed && this._writableState.finished) {\r\n    this.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `'error'` event.\r\n *\r\n * @param {Error} err The error\r\n * @private\r\n */\r\nfunction duplexOnError(err) {\r\n  this.removeListener('error', duplexOnError);\r\n  this.destroy();\r\n  if (this.listenerCount('error') === 0) {\r\n    // Do not suppress the throwing behavior.\r\n    this.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Wraps a `WebSocket` in a duplex stream.\r\n *\r\n * @param {WebSocket} ws The `WebSocket` to wrap\r\n * @param {Object} [options] The options for the `Duplex` constructor\r\n * @return {Duplex} The duplex stream\r\n * @public\r\n */\r\nfunction createWebSocketStream(ws, options) {\r\n  let terminateOnDestroy = true;\r\n\r\n  const duplex = new Duplex({\r\n    ...options,\r\n    autoDestroy: false,\r\n    emitClose: false,\r\n    objectMode: false,\r\n    writableObjectMode: false\r\n  });\r\n\r\n  ws.on('message', function message(msg, isBinary) {\r\n    const data =\r\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\r\n\r\n    if (!duplex.push(data)) ws.pause();\r\n  });\r\n\r\n  ws.once('error', function error(err) {\r\n    if (duplex.destroyed) return;\r\n\r\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\r\n    //\r\n    // - If the `'error'` event is emitted before the `'open'` event, then\r\n    //   `ws.terminate()` is a noop as no socket is assigned.\r\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\r\n    //   event of the `Receiver` object. The listener already closes the\r\n    //   connection by calling `ws.close()`. This allows a close frame to be\r\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\r\n    //   then the close frame might not be sent.\r\n    terminateOnDestroy = false;\r\n    duplex.destroy(err);\r\n  });\r\n\r\n  ws.once('close', function close() {\r\n    if (duplex.destroyed) return;\r\n\r\n    duplex.push(null);\r\n  });\r\n\r\n  duplex._destroy = function (err, callback) {\r\n    if (ws.readyState === ws.CLOSED) {\r\n      callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n      return;\r\n    }\r\n\r\n    let called = false;\r\n\r\n    ws.once('error', function error(err) {\r\n      called = true;\r\n      callback(err);\r\n    });\r\n\r\n    ws.once('close', function close() {\r\n      if (!called) callback(err);\r\n      process.nextTick(emitClose, duplex);\r\n    });\r\n\r\n    if (terminateOnDestroy) ws.terminate();\r\n  };\r\n\r\n  duplex._final = function (callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._final(callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    // If the value of the `_socket` property is `null` it means that `ws` is a\r\n    // client websocket and the handshake failed. In fact, when this happens, a\r\n    // socket is never assigned to the websocket. Wait for the `'error'` event\r\n    // that will be emitted by the websocket.\r\n    if (ws._socket === null) return;\r\n\r\n    if (ws._socket._writableState.finished) {\r\n      callback();\r\n      if (duplex._readableState.endEmitted) duplex.destroy();\r\n    } else {\r\n      ws._socket.once('finish', function finish() {\r\n        // `duplex` is not destroyed here because the `'end'` event will be\r\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\r\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\r\n        callback();\r\n      });\r\n      ws.close();\r\n    }\r\n  };\r\n\r\n  duplex._read = function () {\r\n    if (ws.isPaused) ws.resume();\r\n  };\r\n\r\n  duplex._write = function (chunk, encoding, callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once('open', function open() {\r\n        duplex._write(chunk, encoding, callback);\r\n      });\r\n      return;\r\n    }\r\n\r\n    ws.send(chunk, callback);\r\n  };\r\n\r\n  duplex.on('end', duplexOnEnd);\r\n  duplex.on('error', duplexOnError);\r\n  return duplex;\r\n}\r\n\r\nmodule.exports = createWebSocketStream;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msb0NBQW9DO0FBQzdEO0FBQ2I7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBYTtBQUN2QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXldlYlNvY2tldCRcIiB9XSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcblxyXG4vKipcclxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cclxuICpcclxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xyXG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XHJcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XHJcbiAgICB0aGlzLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xyXG4gIHRoaXMuZGVzdHJveSgpO1xyXG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcclxuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXHJcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxyXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xyXG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xyXG5cclxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXHJcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxyXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXHJcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXHJcbiAgfSk7XHJcblxyXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XHJcbiAgICBjb25zdCBkYXRhID1cclxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XHJcblxyXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcclxuICB9KTtcclxuXHJcbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcclxuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XHJcblxyXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXHJcbiAgICAvL1xyXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxyXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXHJcbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcclxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXHJcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcclxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcclxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXHJcbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcclxuICAgIGR1cGxleC5kZXN0cm95KGVycik7XHJcbiAgfSk7XHJcblxyXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xyXG5cclxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xyXG4gICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuXHJcbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XHJcbiAgfTtcclxuXHJcbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XHJcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXHJcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcclxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XHJcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxyXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXHJcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXHJcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9KTtcclxuICAgICAgd3MuY2xvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xyXG4gIH07XHJcblxyXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XHJcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XHJcbiAgfTtcclxuXHJcbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XHJcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xyXG4gIHJldHVybiBkdXBsZXg7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\n/**\r\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\r\n *\r\n * @param {String} header The field value of the header\r\n * @return {Set} The subprotocol names\r\n * @public\r\n */\r\nfunction parse(header) {\r\n  const protocols = new Set();\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n\r\n  for (i; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n\r\n    if (end === -1 && tokenChars[code] === 1) {\r\n      if (start === -1) start = i;\r\n    } else if (\r\n      i !== 0 &&\r\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\r\n    ) {\r\n      if (end === -1 && start !== -1) end = i;\r\n    } else if (code === 0x2c /* ',' */) {\r\n      if (start === -1) {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n\r\n      if (end === -1) end = i;\r\n\r\n      const protocol = header.slice(start, end);\r\n\r\n      if (protocols.has(protocol)) {\r\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n      }\r\n\r\n      protocols.add(protocol);\r\n      start = end = -1;\r\n    } else {\r\n      throw new SyntaxError(`Unexpected character at index ${i}`);\r\n    }\r\n  }\r\n\r\n  if (start === -1 || end !== -1) {\r\n    throw new SyntaxError('Unexpected end of input');\r\n  }\r\n\r\n  const protocol = header.slice(start, i);\r\n\r\n  if (protocols.has(protocol)) {\r\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n  }\r\n\r\n  protocols.add(protocol);\r\n  return protocols;\r\n}\r\n\r\nmodule.exports = { parse };\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFxzdWJwcm90b2NvbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXHJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xyXG4gIGNvbnN0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcclxuICBsZXQgc3RhcnQgPSAtMTtcclxuICBsZXQgZW5kID0gLTE7XHJcbiAgbGV0IGkgPSAwO1xyXG5cclxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XHJcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGkgIT09IDAgJiZcclxuICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXHJcbiAgICApIHtcclxuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xyXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xyXG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xyXG5cclxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcclxuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XHJcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XHJcblxyXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcclxuICB9XHJcblxyXG4gIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xyXG4gIHJldHVybiBwcm90b2NvbHM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\r\n\r\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\n//\r\n// Allowed token characters:\r\n//\r\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\r\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\r\n//\r\n// tokenChars[32] === 0 // ' '\r\n// tokenChars[33] === 1 // '!'\r\n// tokenChars[34] === 0 // '\"'\r\n// ...\r\n//\r\n// prettier-ignore\r\nconst tokenChars = [\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\r\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\r\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\r\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\r\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\r\n];\r\n\r\n/**\r\n * Checks if a status code is allowed in a close frame.\r\n *\r\n * @param {Number} code The status code\r\n * @return {Boolean} `true` if the status code is valid, else `false`\r\n * @public\r\n */\r\nfunction isValidStatusCode(code) {\r\n  return (\r\n    (code >= 1000 &&\r\n      code <= 1014 &&\r\n      code !== 1004 &&\r\n      code !== 1005 &&\r\n      code !== 1006) ||\r\n    (code >= 3000 && code <= 4999)\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if a given buffer contains only correct UTF-8.\r\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\r\n * Markus Kuhn.\r\n *\r\n * @param {Buffer} buf The buffer to check\r\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\r\n * @public\r\n */\r\nfunction _isValidUTF8(buf) {\r\n  const len = buf.length;\r\n  let i = 0;\r\n\r\n  while (i < len) {\r\n    if ((buf[i] & 0x80) === 0) {\r\n      // 0xxxxxxx\r\n      i++;\r\n    } else if ((buf[i] & 0xe0) === 0xc0) {\r\n      // 110xxxxx 10xxxxxx\r\n      if (\r\n        i + 1 === len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i] & 0xfe) === 0xc0 // Overlong\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 2;\r\n    } else if ((buf[i] & 0xf0) === 0xe0) {\r\n      // 1110xxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 2 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\r\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 3;\r\n    } else if ((buf[i] & 0xf8) === 0xf0) {\r\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\r\n      if (\r\n        i + 3 >= len ||\r\n        (buf[i + 1] & 0xc0) !== 0x80 ||\r\n        (buf[i + 2] & 0xc0) !== 0x80 ||\r\n        (buf[i + 3] & 0xc0) !== 0x80 ||\r\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\r\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\r\n        buf[i] > 0xf4 // > U+10FFFF\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      i += 4;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines whether a value is a `Blob`.\r\n *\r\n * @param {*} value The value to be tested\r\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\r\n * @private\r\n */\r\nfunction isBlob(value) {\r\n  return (\r\n    hasBlob &&\r\n    typeof value === 'object' &&\r\n    typeof value.arrayBuffer === 'function' &&\r\n    typeof value.type === 'string' &&\r\n    typeof value.stream === 'function' &&\r\n    (value[Symbol.toStringTag] === 'Blob' ||\r\n      value[Symbol.toStringTag] === 'File')\r\n  );\r\n}\r\n\r\nmodule.exports = {\r\n  isBlob,\r\n  isValidStatusCode,\r\n  isValidUTF8: _isValidUTF8,\r\n  tokenChars\r\n};\r\n\r\nif (isUtf8) {\r\n  module.exports.isValidUTF8 = function (buf) {\r\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\r\n  };\r\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\r\n  try {\r\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?66e9\");\r\n\r\n    module.exports.isValidUTF8 = function (buf) {\r\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\r\n    };\r\n  } catch (e) {\r\n    // Continue regardless of the error.\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQSxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMEJBQTBCO0FBQzVCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyw2QkFBZ0I7QUFDaEQ7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd3NcXGxpYlxcdmFsaWRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XHJcblxyXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG4vL1xyXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XHJcbi8vXHJcbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXHJcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcclxuLy9cclxuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXHJcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xyXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXHJcbi8vIC4uLlxyXG4vL1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgdG9rZW5DaGFycyA9IFtcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcclxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXHJcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcclxuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XHJcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxyXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXHJcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xyXG4gIHJldHVybiAoXHJcbiAgICAoY29kZSA+PSAxMDAwICYmXHJcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxyXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXHJcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcclxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcclxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxyXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxyXG4gKiBNYXJrdXMgS3Vobi5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XHJcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcclxuICBsZXQgaSA9IDA7XHJcblxyXG4gIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XHJcbiAgICAgIC8vIDB4eHh4eHh4XHJcbiAgICAgIGkrKztcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XHJcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGkgKz0gMjtcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XHJcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcclxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcclxuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGkgKz0gMztcclxuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XHJcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XHJcbiAgICAgIGlmIChcclxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcclxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XHJcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxyXG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcclxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXHJcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcclxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpICs9IDQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGhhc0Jsb2IgJiZcclxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcclxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXHJcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Jsb2InIHx8XHJcbiAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJylcclxuICApO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc0Jsb2IsXHJcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXHJcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcclxuICB0b2tlbkNoYXJzXHJcbn07XHJcblxyXG5pZiAoaXNVdGY4KSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XHJcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcclxuICB9O1xyXG59IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xyXG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGOChidWYpO1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIHRoZSBlcnJvci5cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/./node_modules/ws/lib/subprotocol.js\");\r\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/./node_modules/ws/lib/websocket.js\");\r\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\n\r\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\r\n\r\nconst RUNNING = 0;\r\nconst CLOSING = 1;\r\nconst CLOSED = 2;\r\n\r\n/**\r\n * Class representing a WebSocket server.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n   *     automatically send a pong in response to a ping\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\r\n  constructor(options, callback) {\r\n    super();\r\n\r\n    options = {\r\n      allowSynchronousEvents: true,\r\n      autoPong: true,\r\n      maxPayload: 100 * 1024 * 1024,\r\n      skipUTF8Validation: false,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null, // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null,\r\n      WebSocket,\r\n      ...options\r\n    };\r\n\r\n    if (\r\n      (options.port == null && !options.server && !options.noServer) ||\r\n      (options.port != null && (options.server || options.noServer)) ||\r\n      (options.server && options.noServer)\r\n    ) {\r\n      throw new TypeError(\r\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\r\n          'must be specified'\r\n      );\r\n    }\r\n\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n\r\n        res.writeHead(426, {\r\n          'Content-Length': body.length,\r\n          'Content-Type': 'text/plain'\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(\r\n        options.port,\r\n        options.host,\r\n        options.backlog,\r\n        callback\r\n      );\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n\r\n    if (this._server) {\r\n      const emitConnection = this.emit.bind(this, 'connection');\r\n\r\n      this._removeListeners = addListeners(this._server, {\r\n        listening: this.emit.bind(this, 'listening'),\r\n        error: this.emit.bind(this, 'error'),\r\n        upgrade: (req, socket, head) => {\r\n          this.handleUpgrade(req, socket, head, emitConnection);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\r\n    if (options.clientTracking) {\r\n      this.clients = new Set();\r\n      this._shouldEmitClose = false;\r\n    }\r\n\r\n    this.options = options;\r\n    this._state = RUNNING;\r\n  }\r\n\r\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\r\n  address() {\r\n    if (this.options.noServer) {\r\n      throw new Error('The server is operating in \"noServer\" mode');\r\n    }\r\n\r\n    if (!this._server) return null;\r\n    return this._server.address();\r\n  }\r\n\r\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\r\n  close(cb) {\r\n    if (this._state === CLOSED) {\r\n      if (cb) {\r\n        this.once('close', () => {\r\n          cb(new Error('The server is not running'));\r\n        });\r\n      }\r\n\r\n      process.nextTick(emitClose, this);\r\n      return;\r\n    }\r\n\r\n    if (cb) this.once('close', cb);\r\n\r\n    if (this._state === CLOSING) return;\r\n    this._state = CLOSING;\r\n\r\n    if (this.options.noServer || this.options.server) {\r\n      if (this._server) {\r\n        this._removeListeners();\r\n        this._removeListeners = this._server = null;\r\n      }\r\n\r\n      if (this.clients) {\r\n        if (!this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        } else {\r\n          this._shouldEmitClose = true;\r\n        }\r\n      } else {\r\n        process.nextTick(emitClose, this);\r\n      }\r\n    } else {\r\n      const server = this._server;\r\n\r\n      this._removeListeners();\r\n      this._removeListeners = this._server = null;\r\n\r\n      //\r\n      // The HTTP/S server was created internally. Close it, and rely on its\r\n      // `'close'` event.\r\n      //\r\n      server.close(() => {\r\n        emitClose(this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle(req) {\r\n    if (this.options.path) {\r\n      const index = req.url.indexOf('?');\r\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\r\n\r\n      if (pathname !== this.options.path) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade(req, socket, head, cb) {\r\n    socket.on('error', socketOnError);\r\n\r\n    const key = req.headers['sec-websocket-key'];\r\n    const upgrade = req.headers.upgrade;\r\n    const version = +req.headers['sec-websocket-version'];\r\n\r\n    if (req.method !== 'GET') {\r\n      const message = 'Invalid HTTP method';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\r\n      return;\r\n    }\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      const message = 'Invalid Upgrade header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (key === undefined || !keyRegex.test(key)) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (version !== 8 && version !== 13) {\r\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n\r\n    if (!this.shouldHandle(req)) {\r\n      abortHandshake(socket, 400);\r\n      return;\r\n    }\r\n\r\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\r\n    let protocols = new Set();\r\n\r\n    if (secWebSocketProtocol !== undefined) {\r\n      try {\r\n        protocols = subprotocol.parse(secWebSocketProtocol);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Protocol header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\r\n    const extensions = {};\r\n\r\n    if (\r\n      this.options.perMessageDeflate &&\r\n      secWebSocketExtensions !== undefined\r\n    ) {\r\n      const perMessageDeflate = new PerMessageDeflate(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n\r\n      try {\r\n        const offers = extension.parse(secWebSocketExtensions);\r\n\r\n        if (offers[PerMessageDeflate.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\r\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        const message =\r\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Optionally call external client verification handler.\r\n    //\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin:\r\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\r\n        secure: !!(req.socket.authorized || req.socket.encrypted),\r\n        req\r\n      };\r\n\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message, headers) => {\r\n          if (!verified) {\r\n            return abortHandshake(socket, code || 401, message, headers);\r\n          }\r\n\r\n          this.completeUpgrade(\r\n            extensions,\r\n            key,\r\n            protocols,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\r\n    }\r\n\r\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\r\n  }\r\n\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\r\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\r\n    //\r\n    // Destroy the socket if the client has already sent a FIN packet.\r\n    //\r\n    if (!socket.readable || !socket.writable) return socket.destroy();\r\n\r\n    if (socket[kWebSocket]) {\r\n      throw new Error(\r\n        'server.handleUpgrade() was called more than once with the same ' +\r\n          'socket, possibly due to a misconfiguration'\r\n      );\r\n    }\r\n\r\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    const headers = [\r\n      'HTTP/1.1 101 Switching Protocols',\r\n      'Upgrade: websocket',\r\n      'Connection: Upgrade',\r\n      `Sec-WebSocket-Accept: ${digest}`\r\n    ];\r\n\r\n    const ws = new this.options.WebSocket(null, undefined, this.options);\r\n\r\n    if (protocols.size) {\r\n      //\r\n      // Optionally call external protocol selection handler.\r\n      //\r\n      const protocol = this.options.handleProtocols\r\n        ? this.options.handleProtocols(protocols, req)\r\n        : protocols.values().next().value;\r\n\r\n      if (protocol) {\r\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n        ws._protocol = protocol;\r\n      }\r\n    }\r\n\r\n    if (extensions[PerMessageDeflate.extensionName]) {\r\n      const params = extensions[PerMessageDeflate.extensionName].params;\r\n      const value = extension.format({\r\n        [PerMessageDeflate.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n      ws._extensions = extensions;\r\n    }\r\n\r\n    //\r\n    // Allow external modification/inspection of handshake headers.\r\n    //\r\n    this.emit('headers', headers, req);\r\n\r\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\r\n    socket.removeListener('error', socketOnError);\r\n\r\n    ws.setSocket(socket, head, {\r\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\r\n      maxPayload: this.options.maxPayload,\r\n      skipUTF8Validation: this.options.skipUTF8Validation\r\n    });\r\n\r\n    if (this.clients) {\r\n      this.clients.add(ws);\r\n      ws.on('close', () => {\r\n        this.clients.delete(ws);\r\n\r\n        if (this._shouldEmitClose && !this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        }\r\n      });\r\n    }\r\n\r\n    cb(ws, req);\r\n  }\r\n}\r\n\r\nmodule.exports = WebSocketServer;\r\n\r\n/**\r\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\r\n * pairs.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @param {Object.<String, Function>} map The listeners to add\r\n * @return {Function} A function that will remove the added listeners when\r\n *     called\r\n * @private\r\n */\r\nfunction addListeners(server, map) {\r\n  for (const event of Object.keys(map)) server.on(event, map[event]);\r\n\r\n  return function removeListeners() {\r\n    for (const event of Object.keys(map)) {\r\n      server.removeListener(event, map[event]);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Emit a `'close'` event on an `EventEmitter`.\r\n *\r\n * @param {EventEmitter} server The event emitter\r\n * @private\r\n */\r\nfunction emitClose(server) {\r\n  server._state = CLOSED;\r\n  server.emit('close');\r\n}\r\n\r\n/**\r\n * Handle socket errors.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  this.destroy();\r\n}\r\n\r\n/**\r\n * Close the connection when preconditions are not fulfilled.\r\n *\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} [message] The HTTP response body\r\n * @param {Object} [headers] Additional HTTP response headers\r\n * @private\r\n */\r\nfunction abortHandshake(socket, code, message, headers) {\r\n  //\r\n  // The socket is writable unless the user destroyed or ended it before calling\r\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\r\n  // error. Handling this does not make much sense as the worst that can happen\r\n  // is that some of the data written by the user might be discarded due to the\r\n  // call to `socket.end()` below, which triggers an `'error'` event that in\r\n  // turn causes the socket to be destroyed.\r\n  //\r\n  message = message || http.STATUS_CODES[code];\r\n  headers = {\r\n    Connection: 'close',\r\n    'Content-Type': 'text/html',\r\n    'Content-Length': Buffer.byteLength(message),\r\n    ...headers\r\n  };\r\n\r\n  socket.once('finish', socket.destroy);\r\n\r\n  socket.end(\r\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\r\n      Object.keys(headers)\r\n        .map((h) => `${h}: ${headers[h]}`)\r\n        .join('\\r\\n') +\r\n      '\\r\\n\\r\\n' +\r\n      message\r\n  );\r\n}\r\n\r\n/**\r\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\r\n * one listener for it, otherwise call `abortHandshake()`.\r\n *\r\n * @param {WebSocketServer} server The WebSocket server\r\n * @param {http.IncomingMessage} req The request object\r\n * @param {Duplex} socket The socket of the upgrade request\r\n * @param {Number} code The HTTP response status code\r\n * @param {String} message The HTTP response body\r\n * @private\r\n */\r\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\r\n  if (server.listenerCount('wsClientError')) {\r\n    const err = new Error(message);\r\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\r\n\r\n    server.emit('wsClientError', err, socket, req);\r\n  } else {\r\n    abortHandshake(socket, code, message);\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDtBQUMvRjtBQUNhO0FBQ2I7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkRBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsK0VBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLGlFQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUNsRDtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNu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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjcmVzQ1JNdjJcXFNwZWN0cmVzR3JvdXBDUk1cXGRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx3c1xcbGliXFx3ZWJzb2NrZXQtc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleCRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xyXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XHJcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcblxyXG5jb25zdCBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xyXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xyXG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcblxyXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xyXG5cclxuY29uc3QgUlVOTklORyA9IDA7XHJcbmNvbnN0IENMT1NJTkcgPSAxO1xyXG5jb25zdCBDTE9TRUQgPSAyO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxyXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cclxuICAgKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcclxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXHJcbiAgICogICAgIHRyYWNrIGNsaWVudHNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxyXG4gICAqICAgICBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXHJcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3J0XSBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXHJcbiAgICogICAgIHNlcnZlciB0byB1c2VcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5XZWJTb2NrZXQ9V2ViU29ja2V0XSBTcGVjaWZpZXMgdGhlIGBXZWJTb2NrZXRgXHJcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxyXG4gICAgICBhdXRvUG9uZzogdHJ1ZSxcclxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXHJcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcclxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxyXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcclxuICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxyXG4gICAgICBub1NlcnZlcjogZmFsc2UsXHJcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxyXG4gICAgICBzZXJ2ZXI6IG51bGwsXHJcbiAgICAgIGhvc3Q6IG51bGwsXHJcbiAgICAgIHBhdGg6IG51bGwsXHJcbiAgICAgIHBvcnQ6IG51bGwsXHJcbiAgICAgIFdlYlNvY2tldCxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHx8XHJcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XHJcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcclxuICAgICAgICAgICdtdXN0IGJlIHNwZWNpZmllZCdcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XHJcblxyXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XHJcbiAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aCxcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXMuZW5kKGJvZHkpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcclxuICAgICAgICBvcHRpb25zLnBvcnQsXHJcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxyXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcclxuICAgICAgICBjYWxsYmFja1xyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xyXG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fc2VydmVyKSB7XHJcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcclxuXHJcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IGFkZExpc3RlbmVycyh0aGlzLl9zZXJ2ZXIsIHtcclxuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcclxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXHJcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XHJcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xyXG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXHJcbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcclxuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFkZHJlc3MoKSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxyXG4gICAqIHdoZW4gYWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xvc2UoY2IpIHtcclxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEKSB7XHJcbiAgICAgIGlmIChjYikge1xyXG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcnKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcclxuXHJcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcclxuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcclxuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XHJcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xyXG5cclxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XHJcblxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXHJcbiAgICAgIC8vIGAnY2xvc2UnYCBldmVudC5cclxuICAgICAgLy9cclxuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcclxuICAgICAgICBlbWl0Q2xvc2UodGhpcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xyXG5cclxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XHJcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xyXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG5cclxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xyXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcS5oZWFkZXJzLnVwZ3JhZGU7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcclxuXHJcbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcclxuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVwZ3JhZGUgPT09IHVuZGVmaW5lZCB8fCB1cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCAha2V5UmVnZXgudGVzdChrZXkpKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSkpIHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xyXG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyJztcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcclxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxyXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcclxuICAgICkge1xyXG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcclxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcclxuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xyXG4gICAgICAgICAgZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XHJcbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxyXG4gICAgLy9cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XHJcbiAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgb3JpZ2luOlxyXG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcclxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXHJcbiAgICAgICAgcmVxXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xyXG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoXHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXHJcbiAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgcHJvdG9jb2xzLFxyXG4gICAgICAgICAgICByZXEsXHJcbiAgICAgICAgICAgIHNvY2tldCxcclxuICAgICAgICAgICAgaGVhZCxcclxuICAgICAgICAgICAgY2JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXHJcbiAgICogQHBhcmFtIHtTZXR9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xyXG4gICAgLy9cclxuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxyXG4gICAgLy9cclxuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xyXG5cclxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcclxuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3N0YXRlID4gUlVOTklORykgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNTAzKTtcclxuXHJcbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcclxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxyXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcclxuXHJcbiAgICBjb25zdCBoZWFkZXJzID0gW1xyXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxyXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcclxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxyXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcclxuICAgIF07XHJcblxyXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cclxuICAgICAgLy9cclxuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXHJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxyXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuXHJcbiAgICAgIGlmIChwcm90b2NvbCkge1xyXG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcclxuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xyXG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cclxuICAgICAgfSk7XHJcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xyXG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9cclxuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxyXG4gICAgLy9cclxuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XHJcblxyXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XHJcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XHJcblxyXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcclxuICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRpb25zLm1heFBheWxvYWQsXHJcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xyXG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcclxuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkRW1pdENsb3NlICYmICF0aGlzLmNsaWVudHMuc2l6ZSkge1xyXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2Iod3MsIHJlcSk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcclxuXHJcbi8qKlxyXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XHJcbiAqIHBhaXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFkZGVkIGxpc3RlbmVycyB3aGVuXHJcbiAqICAgICBjYWxsZWRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xyXG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcclxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xyXG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XHJcbiAgc2VydmVyLl9zdGF0ZSA9IENMT1NFRDtcclxuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcclxuICB0aGlzLmRlc3Ryb3koKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cclxuICpcclxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xyXG4gIC8vXHJcbiAgLy8gVGhlIHNvY2tldCBpcyB3cml0YWJsZSB1bmxlc3MgdGhlIHVzZXIgZGVzdHJveWVkIG9yIGVuZGVkIGl0IGJlZm9yZSBjYWxsaW5nXHJcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXHJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cclxuICAvLyBpcyB0aGF0IHNvbWUgb2YgdGhlIGRhdGEgd3JpdHRlbiBieSB0aGUgdXNlciBtaWdodCBiZSBkaXNjYXJkZWQgZHVlIHRvIHRoZVxyXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXHJcbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXHJcbiAgLy9cclxuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcclxuICBoZWFkZXJzID0ge1xyXG4gICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcclxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcclxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxyXG4gICAgLi4uaGVhZGVyc1xyXG4gIH07XHJcblxyXG4gIHNvY2tldC5vbmNlKCdmaW5pc2gnLCBzb2NrZXQuZGVzdHJveSk7XHJcblxyXG4gIHNvY2tldC5lbmQoXHJcbiAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xyXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxyXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcclxuICAgICAgICAuam9pbignXFxyXFxuJykgK1xyXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXHJcbiAgICAgIG1lc3NhZ2VcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcclxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXHJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcclxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcclxuICBpZiAoc2VydmVyLmxpc3RlbmVyQ291bnQoJ3dzQ2xpZW50RXJyb3InKSkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xyXG5cclxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\r\n\r\n\r\n\r\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\r\nconst https = __webpack_require__(/*! https */ \"https\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst tls = __webpack_require__(/*! tls */ \"tls\");\r\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\r\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\r\nconst { URL } = __webpack_require__(/*! url */ \"url\");\r\n\r\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/ws/lib/permessage-deflate.js\");\r\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/ws/lib/receiver.js\");\r\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/ws/lib/sender.js\");\r\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/ws/lib/validation.js\");\r\n\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  GUID,\r\n  kForOnEventAttribute,\r\n  kListener,\r\n  kStatusCode,\r\n  kWebSocket,\r\n  NOOP\r\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ws/lib/constants.js\");\r\nconst {\r\n  EventTarget: { addEventListener, removeEventListener }\r\n} = __webpack_require__(/*! ./event-target */ \"(ssr)/./node_modules/ws/lib/event-target.js\");\r\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/ws/lib/extension.js\");\r\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/./node_modules/ws/lib/buffer-util.js\");\r\n\r\nconst closeTimeout = 30 * 1000;\r\nconst kAborted = Symbol('kAborted');\r\nconst protocolVersions = [8, 13];\r\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\r\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\r\n\r\n/**\r\n * Class representing a WebSocket.\r\n *\r\n * @extends EventEmitter\r\n */\r\nclass WebSocket extends EventEmitter {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\r\n  constructor(address, protocols, options) {\r\n    super();\r\n\r\n    this._binaryType = BINARY_TYPES[0];\r\n    this._closeCode = 1006;\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = EMPTY_BUFFER;\r\n    this._closeTimer = null;\r\n    this._errorEmitted = false;\r\n    this._extensions = {};\r\n    this._paused = false;\r\n    this._protocol = '';\r\n    this._readyState = WebSocket.CONNECTING;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n\r\n    if (address !== null) {\r\n      this._bufferedAmount = 0;\r\n      this._isServer = false;\r\n      this._redirects = 0;\r\n\r\n      if (protocols === undefined) {\r\n        protocols = [];\r\n      } else if (!Array.isArray(protocols)) {\r\n        if (typeof protocols === 'object' && protocols !== null) {\r\n          options = protocols;\r\n          protocols = [];\r\n        } else {\r\n          protocols = [protocols];\r\n        }\r\n      }\r\n\r\n      initAsClient(this, address, protocols, options);\r\n    } else {\r\n      this._autoPong = options.autoPong;\r\n      this._isServer = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\r\n   * instead of \"blob\".\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType() {\r\n    return this._binaryType;\r\n  }\r\n\r\n  set binaryType(type) {\r\n    if (!BINARY_TYPES.includes(type)) return;\r\n\r\n    this._binaryType = type;\r\n\r\n    //\r\n    // Allow to change `binaryType` on the fly.\r\n    //\r\n    if (this._receiver) this._receiver._binaryType = type;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount() {\r\n    if (!this._socket) return this._bufferedAmount;\r\n\r\n    return this._socket._writableState.length + this._sender._bufferedBytes;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get extensions() {\r\n    return Object.keys(this._extensions).join();\r\n  }\r\n\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onclose() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onerror() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onopen() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onmessage() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get protocol() {\r\n    return this._protocol;\r\n  }\r\n\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get readyState() {\r\n    return this._readyState;\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {Duplex} socket The network socket between the server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\r\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\r\n   *     multiple times in the same tick\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\r\n  setSocket(socket, head, options) {\r\n    const receiver = new Receiver({\r\n      allowSynchronousEvents: options.allowSynchronousEvents,\r\n      binaryType: this.binaryType,\r\n      extensions: this._extensions,\r\n      isServer: this._isServer,\r\n      maxPayload: options.maxPayload,\r\n      skipUTF8Validation: options.skipUTF8Validation\r\n    });\r\n\r\n    const sender = new Sender(socket, this._extensions, options.generateMask);\r\n\r\n    this._receiver = receiver;\r\n    this._sender = sender;\r\n    this._socket = socket;\r\n\r\n    receiver[kWebSocket] = this;\r\n    sender[kWebSocket] = this;\r\n    socket[kWebSocket] = this;\r\n\r\n    receiver.on('conclude', receiverOnConclude);\r\n    receiver.on('drain', receiverOnDrain);\r\n    receiver.on('error', receiverOnError);\r\n    receiver.on('message', receiverOnMessage);\r\n    receiver.on('ping', receiverOnPing);\r\n    receiver.on('pong', receiverOnPong);\r\n\r\n    sender.onerror = senderOnError;\r\n\r\n    //\r\n    // These methods may not be available if `socket` is just a `Duplex`.\r\n    //\r\n    if (socket.setTimeout) socket.setTimeout(0);\r\n    if (socket.setNoDelay) socket.setNoDelay();\r\n\r\n    if (head.length > 0) socket.unshift(head);\r\n\r\n    socket.on('close', socketOnClose);\r\n    socket.on('data', socketOnData);\r\n    socket.on('end', socketOnEnd);\r\n    socket.on('error', socketOnError);\r\n\r\n    this._readyState = WebSocket.OPEN;\r\n    this.emit('open');\r\n  }\r\n\r\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose() {\r\n    if (!this._socket) {\r\n      this._readyState = WebSocket.CLOSED;\r\n      this.emit('close', this._closeCode, this._closeMessage);\r\n      return;\r\n    }\r\n\r\n    if (this._extensions[PerMessageDeflate.extensionName]) {\r\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\r\n    }\r\n\r\n    this._receiver.removeAllListeners();\r\n    this._readyState = WebSocket.CLOSED;\r\n    this.emit('close', this._closeCode, this._closeMessage);\r\n  }\r\n\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\r\n  close(code, data) {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (\r\n        this._closeFrameSent &&\r\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    this._readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      //\r\n      // This error is handled by the `'error'` listener on the socket. We only\r\n      // want to know if the close frame has been sent here.\r\n      //\r\n      if (err) return;\r\n\r\n      this._closeFrameSent = true;\r\n\r\n      if (\r\n        this._closeFrameReceived ||\r\n        this._receiver._writableState.errorEmitted\r\n      ) {\r\n        this._socket.end();\r\n      }\r\n    });\r\n\r\n    setCloseTimer(this);\r\n  }\r\n\r\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\r\n  pause() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = true;\r\n    this._socket.pause();\r\n  }\r\n\r\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\r\n  ping(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\r\n  pong(data, mask, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof data === 'function') {\r\n      cb = data;\r\n      data = mask = undefined;\r\n    } else if (typeof mask === 'function') {\r\n      cb = mask;\r\n      mask = undefined;\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    if (mask === undefined) mask = !this._isServer;\r\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\r\n  }\r\n\r\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\r\n  resume() {\r\n    if (\r\n      this.readyState === WebSocket.CONNECTING ||\r\n      this.readyState === WebSocket.CLOSED\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this._paused = false;\r\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\r\n  }\r\n\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\r\n    }\r\n\r\n    if (typeof options === 'function') {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n\r\n    if (typeof data === 'number') data = data.toString();\r\n\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n\r\n    const opts = {\r\n      binary: typeof data !== 'string',\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true,\r\n      ...options\r\n    };\r\n\r\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n\r\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\r\n  }\r\n\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate() {\r\n    if (this.readyState === WebSocket.CLOSED) return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = 'WebSocket was closed before the connection was established';\r\n      abortHandshake(this, this._req, msg);\r\n      return;\r\n    }\r\n\r\n    if (this._socket) {\r\n      this._readyState = WebSocket.CLOSING;\r\n      this._socket.destroy();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CONNECTING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CONNECTING')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} OPEN\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('OPEN')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSING\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSING')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket\r\n */\r\nObject.defineProperty(WebSocket, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n/**\r\n * @constant {Number} CLOSED\r\n * @memberof WebSocket.prototype\r\n */\r\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\r\n  enumerable: true,\r\n  value: readyStates.indexOf('CLOSED')\r\n});\r\n\r\n[\r\n  'binaryType',\r\n  'bufferedAmount',\r\n  'extensions',\r\n  'isPaused',\r\n  'protocol',\r\n  'readyState',\r\n  'url'\r\n].forEach((property) => {\r\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\r\n});\r\n\r\n//\r\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\r\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\r\n//\r\n['open', 'error', 'close', 'message'].forEach((method) => {\r\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\r\n    enumerable: true,\r\n    get() {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) return listener[kListener];\r\n      }\r\n\r\n      return null;\r\n    },\r\n    set(handler) {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) {\r\n          this.removeListener(method, listener);\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (typeof handler !== 'function') return;\r\n\r\n      this.addEventListener(method, handler, {\r\n        [kForOnEventAttribute]: true\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nWebSocket.prototype.addEventListener = addEventListener;\r\nWebSocket.prototype.removeEventListener = removeEventListener;\r\n\r\nmodule.exports = WebSocket;\r\n\r\n/**\r\n * Initialize a WebSocket client.\r\n *\r\n * @param {WebSocket} websocket The client to initialize\r\n * @param {(String|URL)} address The URL to which to connect\r\n * @param {Array} protocols The subprotocols\r\n * @param {Object} [options] Connection options\r\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\r\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\r\n *     times in the same tick\r\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\r\n *     automatically send a pong in response to a ping\r\n * @param {Function} [options.finishRequest] A function which can be used to\r\n *     customize the headers of each http request before it is sent\r\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\r\n *     redirects\r\n * @param {Function} [options.generateMask] The function used to generate the\r\n *     masking key\r\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\r\n *     handshake request\r\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n *     size\r\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\r\n *     allowed\r\n * @param {String} [options.origin] Value of the `Origin` or\r\n *     `Sec-WebSocket-Origin` header\r\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\r\n *     permessage-deflate\r\n * @param {Number} [options.protocolVersion=13] Value of the\r\n *     `Sec-WebSocket-Version` header\r\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n *     not to skip UTF-8 validation for text and close messages\r\n * @private\r\n */\r\nfunction initAsClient(websocket, address, protocols, options) {\r\n  const opts = {\r\n    allowSynchronousEvents: true,\r\n    autoPong: true,\r\n    protocolVersion: protocolVersions[1],\r\n    maxPayload: 100 * 1024 * 1024,\r\n    skipUTF8Validation: false,\r\n    perMessageDeflate: true,\r\n    followRedirects: false,\r\n    maxRedirects: 10,\r\n    ...options,\r\n    socketPath: undefined,\r\n    hostname: undefined,\r\n    protocol: undefined,\r\n    timeout: undefined,\r\n    method: 'GET',\r\n    host: undefined,\r\n    path: undefined,\r\n    port: undefined\r\n  };\r\n\r\n  websocket._autoPong = opts.autoPong;\r\n\r\n  if (!protocolVersions.includes(opts.protocolVersion)) {\r\n    throw new RangeError(\r\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\r\n        `(supported versions: ${protocolVersions.join(', ')})`\r\n    );\r\n  }\r\n\r\n  let parsedUrl;\r\n\r\n  if (address instanceof URL) {\r\n    parsedUrl = address;\r\n  } else {\r\n    try {\r\n      parsedUrl = new URL(address);\r\n    } catch (e) {\r\n      throw new SyntaxError(`Invalid URL: ${address}`);\r\n    }\r\n  }\r\n\r\n  if (parsedUrl.protocol === 'http:') {\r\n    parsedUrl.protocol = 'ws:';\r\n  } else if (parsedUrl.protocol === 'https:') {\r\n    parsedUrl.protocol = 'wss:';\r\n  }\r\n\r\n  websocket._url = parsedUrl.href;\r\n\r\n  const isSecure = parsedUrl.protocol === 'wss:';\r\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\r\n  let invalidUrlMessage;\r\n\r\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\r\n    invalidUrlMessage =\r\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\r\n      '\"http:\", \"https:\", or \"ws+unix:\"';\r\n  } else if (isIpcUrl && !parsedUrl.pathname) {\r\n    invalidUrlMessage = \"The URL's pathname is empty\";\r\n  } else if (parsedUrl.hash) {\r\n    invalidUrlMessage = 'The URL contains a fragment identifier';\r\n  }\r\n\r\n  if (invalidUrlMessage) {\r\n    const err = new SyntaxError(invalidUrlMessage);\r\n\r\n    if (websocket._redirects === 0) {\r\n      throw err;\r\n    } else {\r\n      emitErrorAndClose(websocket, err);\r\n      return;\r\n    }\r\n  }\r\n\r\n  const defaultPort = isSecure ? 443 : 80;\r\n  const key = randomBytes(16).toString('base64');\r\n  const request = isSecure ? https.request : http.request;\r\n  const protocolSet = new Set();\r\n  let perMessageDeflate;\r\n\r\n  opts.createConnection =\r\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\r\n  opts.defaultPort = opts.defaultPort || defaultPort;\r\n  opts.port = parsedUrl.port || defaultPort;\r\n  opts.host = parsedUrl.hostname.startsWith('[')\r\n    ? parsedUrl.hostname.slice(1, -1)\r\n    : parsedUrl.hostname;\r\n  opts.headers = {\r\n    ...opts.headers,\r\n    'Sec-WebSocket-Version': opts.protocolVersion,\r\n    'Sec-WebSocket-Key': key,\r\n    Connection: 'Upgrade',\r\n    Upgrade: 'websocket'\r\n  };\r\n  opts.path = parsedUrl.pathname + parsedUrl.search;\r\n  opts.timeout = opts.handshakeTimeout;\r\n\r\n  if (opts.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate(\r\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\r\n      false,\r\n      opts.maxPayload\r\n    );\r\n    opts.headers['Sec-WebSocket-Extensions'] = format({\r\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (protocols.length) {\r\n    for (const protocol of protocols) {\r\n      if (\r\n        typeof protocol !== 'string' ||\r\n        !subprotocolRegex.test(protocol) ||\r\n        protocolSet.has(protocol)\r\n      ) {\r\n        throw new SyntaxError(\r\n          'An invalid or duplicated subprotocol was specified'\r\n        );\r\n      }\r\n\r\n      protocolSet.add(protocol);\r\n    }\r\n\r\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\r\n  }\r\n  if (opts.origin) {\r\n    if (opts.protocolVersion < 13) {\r\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\r\n    } else {\r\n      opts.headers.Origin = opts.origin;\r\n    }\r\n  }\r\n  if (parsedUrl.username || parsedUrl.password) {\r\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\r\n  }\r\n\r\n  if (isIpcUrl) {\r\n    const parts = opts.path.split(':');\r\n\r\n    opts.socketPath = parts[0];\r\n    opts.path = parts[1];\r\n  }\r\n\r\n  let req;\r\n\r\n  if (opts.followRedirects) {\r\n    if (websocket._redirects === 0) {\r\n      websocket._originalIpc = isIpcUrl;\r\n      websocket._originalSecure = isSecure;\r\n      websocket._originalHostOrSocketPath = isIpcUrl\r\n        ? opts.socketPath\r\n        : parsedUrl.host;\r\n\r\n      const headers = options && options.headers;\r\n\r\n      //\r\n      // Shallow copy the user provided options so that headers can be changed\r\n      // without mutating the original object.\r\n      //\r\n      options = { ...options, headers: {} };\r\n\r\n      if (headers) {\r\n        for (const [key, value] of Object.entries(headers)) {\r\n          options.headers[key.toLowerCase()] = value;\r\n        }\r\n      }\r\n    } else if (websocket.listenerCount('redirect') === 0) {\r\n      const isSameHost = isIpcUrl\r\n        ? websocket._originalIpc\r\n          ? opts.socketPath === websocket._originalHostOrSocketPath\r\n          : false\r\n        : websocket._originalIpc\r\n          ? false\r\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\r\n\r\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\r\n        //\r\n        // Match curl 7.77.0 behavior and drop the following headers. These\r\n        // headers are also dropped when following a redirect to a subdomain.\r\n        //\r\n        delete opts.headers.authorization;\r\n        delete opts.headers.cookie;\r\n\r\n        if (!isSameHost) delete opts.headers.host;\r\n\r\n        opts.auth = undefined;\r\n      }\r\n    }\r\n\r\n    //\r\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\r\n    // If the `Authorization` header is set, then there is nothing to do as it\r\n    // will take precedence.\r\n    //\r\n    if (opts.auth && !options.headers.authorization) {\r\n      options.headers.authorization =\r\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\r\n    }\r\n\r\n    req = websocket._req = request(opts);\r\n\r\n    if (websocket._redirects) {\r\n      //\r\n      // Unlike what is done for the `'upgrade'` event, no early exit is\r\n      // triggered here if the user calls `websocket.close()` or\r\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\r\n      // is because the user can also call `request.destroy()` with an error\r\n      // before calling `websocket.close()` or `websocket.terminate()` and this\r\n      // would result in an error being emitted on the `request` object with no\r\n      // `'error'` event listeners attached.\r\n      //\r\n      websocket.emit('redirect', websocket.url, req);\r\n    }\r\n  } else {\r\n    req = websocket._req = request(opts);\r\n  }\r\n\r\n  if (opts.timeout) {\r\n    req.on('timeout', () => {\r\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\r\n    });\r\n  }\r\n\r\n  req.on('error', (err) => {\r\n    if (req === null || req[kAborted]) return;\r\n\r\n    req = websocket._req = null;\r\n    emitErrorAndClose(websocket, err);\r\n  });\r\n\r\n  req.on('response', (res) => {\r\n    const location = res.headers.location;\r\n    const statusCode = res.statusCode;\r\n\r\n    if (\r\n      location &&\r\n      opts.followRedirects &&\r\n      statusCode >= 300 &&\r\n      statusCode < 400\r\n    ) {\r\n      if (++websocket._redirects > opts.maxRedirects) {\r\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\r\n        return;\r\n      }\r\n\r\n      req.abort();\r\n\r\n      let addr;\r\n\r\n      try {\r\n        addr = new URL(location, address);\r\n      } catch (e) {\r\n        const err = new SyntaxError(`Invalid URL: ${location}`);\r\n        emitErrorAndClose(websocket, err);\r\n        return;\r\n      }\r\n\r\n      initAsClient(websocket, addr, protocols, options);\r\n    } else if (!websocket.emit('unexpected-response', req, res)) {\r\n      abortHandshake(\r\n        websocket,\r\n        req,\r\n        `Unexpected server response: ${res.statusCode}`\r\n      );\r\n    }\r\n  });\r\n\r\n  req.on('upgrade', (res, socket, head) => {\r\n    websocket.emit('upgrade', res);\r\n\r\n    //\r\n    // The user may have closed the connection from a listener of the\r\n    // `'upgrade'` event.\r\n    //\r\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\r\n\r\n    req = websocket._req = null;\r\n\r\n    const upgrade = res.headers.upgrade;\r\n\r\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\r\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\r\n      return;\r\n    }\r\n\r\n    const digest = createHash('sha1')\r\n      .update(key + GUID)\r\n      .digest('base64');\r\n\r\n    if (res.headers['sec-websocket-accept'] !== digest) {\r\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\r\n      return;\r\n    }\r\n\r\n    const serverProt = res.headers['sec-websocket-protocol'];\r\n    let protError;\r\n\r\n    if (serverProt !== undefined) {\r\n      if (!protocolSet.size) {\r\n        protError = 'Server sent a subprotocol but none was requested';\r\n      } else if (!protocolSet.has(serverProt)) {\r\n        protError = 'Server sent an invalid subprotocol';\r\n      }\r\n    } else if (protocolSet.size) {\r\n      protError = 'Server sent no subprotocol';\r\n    }\r\n\r\n    if (protError) {\r\n      abortHandshake(websocket, socket, protError);\r\n      return;\r\n    }\r\n\r\n    if (serverProt) websocket._protocol = serverProt;\r\n\r\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\r\n\r\n    if (secWebSocketExtensions !== undefined) {\r\n      if (!perMessageDeflate) {\r\n        const message =\r\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\r\n          'was requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      let extensions;\r\n\r\n      try {\r\n        extensions = parse(secWebSocketExtensions);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      const extensionNames = Object.keys(extensions);\r\n\r\n      if (\r\n        extensionNames.length !== 1 ||\r\n        extensionNames[0] !== PerMessageDeflate.extensionName\r\n      ) {\r\n        const message = 'Server indicated an extension that was not requested';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\r\n      } catch (err) {\r\n        const message = 'Invalid Sec-WebSocket-Extensions header';\r\n        abortHandshake(websocket, socket, message);\r\n        return;\r\n      }\r\n\r\n      websocket._extensions[PerMessageDeflate.extensionName] =\r\n        perMessageDeflate;\r\n    }\r\n\r\n    websocket.setSocket(socket, head, {\r\n      allowSynchronousEvents: opts.allowSynchronousEvents,\r\n      generateMask: opts.generateMask,\r\n      maxPayload: opts.maxPayload,\r\n      skipUTF8Validation: opts.skipUTF8Validation\r\n    });\r\n  });\r\n\r\n  if (opts.finishRequest) {\r\n    opts.finishRequest(req, websocket);\r\n  } else {\r\n    req.end();\r\n  }\r\n}\r\n\r\n/**\r\n * Emit the `'error'` and `'close'` events.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {Error} The error to emit\r\n * @private\r\n */\r\nfunction emitErrorAndClose(websocket, err) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  //\r\n  // The following assignment is practically useless and is done only for\r\n  // consistency.\r\n  //\r\n  websocket._errorEmitted = true;\r\n  websocket.emit('error', err);\r\n  websocket.emitClose();\r\n}\r\n\r\n/**\r\n * Create a `net.Socket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {net.Socket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction netConnect(options) {\r\n  options.path = options.socketPath;\r\n  return net.connect(options);\r\n}\r\n\r\n/**\r\n * Create a `tls.TLSSocket` and initiate a connection.\r\n *\r\n * @param {Object} options Connection options\r\n * @return {tls.TLSSocket} The newly created socket used to start the connection\r\n * @private\r\n */\r\nfunction tlsConnect(options) {\r\n  options.path = undefined;\r\n\r\n  if (!options.servername && options.servername !== '') {\r\n    options.servername = net.isIP(options.host) ? '' : options.host;\r\n  }\r\n\r\n  return tls.connect(options);\r\n}\r\n\r\n/**\r\n * Abort the handshake and emit an error.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\r\n *     abort or the socket to destroy\r\n * @param {String} message The error message\r\n * @private\r\n */\r\nfunction abortHandshake(websocket, stream, message) {\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  const err = new Error(message);\r\n  Error.captureStackTrace(err, abortHandshake);\r\n\r\n  if (stream.setHeader) {\r\n    stream[kAborted] = true;\r\n    stream.abort();\r\n\r\n    if (stream.socket && !stream.socket.destroyed) {\r\n      //\r\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\r\n      // called after the request completed. See\r\n      // https://github.com/websockets/ws/issues/1869.\r\n      //\r\n      stream.socket.destroy();\r\n    }\r\n\r\n    process.nextTick(emitErrorAndClose, websocket, err);\r\n  } else {\r\n    stream.destroy(err);\r\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\r\n    stream.once('close', websocket.emitClose.bind(websocket));\r\n  }\r\n}\r\n\r\n/**\r\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\r\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @param {*} [data] The data to send\r\n * @param {Function} [cb] Callback\r\n * @private\r\n */\r\nfunction sendAfterClose(websocket, data, cb) {\r\n  if (data) {\r\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\r\n\r\n    //\r\n    // The `_bufferedAmount` property is used only when the peer is a client and\r\n    // the opening handshake fails. Under these circumstances, in fact, the\r\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\r\n    // properties are set to `null`.\r\n    //\r\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\r\n    else websocket._bufferedAmount += length;\r\n  }\r\n\r\n  if (cb) {\r\n    const err = new Error(\r\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\r\n        `(${readyStates[websocket.readyState]})`\r\n    );\r\n    process.nextTick(cb, err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'conclude'` event.\r\n *\r\n * @param {Number} code The status code\r\n * @param {Buffer} reason The reason for closing\r\n * @private\r\n */\r\nfunction receiverOnConclude(code, reason) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._closeFrameReceived = true;\r\n  websocket._closeMessage = reason;\r\n  websocket._closeCode = code;\r\n\r\n  if (websocket._socket[kWebSocket] === undefined) return;\r\n\r\n  websocket._socket.removeListener('data', socketOnData);\r\n  process.nextTick(resume, websocket._socket);\r\n\r\n  if (code === 1005) websocket.close();\r\n  else websocket.close(code, reason);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'drain'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnDrain() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (!websocket.isPaused) websocket._socket.resume();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'error'` event.\r\n *\r\n * @param {(RangeError|Error)} err The emitted error\r\n * @private\r\n */\r\nfunction receiverOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._socket[kWebSocket] !== undefined) {\r\n    websocket._socket.removeListener('data', socketOnData);\r\n\r\n    //\r\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\r\n    // https://github.com/websockets/ws/issues/1940.\r\n    //\r\n    process.nextTick(resume, websocket._socket);\r\n\r\n    websocket.close(err[kStatusCode]);\r\n  }\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'finish'` event.\r\n *\r\n * @private\r\n */\r\nfunction receiverOnFinish() {\r\n  this[kWebSocket].emitClose();\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'message'` event.\r\n *\r\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\r\n * @param {Boolean} isBinary Specifies whether the message is binary or not\r\n * @private\r\n */\r\nfunction receiverOnMessage(data, isBinary) {\r\n  this[kWebSocket].emit('message', data, isBinary);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'ping'` event.\r\n *\r\n * @param {Buffer} data The data included in the ping frame\r\n * @private\r\n */\r\nfunction receiverOnPing(data) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\r\n  websocket.emit('ping', data);\r\n}\r\n\r\n/**\r\n * The listener of the `Receiver` `'pong'` event.\r\n *\r\n * @param {Buffer} data The data included in the pong frame\r\n * @private\r\n */\r\nfunction receiverOnPong(data) {\r\n  this[kWebSocket].emit('pong', data);\r\n}\r\n\r\n/**\r\n * Resume a readable stream\r\n *\r\n * @param {Readable} stream The readable stream\r\n * @private\r\n */\r\nfunction resume(stream) {\r\n  stream.resume();\r\n}\r\n\r\n/**\r\n * The `Sender` error event handler.\r\n *\r\n * @param {Error} The error\r\n * @private\r\n */\r\nfunction senderOnError(err) {\r\n  const websocket = this[kWebSocket];\r\n\r\n  if (websocket.readyState === WebSocket.CLOSED) return;\r\n  if (websocket.readyState === WebSocket.OPEN) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    setCloseTimer(websocket);\r\n  }\r\n\r\n  //\r\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\r\n  // peer to finish sending queued data. There is no need to set a timer here\r\n  // because `CLOSING` means that it is already set or not needed.\r\n  //\r\n  this._socket.end();\r\n\r\n  if (!websocket._errorEmitted) {\r\n    websocket._errorEmitted = true;\r\n    websocket.emit('error', err);\r\n  }\r\n}\r\n\r\n/**\r\n * Set a timer to destroy the underlying raw socket of a WebSocket.\r\n *\r\n * @param {WebSocket} websocket The WebSocket instance\r\n * @private\r\n */\r\nfunction setCloseTimer(websocket) {\r\n  websocket._closeTimer = setTimeout(\r\n    websocket._socket.destroy.bind(websocket._socket),\r\n    closeTimeout\r\n  );\r\n}\r\n\r\n/**\r\n * The listener of the socket `'close'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnClose() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('close', socketOnClose);\r\n  this.removeListener('data', socketOnData);\r\n  this.removeListener('end', socketOnEnd);\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n\r\n  let chunk;\r\n\r\n  //\r\n  // The close frame might not have been received or the `'end'` event emitted,\r\n  // for example, if the socket was destroyed due to an error. Ensure that the\r\n  // `receiver` stream is closed after writing any remaining buffered data to\r\n  // it. If the readable side of the socket is in flowing mode then there is no\r\n  // buffered data as everything has been already written and `readable.read()`\r\n  // will return `null`. If instead, the socket is paused, any possible buffered\r\n  // data will be read as a single chunk.\r\n  //\r\n  if (\r\n    !this._readableState.endEmitted &&\r\n    !websocket._closeFrameReceived &&\r\n    !websocket._receiver._writableState.errorEmitted &&\r\n    (chunk = websocket._socket.read()) !== null\r\n  ) {\r\n    websocket._receiver.write(chunk);\r\n  }\r\n\r\n  websocket._receiver.end();\r\n\r\n  this[kWebSocket] = undefined;\r\n\r\n  clearTimeout(websocket._closeTimer);\r\n\r\n  if (\r\n    websocket._receiver._writableState.finished ||\r\n    websocket._receiver._writableState.errorEmitted\r\n  ) {\r\n    websocket.emitClose();\r\n  } else {\r\n    websocket._receiver.on('error', receiverOnFinish);\r\n    websocket._receiver.on('finish', receiverOnFinish);\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction socketOnData(chunk) {\r\n  if (!this[kWebSocket]._receiver.write(chunk)) {\r\n    this.pause();\r\n  }\r\n}\r\n\r\n/**\r\n * The listener of the socket `'end'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnEnd() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  websocket._readyState = WebSocket.CLOSING;\r\n  websocket._receiver.end();\r\n  this.end();\r\n}\r\n\r\n/**\r\n * The listener of the socket `'error'` event.\r\n *\r\n * @private\r\n */\r\nfunction socketOnError() {\r\n  const websocket = this[kWebSocket];\r\n\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', NOOP);\r\n\r\n  if (websocket) {\r\n    websocket._readyState = WebSocket.CLOSING;\r\n    this.destroy();\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msa0VBQWtFO0FBQ3hHO0FBQ2E7QUFDYjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDcEQsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0I7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsMkRBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLHVEQUFVO0FBQ2pDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDNUIsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDZEQUFhO0FBQy9DLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsaUVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xca2thY3BcXERlc2t0b3BcXFNwZWNyZXNDUk12MlxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdzXFxsaWJcXHdlYnNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXh8UmVhZGFibGUkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcclxuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xyXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcclxuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XHJcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5jb25zdCB7IER1cGxleCwgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XHJcblxyXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XHJcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xyXG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xyXG5jb25zdCB7IGlzQmxvYiB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XHJcblxyXG5jb25zdCB7XHJcbiAgQklOQVJZX1RZUEVTLFxyXG4gIEVNUFRZX0JVRkZFUixcclxuICBHVUlELFxyXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxyXG4gIGtMaXN0ZW5lcixcclxuICBrU3RhdHVzQ29kZSxcclxuICBrV2ViU29ja2V0LFxyXG4gIE5PT1BcclxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbmNvbnN0IHtcclxuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cclxufSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XHJcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcclxuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xyXG5cclxuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xyXG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcclxuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XHJcbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcclxuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcclxuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XHJcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSBFTVBUWV9CVUZGRVI7XHJcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcclxuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHt9O1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xyXG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XHJcblxyXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnQgPSAwO1xyXG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xyXG5cclxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHJvdG9jb2xzID0gW107XHJcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcclxuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XHJcbiAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcclxuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgdGhlIGN1c3RvbSBcIm5vZGVidWZmZXJcIiB0eXBlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcclxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxyXG4gICAqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgYmluYXJ5VHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xyXG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxyXG4gICAgLy9cclxuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBnZXQgZXh0ZW5zaW9ucygpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNQYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgZ2V0IG9uY2xvc2UoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIGdldCBvbmVycm9yKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBnZXQgb25vcGVuKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICBnZXQgb25tZXNzYWdlKCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBwcm90b2NvbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IHVybCgpIHtcclxuICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XHJcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXHJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXHJcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxyXG4gICAqICAgICBtYXNraW5nIGtleVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXHJcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XHJcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcclxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxyXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxyXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXHJcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcclxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcclxuXHJcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xyXG5cclxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcclxuICAgIHNlbmRlcltrV2ViU29ja2V0XSA9IHRoaXM7XHJcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xyXG5cclxuICAgIHJlY2VpdmVyLm9uKCdjb25jbHVkZScsIHJlY2VpdmVyT25Db25jbHVkZSk7XHJcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xyXG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcclxuICAgIHJlY2VpdmVyLm9uKCdtZXNzYWdlJywgcmVjZWl2ZXJPbk1lc3NhZ2UpO1xyXG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XHJcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcclxuXHJcbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxyXG4gICAgLy9cclxuICAgIGlmIChzb2NrZXQuc2V0VGltZW91dCkgc29ja2V0LnNldFRpbWVvdXQoMCk7XHJcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XHJcblxyXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XHJcblxyXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xyXG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcclxuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xyXG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG5cclxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcclxuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBlbWl0Q2xvc2UoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xyXG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcclxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XHJcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XHJcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cclxuICAgKlxyXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcclxuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cclxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XHJcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcclxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXHJcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcclxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XHJcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXHJcbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xyXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXHJcbiAgICogICAgICAgICAgICAgICstLS0rXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcclxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXHJcbiAgICogICAgIGNsb3NpbmdcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgY2xvc2UoY29kZSwgZGF0YSkge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcclxuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcclxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XHJcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoZXJyKSByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XHJcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgYSBwaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gZGF0YTtcclxuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gbWFzaztcclxuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XHJcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZCBhIHBvbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcclxuICAgKiBAcHVibGljXHJcbiAgICovXHJcbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2IgPSBkYXRhO1xyXG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2IgPSBtYXNrO1xyXG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcclxuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICByZXN1bWUoKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcclxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxyXG4gICAqICAgICB0ZXh0XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXHJcbiAgICogICAgIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcclxuICAgKiAgICAgbGFzdCBvbmVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNiID0gb3B0aW9ucztcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcclxuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtcclxuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXHJcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcclxuICAgICAgY29tcHJlc3M6IHRydWUsXHJcbiAgICAgIGZpbjogdHJ1ZSxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcclxuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICB0ZXJtaW5hdGUoKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xyXG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcclxuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxyXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cclxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcclxufSk7XHJcblxyXG4vKipcclxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcclxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcclxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXHJcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxyXG59KTtcclxuXHJcbltcclxuICAnYmluYXJ5VHlwZScsXHJcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcclxuICAnZXh0ZW5zaW9ucycsXHJcbiAgJ2lzUGF1c2VkJyxcclxuICAncHJvdG9jb2wnLFxyXG4gICdyZWFkeVN0YXRlJyxcclxuICAndXJsJ1xyXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbn0pO1xyXG5cclxuLy9cclxuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxyXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxyXG4vL1xyXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0KCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcclxuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgc2V0KGhhbmRsZXIpIHtcclxuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XHJcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xyXG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXHJcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XHJcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXHJcbiAqICAgICB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXHJcbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5pc2hSZXF1ZXN0XSBBIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvXHJcbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xyXG4gKiAgICAgcmVkaXJlY3RzXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXHJcbiAqICAgICBtYXNraW5nIGtleVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxyXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcclxuICogICAgIHNpemVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xyXG4gKiAgICAgYWxsb3dlZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXHJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcclxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcclxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcclxuICBjb25zdCBvcHRzID0ge1xyXG4gICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcclxuICAgIGF1dG9Qb25nOiB0cnVlLFxyXG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxyXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXHJcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxyXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXHJcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxyXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXHJcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxyXG4gICAgcHJvdG9jb2w6IHVuZGVmaW5lZCxcclxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcclxuICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICBob3N0OiB1bmRlZmluZWQsXHJcbiAgICBwYXRoOiB1bmRlZmluZWQsXHJcbiAgICBwb3J0OiB1bmRlZmluZWRcclxuICB9O1xyXG5cclxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcclxuXHJcbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXHJcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcclxuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBsZXQgcGFyc2VkVXJsO1xyXG5cclxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xyXG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcclxuICB9IGVsc2Uge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xyXG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzOic7XHJcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XHJcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XHJcbiAgfVxyXG5cclxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xyXG5cclxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xyXG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xyXG4gIGxldCBpbnZhbGlkVXJsTWVzc2FnZTtcclxuXHJcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xyXG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPVxyXG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xyXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzOlwiLCBvciBcIndzK3VuaXg6XCInO1xyXG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xyXG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcclxuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcclxuICB9XHJcblxyXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcclxuXHJcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XHJcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuICBjb25zdCByZXF1ZXN0ID0gaXNTZWN1cmUgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0O1xyXG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xyXG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcclxuXHJcbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cclxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XHJcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XHJcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XHJcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxyXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXHJcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcclxuICBvcHRzLmhlYWRlcnMgPSB7XHJcbiAgICAuLi5vcHRzLmhlYWRlcnMsXHJcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXHJcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXHJcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXHJcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xyXG4gIH07XHJcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcclxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XHJcblxyXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XHJcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcclxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxyXG4gICAgKTtcclxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xyXG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xyXG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxyXG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxyXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xyXG4gIH1cclxuICBpZiAob3B0cy5vcmlnaW4pIHtcclxuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XHJcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xyXG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzSXBjVXJsKSB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xyXG5cclxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xyXG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XHJcbiAgfVxyXG5cclxuICBsZXQgcmVxO1xyXG5cclxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcclxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xyXG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XHJcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcclxuICAgICAgd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGggPSBpc0lwY1VybFxyXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXHJcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcclxuXHJcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcclxuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxyXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXHJcbiAgICAgIC8vXHJcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XHJcblxyXG4gICAgICBpZiAoaGVhZGVycykge1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XHJcbiAgICAgIGNvbnN0IGlzU2FtZUhvc3QgPSBpc0lwY1VybFxyXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xyXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXHJcbiAgICAgICAgICA6IGZhbHNlXHJcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXHJcbiAgICAgICAgICA/IGZhbHNlXHJcbiAgICAgICAgICA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcclxuXHJcbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXHJcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXHJcbiAgICAgICAgLy9cclxuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XHJcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XHJcblxyXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xyXG5cclxuICAgICAgICBvcHRzLmF1dGggPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxyXG4gICAgLy8gSWYgdGhlIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgaXMgc2V0LCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gYXMgaXRcclxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxyXG4gICAgLy9cclxuICAgIGlmIChvcHRzLmF1dGggJiYgIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XHJcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cclxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcclxuXHJcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gVW5saWtlIHdoYXQgaXMgZG9uZSBmb3IgdGhlIGAndXBncmFkZSdgIGV2ZW50LCBubyBlYXJseSBleGl0IGlzXHJcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcclxuICAgICAgLy8gaXMgYmVjYXVzZSB0aGUgdXNlciBjYW4gYWxzbyBjYWxsIGByZXF1ZXN0LmRlc3Ryb3koKWAgd2l0aCBhbiBlcnJvclxyXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXHJcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cclxuICAgICAgLy8gYCdlcnJvcidgIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZC5cclxuICAgICAgLy9cclxuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9wdHMudGltZW91dCkge1xyXG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxW2tBYm9ydGVkXSkgcmV0dXJuO1xyXG5cclxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcclxuICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcclxuICB9KTtcclxuXHJcbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XHJcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBsb2NhdGlvbiAmJlxyXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxyXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxyXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXHJcbiAgICApIHtcclxuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlcS5hYm9ydCgpO1xyXG5cclxuICAgICAgbGV0IGFkZHI7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XHJcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxyXG4gICAgICAgIHdlYnNvY2tldCxcclxuICAgICAgICByZXEsXHJcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXHJcbiAgICAvLyBgJ3VwZ3JhZGUnYCBldmVudC5cclxuICAgIC8vXHJcbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XHJcblxyXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXMuaGVhZGVycy51cGdyYWRlO1xyXG5cclxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xyXG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgVXBncmFkZSBoZWFkZXInKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxyXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXHJcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG5cclxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XHJcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXInKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xyXG4gICAgbGV0IHByb3RFcnJvcjtcclxuXHJcbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xyXG4gICAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xyXG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcclxuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xyXG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcm90RXJyb3IpIHtcclxuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XHJcblxyXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcclxuXHJcbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID1cclxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcclxuICAgICAgICAgICd3YXMgcmVxdWVzdGVkJztcclxuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcclxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1NlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWQnO1xyXG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XHJcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cclxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xyXG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRzLmFsbG93U3luY2hyb25vdXNFdmVudHMsXHJcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXHJcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcclxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcclxuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlcS5lbmQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbWl0IHRoZSBgJ2Vycm9yJ2AgYW5kIGAnY2xvc2UnYCBldmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcclxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcclxuICAvL1xyXG4gIC8vIFRoZSBmb2xsb3dpbmcgYXNzaWdubWVudCBpcyBwcmFjdGljYWxseSB1c2VsZXNzIGFuZCBpcyBkb25lIG9ubHkgZm9yXHJcbiAgLy8gY29uc2lzdGVuY3kuXHJcbiAgLy9cclxuICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XHJcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXHJcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcclxuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XHJcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XHJcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xyXG5cclxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XHJcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcclxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xyXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xyXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG5cclxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XHJcblxyXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XHJcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcclxuICAgIHN0cmVhbS5hYm9ydCgpO1xyXG5cclxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcclxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXHJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxyXG4gICAgICAvL1xyXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XHJcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xyXG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcclxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcclxuICBpZiAoZGF0YSkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gaXNCbG9iKGRhdGEpID8gZGF0YS5zaXplIDogdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXHJcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxyXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXHJcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxyXG4gICAgLy9cclxuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xyXG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcclxuICB9XHJcblxyXG4gIGlmIChjYikge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxyXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xyXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcclxuICAgICk7XHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XHJcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XHJcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xyXG5cclxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XHJcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcclxuXHJcbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xyXG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xyXG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XHJcblxyXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxyXG4gICAgLy9cclxuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XHJcblxyXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xyXG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XHJcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcclxuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XHJcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcclxuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xyXG4gIHN0cmVhbS5yZXN1bWUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNlbmRlck9uRXJyb3IoZXJyKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XHJcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xyXG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XHJcbiAgICBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXHJcbiAgLy8gcGVlciB0byBmaW5pc2ggc2VuZGluZyBxdWV1ZWQgZGF0YS4gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgYSB0aW1lciBoZXJlXHJcbiAgLy8gYmVjYXVzZSBgQ0xPU0lOR2AgbWVhbnMgdGhhdCBpdCBpcyBhbHJlYWR5IHNldCBvciBub3QgbmVlZGVkLlxyXG4gIC8vXHJcbiAgdGhpcy5fc29ja2V0LmVuZCgpO1xyXG5cclxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XHJcbiAgICB3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCA9IHRydWU7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIHRpbWVyIHRvIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgcmF3IHNvY2tldCBvZiBhIFdlYlNvY2tldC5cclxuICpcclxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xyXG4gIHdlYnNvY2tldC5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXHJcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95LmJpbmQod2Vic29ja2V0Ll9zb2NrZXQpLFxyXG4gICAgY2xvc2VUaW1lb3V0XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnY2xvc2UnYCBldmVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XHJcblxyXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG5cclxuICBsZXQgY2h1bms7XHJcblxyXG4gIC8vXHJcbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcclxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXHJcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXHJcbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cclxuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxyXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxyXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxyXG4gIC8vXHJcbiAgaWYgKFxyXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxyXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXHJcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcclxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcclxuICApIHtcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xyXG4gIH1cclxuXHJcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcclxuXHJcbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XHJcblxyXG4gIGlmIChcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXHJcbiAgKSB7XHJcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XHJcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2RhdGEnYCBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XHJcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcclxuICAgIHRoaXMucGF1c2UoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2VuZCdgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XHJcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcclxuXHJcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XHJcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcclxuICB0aGlzLmVuZCgpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcclxuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xyXG5cclxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xyXG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XHJcblxyXG4gIGlmICh3ZWJzb2NrZXQpIHtcclxuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xyXG4gICAgdGhpcy5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ws/lib/websocket.js\n");

/***/ })

};
;