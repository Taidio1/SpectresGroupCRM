"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webidl-conversions";
exports.ids = ["vendor-chunks/webidl-conversions"];
exports.modules = {

/***/ "(rsc)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar conversions = {};\r\nmodule.exports = conversions;\r\n\r\nfunction sign(x) {\r\n    return x < 0 ? -1 : 1;\r\n}\r\n\r\nfunction evenRound(x) {\r\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\r\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\r\n        return Math.floor(x);\r\n    } else {\r\n        return Math.round(x);\r\n    }\r\n}\r\n\r\nfunction createNumberConversion(bitLength, typeOpts) {\r\n    if (!typeOpts.unsigned) {\r\n        --bitLength;\r\n    }\r\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\r\n    const upperBound = Math.pow(2, bitLength) - 1;\r\n\r\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\r\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\r\n\r\n    return function(V, opts) {\r\n        if (!opts) opts = {};\r\n\r\n        let x = +V;\r\n\r\n        if (opts.enforceRange) {\r\n            if (!Number.isFinite(x)) {\r\n                throw new TypeError(\"Argument is not a finite number\");\r\n            }\r\n\r\n            x = sign(x) * Math.floor(Math.abs(x));\r\n            if (x < lowerBound || x > upperBound) {\r\n                throw new TypeError(\"Argument is not in byte range\");\r\n            }\r\n\r\n            return x;\r\n        }\r\n\r\n        if (!isNaN(x) && opts.clamp) {\r\n            x = evenRound(x);\r\n\r\n            if (x < lowerBound) x = lowerBound;\r\n            if (x > upperBound) x = upperBound;\r\n            return x;\r\n        }\r\n\r\n        if (!Number.isFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n\r\n        x = sign(x) * Math.floor(Math.abs(x));\r\n        x = x % moduloVal;\r\n\r\n        if (!typeOpts.unsigned && x >= moduloBound) {\r\n            return x - moduloVal;\r\n        } else if (typeOpts.unsigned) {\r\n            if (x < 0) {\r\n              x += moduloVal;\r\n            } else if (x === -0) { // don't return negative zero\r\n              return 0;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n}\r\n\r\nconversions[\"void\"] = function () {\r\n    return undefined;\r\n};\r\n\r\nconversions[\"boolean\"] = function (val) {\r\n    return !!val;\r\n};\r\n\r\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\r\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\r\n\r\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\r\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\r\n\r\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\r\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\r\n\r\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\r\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\r\n\r\nconversions[\"double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (!Number.isFinite(x)) {\r\n        throw new TypeError(\"Argument is not a finite floating-point value\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"unrestricted double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (isNaN(x)) {\r\n        throw new TypeError(\"Argument is NaN\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\n// not quite valid, but good enough for JS\r\nconversions[\"float\"] = conversions[\"double\"];\r\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\r\n\r\nconversions[\"DOMString\"] = function (V, opts) {\r\n    if (!opts) opts = {};\r\n\r\n    if (opts.treatNullAsEmptyString && V === null) {\r\n        return \"\";\r\n    }\r\n\r\n    return String(V);\r\n};\r\n\r\nconversions[\"ByteString\"] = function (V, opts) {\r\n    const x = String(V);\r\n    let c = undefined;\r\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\r\n        if (c > 255) {\r\n            throw new TypeError(\"Argument is not a valid bytestring\");\r\n        }\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"USVString\"] = function (V) {\r\n    const S = String(V);\r\n    const n = S.length;\r\n    const U = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        const c = S.charCodeAt(i);\r\n        if (c < 0xD800 || c > 0xDFFF) {\r\n            U.push(String.fromCodePoint(c));\r\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\r\n            U.push(String.fromCodePoint(0xFFFD));\r\n        } else {\r\n            if (i === n - 1) {\r\n                U.push(String.fromCodePoint(0xFFFD));\r\n            } else {\r\n                const d = S.charCodeAt(i + 1);\r\n                if (0xDC00 <= d && d <= 0xDFFF) {\r\n                    const a = c & 0x3FF;\r\n                    const b = d & 0x3FF;\r\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\r\n                    ++i;\r\n                } else {\r\n                    U.push(String.fromCodePoint(0xFFFD));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return U.join('');\r\n};\r\n\r\nconversions[\"Date\"] = function (V, opts) {\r\n    if (!(V instanceof Date)) {\r\n        throw new TypeError(\"Argument is not a Date object\");\r\n    }\r\n    if (isNaN(V)) {\r\n        return undefined;\r\n    }\r\n\r\n    return V;\r\n};\r\n\r\nconversions[\"RegExp\"] = function (V, opts) {\r\n    if (!(V instanceof RegExp)) {\r\n        V = new RegExp(V);\r\n    }\r\n\r\n    return V;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLGlFQUFpRSxxQ0FBcUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdlYmlkbC1jb252ZXJzaW9uc1xcbGliXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBjb252ZXJzaW9ucyA9IHt9O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnNpb25zO1xyXG5cclxuZnVuY3Rpb24gc2lnbih4KSB7XHJcbiAgICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV2ZW5Sb3VuZCh4KSB7XHJcbiAgICAvLyBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZSBldmVuIGludGVnZXIgaWYgaXQgbGllcyBoYWxmd2F5IGJldHdlZW4gdHdvLlxyXG4gICAgaWYgKCh4ICUgMSkgPT09IDAuNSAmJiAoeCAmIDEpID09PSAwKSB7IC8vIFtldmVuIG51bWJlcl0uNTsgcm91bmQgZG93biAoaS5lLiBmbG9vcilcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU51bWJlckNvbnZlcnNpb24oYml0TGVuZ3RoLCB0eXBlT3B0cykge1xyXG4gICAgaWYgKCF0eXBlT3B0cy51bnNpZ25lZCkge1xyXG4gICAgICAgIC0tYml0TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG93ZXJCb3VuZCA9IHR5cGVPcHRzLnVuc2lnbmVkID8gMCA6IC1NYXRoLnBvdygyLCBiaXRMZW5ndGgpO1xyXG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxO1xyXG5cclxuICAgIGNvbnN0IG1vZHVsb1ZhbCA9IHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCA/IE1hdGgucG93KDIsIHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCkgOiBNYXRoLnBvdygyLCBiaXRMZW5ndGgpO1xyXG4gICAgY29uc3QgbW9kdWxvQm91bmQgPSB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggPyBNYXRoLnBvdygyLCB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggLSAxKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihWLCBvcHRzKSB7XHJcbiAgICAgICAgaWYgKCFvcHRzKSBvcHRzID0ge307XHJcblxyXG4gICAgICAgIGxldCB4ID0gK1Y7XHJcblxyXG4gICAgICAgIGlmIChvcHRzLmVuZm9yY2VSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZpbml0ZSBudW1iZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHggPSBzaWduKHgpICogTWF0aC5mbG9vcihNYXRoLmFicyh4KSk7XHJcbiAgICAgICAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBpbiBieXRlIHJhbmdlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOYU4oeCkgJiYgb3B0cy5jbGFtcCkge1xyXG4gICAgICAgICAgICB4ID0gZXZlblJvdW5kKHgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kKSB4ID0gbG93ZXJCb3VuZDtcclxuICAgICAgICAgICAgaWYgKHggPiB1cHBlckJvdW5kKSB4ID0gdXBwZXJCb3VuZDtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHNpZ24oeCkgKiBNYXRoLmZsb29yKE1hdGguYWJzKHgpKTtcclxuICAgICAgICB4ID0geCAlIG1vZHVsb1ZhbDtcclxuXHJcbiAgICAgICAgaWYgKCF0eXBlT3B0cy51bnNpZ25lZCAmJiB4ID49IG1vZHVsb0JvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4IC0gbW9kdWxvVmFsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZU9wdHMudW5zaWduZWQpIHtcclxuICAgICAgICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgeCArPSBtb2R1bG9WYWw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gLTApIHsgLy8gZG9uJ3QgcmV0dXJuIG5lZ2F0aXZlIHplcm9cclxuICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnZlcnNpb25zW1widm9pZFwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcImJvb2xlYW5cIl0gPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICByZXR1cm4gISF2YWw7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcImJ5dGVcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcIm9jdGV0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbig4LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJzaG9ydFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMTYsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIHNob3J0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcclxuXHJcbmNvbnZlcnNpb25zW1wibG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJsb25nIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiBmYWxzZSwgbW9kdWxvQml0TGVuZ3RoOiA2NCB9KTtcclxuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBsb25nIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiB0cnVlLCBtb2R1bG9CaXRMZW5ndGg6IDY0IH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJkb3VibGVcIl0gPSBmdW5jdGlvbiAoVikge1xyXG4gICAgY29uc3QgeCA9ICtWO1xyXG5cclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZpbml0ZSBmbG9hdGluZy1wb2ludCB2YWx1ZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGRvdWJsZVwiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCB4ID0gK1Y7XHJcblxyXG4gICAgaWYgKGlzTmFOKHgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIE5hTlwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbi8vIG5vdCBxdWl0ZSB2YWxpZCwgYnV0IGdvb2QgZW5vdWdoIGZvciBKU1xyXG5jb252ZXJzaW9uc1tcImZsb2F0XCJdID0gY29udmVyc2lvbnNbXCJkb3VibGVcIl07XHJcbmNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGZsb2F0XCJdID0gY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZG91YmxlXCJdO1xyXG5cclxuY29udmVyc2lvbnNbXCJET01TdHJpbmdcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XHJcblxyXG4gICAgaWYgKG9wdHMudHJlYXROdWxsQXNFbXB0eVN0cmluZyAmJiBWID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFN0cmluZyhWKTtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiQnl0ZVN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBjb25zdCB4ID0gU3RyaW5nKFYpO1xyXG4gICAgbGV0IGMgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgKGMgPSB4LmNvZGVQb2ludEF0KGkpKSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcclxuICAgICAgICBpZiAoYyA+IDI1NSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgdmFsaWQgYnl0ZXN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIlVTVlN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCBTID0gU3RyaW5nKFYpO1xyXG4gICAgY29uc3QgbiA9IFMubGVuZ3RoO1xyXG4gICAgY29uc3QgVSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjID0gUy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPiAweERGRkYpIHtcclxuICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGMpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKDB4REMwMCA8PSBjICYmIGMgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBTLmNoYXJDb2RlQXQoaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKDB4REMwMCA8PSBkICYmIGQgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGMgJiAweDNGRjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gZCAmIDB4M0ZGO1xyXG4gICAgICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgoMiA8PCAxNSkgKyAoMiA8PCA5KSAqIGEgKyBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFUuam9pbignJyk7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIkRhdGVcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCEoViBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIERhdGUgb2JqZWN0XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTmFOKFYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVjtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiUmVnRXhwXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGlmICghKFYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XHJcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoVik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFY7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar conversions = {};\r\nmodule.exports = conversions;\r\n\r\nfunction sign(x) {\r\n    return x < 0 ? -1 : 1;\r\n}\r\n\r\nfunction evenRound(x) {\r\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\r\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\r\n        return Math.floor(x);\r\n    } else {\r\n        return Math.round(x);\r\n    }\r\n}\r\n\r\nfunction createNumberConversion(bitLength, typeOpts) {\r\n    if (!typeOpts.unsigned) {\r\n        --bitLength;\r\n    }\r\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\r\n    const upperBound = Math.pow(2, bitLength) - 1;\r\n\r\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\r\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\r\n\r\n    return function(V, opts) {\r\n        if (!opts) opts = {};\r\n\r\n        let x = +V;\r\n\r\n        if (opts.enforceRange) {\r\n            if (!Number.isFinite(x)) {\r\n                throw new TypeError(\"Argument is not a finite number\");\r\n            }\r\n\r\n            x = sign(x) * Math.floor(Math.abs(x));\r\n            if (x < lowerBound || x > upperBound) {\r\n                throw new TypeError(\"Argument is not in byte range\");\r\n            }\r\n\r\n            return x;\r\n        }\r\n\r\n        if (!isNaN(x) && opts.clamp) {\r\n            x = evenRound(x);\r\n\r\n            if (x < lowerBound) x = lowerBound;\r\n            if (x > upperBound) x = upperBound;\r\n            return x;\r\n        }\r\n\r\n        if (!Number.isFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n\r\n        x = sign(x) * Math.floor(Math.abs(x));\r\n        x = x % moduloVal;\r\n\r\n        if (!typeOpts.unsigned && x >= moduloBound) {\r\n            return x - moduloVal;\r\n        } else if (typeOpts.unsigned) {\r\n            if (x < 0) {\r\n              x += moduloVal;\r\n            } else if (x === -0) { // don't return negative zero\r\n              return 0;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n}\r\n\r\nconversions[\"void\"] = function () {\r\n    return undefined;\r\n};\r\n\r\nconversions[\"boolean\"] = function (val) {\r\n    return !!val;\r\n};\r\n\r\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\r\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\r\n\r\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\r\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\r\n\r\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\r\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\r\n\r\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\r\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\r\n\r\nconversions[\"double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (!Number.isFinite(x)) {\r\n        throw new TypeError(\"Argument is not a finite floating-point value\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"unrestricted double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (isNaN(x)) {\r\n        throw new TypeError(\"Argument is NaN\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\n// not quite valid, but good enough for JS\r\nconversions[\"float\"] = conversions[\"double\"];\r\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\r\n\r\nconversions[\"DOMString\"] = function (V, opts) {\r\n    if (!opts) opts = {};\r\n\r\n    if (opts.treatNullAsEmptyString && V === null) {\r\n        return \"\";\r\n    }\r\n\r\n    return String(V);\r\n};\r\n\r\nconversions[\"ByteString\"] = function (V, opts) {\r\n    const x = String(V);\r\n    let c = undefined;\r\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\r\n        if (c > 255) {\r\n            throw new TypeError(\"Argument is not a valid bytestring\");\r\n        }\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"USVString\"] = function (V) {\r\n    const S = String(V);\r\n    const n = S.length;\r\n    const U = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        const c = S.charCodeAt(i);\r\n        if (c < 0xD800 || c > 0xDFFF) {\r\n            U.push(String.fromCodePoint(c));\r\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\r\n            U.push(String.fromCodePoint(0xFFFD));\r\n        } else {\r\n            if (i === n - 1) {\r\n                U.push(String.fromCodePoint(0xFFFD));\r\n            } else {\r\n                const d = S.charCodeAt(i + 1);\r\n                if (0xDC00 <= d && d <= 0xDFFF) {\r\n                    const a = c & 0x3FF;\r\n                    const b = d & 0x3FF;\r\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\r\n                    ++i;\r\n                } else {\r\n                    U.push(String.fromCodePoint(0xFFFD));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return U.join('');\r\n};\r\n\r\nconversions[\"Date\"] = function (V, opts) {\r\n    if (!(V instanceof Date)) {\r\n        throw new TypeError(\"Argument is not a Date object\");\r\n    }\r\n    if (isNaN(V)) {\r\n        return undefined;\r\n    }\r\n\r\n    return V;\r\n};\r\n\r\nconversions[\"RegExp\"] = function (V, opts) {\r\n    if (!(V instanceof RegExp)) {\r\n        V = new RegExp(V);\r\n    }\r\n\r\n    return V;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLGlFQUFpRSxxQ0FBcUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3RyZXNHcm91cENSTVxcZGFzaGJvYXJkXFxub2RlX21vZHVsZXNcXHdlYmlkbC1jb252ZXJzaW9uc1xcbGliXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBjb252ZXJzaW9ucyA9IHt9O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnNpb25zO1xyXG5cclxuZnVuY3Rpb24gc2lnbih4KSB7XHJcbiAgICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV2ZW5Sb3VuZCh4KSB7XHJcbiAgICAvLyBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZSBldmVuIGludGVnZXIgaWYgaXQgbGllcyBoYWxmd2F5IGJldHdlZW4gdHdvLlxyXG4gICAgaWYgKCh4ICUgMSkgPT09IDAuNSAmJiAoeCAmIDEpID09PSAwKSB7IC8vIFtldmVuIG51bWJlcl0uNTsgcm91bmQgZG93biAoaS5lLiBmbG9vcilcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU51bWJlckNvbnZlcnNpb24oYml0TGVuZ3RoLCB0eXBlT3B0cykge1xyXG4gICAgaWYgKCF0eXBlT3B0cy51bnNpZ25lZCkge1xyXG4gICAgICAgIC0tYml0TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG93ZXJCb3VuZCA9IHR5cGVPcHRzLnVuc2lnbmVkID8gMCA6IC1NYXRoLnBvdygyLCBiaXRMZW5ndGgpO1xyXG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxO1xyXG5cclxuICAgIGNvbnN0IG1vZHVsb1ZhbCA9IHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCA/IE1hdGgucG93KDIsIHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCkgOiBNYXRoLnBvdygyLCBiaXRMZW5ndGgpO1xyXG4gICAgY29uc3QgbW9kdWxvQm91bmQgPSB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggPyBNYXRoLnBvdygyLCB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggLSAxKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihWLCBvcHRzKSB7XHJcbiAgICAgICAgaWYgKCFvcHRzKSBvcHRzID0ge307XHJcblxyXG4gICAgICAgIGxldCB4ID0gK1Y7XHJcblxyXG4gICAgICAgIGlmIChvcHRzLmVuZm9yY2VSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZpbml0ZSBudW1iZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHggPSBzaWduKHgpICogTWF0aC5mbG9vcihNYXRoLmFicyh4KSk7XHJcbiAgICAgICAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBpbiBieXRlIHJhbmdlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOYU4oeCkgJiYgb3B0cy5jbGFtcCkge1xyXG4gICAgICAgICAgICB4ID0gZXZlblJvdW5kKHgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kKSB4ID0gbG93ZXJCb3VuZDtcclxuICAgICAgICAgICAgaWYgKHggPiB1cHBlckJvdW5kKSB4ID0gdXBwZXJCb3VuZDtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHNpZ24oeCkgKiBNYXRoLmZsb29yKE1hdGguYWJzKHgpKTtcclxuICAgICAgICB4ID0geCAlIG1vZHVsb1ZhbDtcclxuXHJcbiAgICAgICAgaWYgKCF0eXBlT3B0cy51bnNpZ25lZCAmJiB4ID49IG1vZHVsb0JvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4IC0gbW9kdWxvVmFsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZU9wdHMudW5zaWduZWQpIHtcclxuICAgICAgICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgeCArPSBtb2R1bG9WYWw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA9PT0gLTApIHsgLy8gZG9uJ3QgcmV0dXJuIG5lZ2F0aXZlIHplcm9cclxuICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnZlcnNpb25zW1widm9pZFwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcImJvb2xlYW5cIl0gPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICByZXR1cm4gISF2YWw7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcImJ5dGVcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcIm9jdGV0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbig4LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJzaG9ydFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMTYsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIHNob3J0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcclxuXHJcbmNvbnZlcnNpb25zW1wibG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlIH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJsb25nIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiBmYWxzZSwgbW9kdWxvQml0TGVuZ3RoOiA2NCB9KTtcclxuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBsb25nIGxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiB0cnVlLCBtb2R1bG9CaXRMZW5ndGg6IDY0IH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJkb3VibGVcIl0gPSBmdW5jdGlvbiAoVikge1xyXG4gICAgY29uc3QgeCA9ICtWO1xyXG5cclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZpbml0ZSBmbG9hdGluZy1wb2ludCB2YWx1ZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGRvdWJsZVwiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCB4ID0gK1Y7XHJcblxyXG4gICAgaWYgKGlzTmFOKHgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIE5hTlwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbi8vIG5vdCBxdWl0ZSB2YWxpZCwgYnV0IGdvb2QgZW5vdWdoIGZvciBKU1xyXG5jb252ZXJzaW9uc1tcImZsb2F0XCJdID0gY29udmVyc2lvbnNbXCJkb3VibGVcIl07XHJcbmNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGZsb2F0XCJdID0gY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZG91YmxlXCJdO1xyXG5cclxuY29udmVyc2lvbnNbXCJET01TdHJpbmdcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XHJcblxyXG4gICAgaWYgKG9wdHMudHJlYXROdWxsQXNFbXB0eVN0cmluZyAmJiBWID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFN0cmluZyhWKTtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiQnl0ZVN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBjb25zdCB4ID0gU3RyaW5nKFYpO1xyXG4gICAgbGV0IGMgPSB1bmRlZmluZWQ7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgKGMgPSB4LmNvZGVQb2ludEF0KGkpKSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcclxuICAgICAgICBpZiAoYyA+IDI1NSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgdmFsaWQgYnl0ZXN0cmluZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIlVTVlN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCBTID0gU3RyaW5nKFYpO1xyXG4gICAgY29uc3QgbiA9IFMubGVuZ3RoO1xyXG4gICAgY29uc3QgVSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjID0gUy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPiAweERGRkYpIHtcclxuICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGMpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKDB4REMwMCA8PSBjICYmIGMgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBTLmNoYXJDb2RlQXQoaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKDB4REMwMCA8PSBkICYmIGQgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGMgJiAweDNGRjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gZCAmIDB4M0ZGO1xyXG4gICAgICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgoMiA8PCAxNSkgKyAoMiA8PCA5KSAqIGEgKyBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFUuam9pbignJyk7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIkRhdGVcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCEoViBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIERhdGUgb2JqZWN0XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTmFOKFYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVjtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiUmVnRXhwXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGlmICghKFYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XHJcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoVik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFY7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ })

};
;