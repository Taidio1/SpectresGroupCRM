"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webidl-conversions";
exports.ids = ["vendor-chunks/webidl-conversions"];
exports.modules = {

/***/ "(rsc)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar conversions = {};\r\nmodule.exports = conversions;\r\n\r\nfunction sign(x) {\r\n    return x < 0 ? -1 : 1;\r\n}\r\n\r\nfunction evenRound(x) {\r\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\r\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\r\n        return Math.floor(x);\r\n    } else {\r\n        return Math.round(x);\r\n    }\r\n}\r\n\r\nfunction createNumberConversion(bitLength, typeOpts) {\r\n    if (!typeOpts.unsigned) {\r\n        --bitLength;\r\n    }\r\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\r\n    const upperBound = Math.pow(2, bitLength) - 1;\r\n\r\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\r\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\r\n\r\n    return function(V, opts) {\r\n        if (!opts) opts = {};\r\n\r\n        let x = +V;\r\n\r\n        if (opts.enforceRange) {\r\n            if (!Number.isFinite(x)) {\r\n                throw new TypeError(\"Argument is not a finite number\");\r\n            }\r\n\r\n            x = sign(x) * Math.floor(Math.abs(x));\r\n            if (x < lowerBound || x > upperBound) {\r\n                throw new TypeError(\"Argument is not in byte range\");\r\n            }\r\n\r\n            return x;\r\n        }\r\n\r\n        if (!isNaN(x) && opts.clamp) {\r\n            x = evenRound(x);\r\n\r\n            if (x < lowerBound) x = lowerBound;\r\n            if (x > upperBound) x = upperBound;\r\n            return x;\r\n        }\r\n\r\n        if (!Number.isFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n\r\n        x = sign(x) * Math.floor(Math.abs(x));\r\n        x = x % moduloVal;\r\n\r\n        if (!typeOpts.unsigned && x >= moduloBound) {\r\n            return x - moduloVal;\r\n        } else if (typeOpts.unsigned) {\r\n            if (x < 0) {\r\n              x += moduloVal;\r\n            } else if (x === -0) { // don't return negative zero\r\n              return 0;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n}\r\n\r\nconversions[\"void\"] = function () {\r\n    return undefined;\r\n};\r\n\r\nconversions[\"boolean\"] = function (val) {\r\n    return !!val;\r\n};\r\n\r\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\r\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\r\n\r\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\r\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\r\n\r\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\r\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\r\n\r\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\r\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\r\n\r\nconversions[\"double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (!Number.isFinite(x)) {\r\n        throw new TypeError(\"Argument is not a finite floating-point value\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"unrestricted double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (isNaN(x)) {\r\n        throw new TypeError(\"Argument is NaN\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\n// not quite valid, but good enough for JS\r\nconversions[\"float\"] = conversions[\"double\"];\r\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\r\n\r\nconversions[\"DOMString\"] = function (V, opts) {\r\n    if (!opts) opts = {};\r\n\r\n    if (opts.treatNullAsEmptyString && V === null) {\r\n        return \"\";\r\n    }\r\n\r\n    return String(V);\r\n};\r\n\r\nconversions[\"ByteString\"] = function (V, opts) {\r\n    const x = String(V);\r\n    let c = undefined;\r\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\r\n        if (c > 255) {\r\n            throw new TypeError(\"Argument is not a valid bytestring\");\r\n        }\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"USVString\"] = function (V) {\r\n    const S = String(V);\r\n    const n = S.length;\r\n    const U = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        const c = S.charCodeAt(i);\r\n        if (c < 0xD800 || c > 0xDFFF) {\r\n            U.push(String.fromCodePoint(c));\r\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\r\n            U.push(String.fromCodePoint(0xFFFD));\r\n        } else {\r\n            if (i === n - 1) {\r\n                U.push(String.fromCodePoint(0xFFFD));\r\n            } else {\r\n                const d = S.charCodeAt(i + 1);\r\n                if (0xDC00 <= d && d <= 0xDFFF) {\r\n                    const a = c & 0x3FF;\r\n                    const b = d & 0x3FF;\r\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\r\n                    ++i;\r\n                } else {\r\n                    U.push(String.fromCodePoint(0xFFFD));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return U.join('');\r\n};\r\n\r\nconversions[\"Date\"] = function (V, opts) {\r\n    if (!(V instanceof Date)) {\r\n        throw new TypeError(\"Argument is not a Date object\");\r\n    }\r\n    if (isNaN(V)) {\r\n        return undefined;\r\n    }\r\n\r\n    return V;\r\n};\r\n\r\nconversions[\"RegExp\"] = function (V, opts) {\r\n    if (!(V instanceof RegExp)) {\r\n        V = new RegExp(V);\r\n    }\r\n\r\n    return V;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLGlFQUFpRSxxQ0FBcUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd2ViaWRsLWNvbnZlcnNpb25zXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNvbnZlcnNpb25zID0ge307XHJcbm1vZHVsZS5leHBvcnRzID0gY29udmVyc2lvbnM7XHJcblxyXG5mdW5jdGlvbiBzaWduKHgpIHtcclxuICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlblJvdW5kKHgpIHtcclxuICAgIC8vIFJvdW5kIHggdG8gdGhlIG5lYXJlc3QgaW50ZWdlciwgY2hvb3NpbmcgdGhlIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28uXHJcbiAgICBpZiAoKHggJSAxKSA9PT0gMC41ICYmICh4ICYgMSkgPT09IDApIHsgLy8gW2V2ZW4gbnVtYmVyXS41OyByb3VuZCBkb3duIChpLmUuIGZsb29yKVxyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTnVtYmVyQ29udmVyc2lvbihiaXRMZW5ndGgsIHR5cGVPcHRzKSB7XHJcbiAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLS1iaXRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsb3dlckJvdW5kID0gdHlwZU9wdHMudW5zaWduZWQgPyAwIDogLU1hdGgucG93KDIsIGJpdExlbmd0aCk7XHJcbiAgICBjb25zdCB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDE7XHJcblxyXG4gICAgY29uc3QgbW9kdWxvVmFsID0gdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoID8gTWF0aC5wb3coMiwgdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XHJcbiAgICBjb25zdCBtb2R1bG9Cb3VuZCA9IHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCA/IE1hdGgucG93KDIsIHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCAtIDEpIDogTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKFYsIG9wdHMpIHtcclxuICAgICAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcclxuXHJcbiAgICAgICAgbGV0IHggPSArVjtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZW5mb3JjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgZmluaXRlIG51bWJlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeCA9IHNpZ24oeCkgKiBNYXRoLmZsb29yKE1hdGguYWJzKHgpKTtcclxuICAgICAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGluIGJ5dGUgcmFuZ2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc05hTih4KSAmJiBvcHRzLmNsYW1wKSB7XHJcbiAgICAgICAgICAgIHggPSBldmVuUm91bmQoeCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQpIHggPSBsb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBpZiAoeCA+IHVwcGVyQm91bmQpIHggPSB1cHBlckJvdW5kO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0gc2lnbih4KSAqIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkpO1xyXG4gICAgICAgIHggPSB4ICUgbW9kdWxvVmFsO1xyXG5cclxuICAgICAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkICYmIHggPj0gbW9kdWxvQm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHggLSBtb2R1bG9WYWw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlT3B0cy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICAgICAgICB4ICs9IG1vZHVsb1ZhbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh4ID09PSAtMCkgeyAvLyBkb24ndCByZXR1cm4gbmVnYXRpdmUgemVyb1xyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxufVxyXG5cclxuY29udmVyc2lvbnNbXCJ2b2lkXCJdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiYm9vbGVhblwiXSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiAhIXZhbDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiYnl0ZVwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1wib2N0ZXRcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IHRydWUgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcInNob3J0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1widW5zaWduZWQgc2hvcnRcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDE2LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1widW5zaWduZWQgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IHRydWUgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcImxvbmcgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlLCBtb2R1bG9CaXRMZW5ndGg6IDY0IH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIGxvbmcgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IHRydWUsIG1vZHVsb0JpdExlbmd0aDogNjQgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcImRvdWJsZVwiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCB4ID0gK1Y7XHJcblxyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgZmluaXRlIGZsb2F0aW5nLXBvaW50IHZhbHVlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZG91YmxlXCJdID0gZnVuY3Rpb24gKFYpIHtcclxuICAgIGNvbnN0IHggPSArVjtcclxuXHJcbiAgICBpZiAoaXNOYU4oeCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgTmFOXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG59O1xyXG5cclxuLy8gbm90IHF1aXRlIHZhbGlkLCBidXQgZ29vZCBlbm91Z2ggZm9yIEpTXHJcbmNvbnZlcnNpb25zW1wiZmxvYXRcIl0gPSBjb252ZXJzaW9uc1tcImRvdWJsZVwiXTtcclxuY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZmxvYXRcIl0gPSBjb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBkb3VibGVcIl07XHJcblxyXG5jb252ZXJzaW9uc1tcIkRPTVN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcclxuXHJcbiAgICBpZiAob3B0cy50cmVhdE51bGxBc0VtcHR5U3RyaW5nICYmIFYgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gU3RyaW5nKFYpO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJCeXRlU3RyaW5nXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGNvbnN0IHggPSBTdHJpbmcoVik7XHJcbiAgICBsZXQgYyA9IHVuZGVmaW5lZDtcclxuICAgIGZvciAobGV0IGkgPSAwOyAoYyA9IHguY29kZVBvaW50QXQoaSkpICE9PSB1bmRlZmluZWQ7ICsraSkge1xyXG4gICAgICAgIGlmIChjID4gMjU1KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSB2YWxpZCBieXRlc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdID0gZnVuY3Rpb24gKFYpIHtcclxuICAgIGNvbnN0IFMgPSBTdHJpbmcoVik7XHJcbiAgICBjb25zdCBuID0gUy5sZW5ndGg7XHJcbiAgICBjb25zdCBVID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGMgPSBTLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+IDB4REZGRikge1xyXG4gICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoYykpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoMHhEQzAwIDw9IGMgJiYgYyA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IFMuY2hhckNvZGVBdChpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoMHhEQzAwIDw9IGQgJiYgZCA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gYyAmIDB4M0ZGO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBkICYgMHgzRkY7XHJcbiAgICAgICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KCgyIDw8IDE1KSArICgyIDw8IDkpICogYSArIGIpKTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVS5qb2luKCcnKTtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiRGF0ZVwiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgRGF0ZSBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOYU4oVikpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJSZWdFeHBcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCEoViBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcclxuICAgICAgICBWID0gbmV3IFJlZ0V4cChWKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar conversions = {};\r\nmodule.exports = conversions;\r\n\r\nfunction sign(x) {\r\n    return x < 0 ? -1 : 1;\r\n}\r\n\r\nfunction evenRound(x) {\r\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\r\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\r\n        return Math.floor(x);\r\n    } else {\r\n        return Math.round(x);\r\n    }\r\n}\r\n\r\nfunction createNumberConversion(bitLength, typeOpts) {\r\n    if (!typeOpts.unsigned) {\r\n        --bitLength;\r\n    }\r\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\r\n    const upperBound = Math.pow(2, bitLength) - 1;\r\n\r\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\r\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\r\n\r\n    return function(V, opts) {\r\n        if (!opts) opts = {};\r\n\r\n        let x = +V;\r\n\r\n        if (opts.enforceRange) {\r\n            if (!Number.isFinite(x)) {\r\n                throw new TypeError(\"Argument is not a finite number\");\r\n            }\r\n\r\n            x = sign(x) * Math.floor(Math.abs(x));\r\n            if (x < lowerBound || x > upperBound) {\r\n                throw new TypeError(\"Argument is not in byte range\");\r\n            }\r\n\r\n            return x;\r\n        }\r\n\r\n        if (!isNaN(x) && opts.clamp) {\r\n            x = evenRound(x);\r\n\r\n            if (x < lowerBound) x = lowerBound;\r\n            if (x > upperBound) x = upperBound;\r\n            return x;\r\n        }\r\n\r\n        if (!Number.isFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n\r\n        x = sign(x) * Math.floor(Math.abs(x));\r\n        x = x % moduloVal;\r\n\r\n        if (!typeOpts.unsigned && x >= moduloBound) {\r\n            return x - moduloVal;\r\n        } else if (typeOpts.unsigned) {\r\n            if (x < 0) {\r\n              x += moduloVal;\r\n            } else if (x === -0) { // don't return negative zero\r\n              return 0;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n}\r\n\r\nconversions[\"void\"] = function () {\r\n    return undefined;\r\n};\r\n\r\nconversions[\"boolean\"] = function (val) {\r\n    return !!val;\r\n};\r\n\r\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\r\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\r\n\r\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\r\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\r\n\r\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\r\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\r\n\r\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\r\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\r\n\r\nconversions[\"double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (!Number.isFinite(x)) {\r\n        throw new TypeError(\"Argument is not a finite floating-point value\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"unrestricted double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (isNaN(x)) {\r\n        throw new TypeError(\"Argument is NaN\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\n// not quite valid, but good enough for JS\r\nconversions[\"float\"] = conversions[\"double\"];\r\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\r\n\r\nconversions[\"DOMString\"] = function (V, opts) {\r\n    if (!opts) opts = {};\r\n\r\n    if (opts.treatNullAsEmptyString && V === null) {\r\n        return \"\";\r\n    }\r\n\r\n    return String(V);\r\n};\r\n\r\nconversions[\"ByteString\"] = function (V, opts) {\r\n    const x = String(V);\r\n    let c = undefined;\r\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\r\n        if (c > 255) {\r\n            throw new TypeError(\"Argument is not a valid bytestring\");\r\n        }\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"USVString\"] = function (V) {\r\n    const S = String(V);\r\n    const n = S.length;\r\n    const U = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        const c = S.charCodeAt(i);\r\n        if (c < 0xD800 || c > 0xDFFF) {\r\n            U.push(String.fromCodePoint(c));\r\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\r\n            U.push(String.fromCodePoint(0xFFFD));\r\n        } else {\r\n            if (i === n - 1) {\r\n                U.push(String.fromCodePoint(0xFFFD));\r\n            } else {\r\n                const d = S.charCodeAt(i + 1);\r\n                if (0xDC00 <= d && d <= 0xDFFF) {\r\n                    const a = c & 0x3FF;\r\n                    const b = d & 0x3FF;\r\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\r\n                    ++i;\r\n                } else {\r\n                    U.push(String.fromCodePoint(0xFFFD));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return U.join('');\r\n};\r\n\r\nconversions[\"Date\"] = function (V, opts) {\r\n    if (!(V instanceof Date)) {\r\n        throw new TypeError(\"Argument is not a Date object\");\r\n    }\r\n    if (isNaN(V)) {\r\n        return undefined;\r\n    }\r\n\r\n    return V;\r\n};\r\n\r\nconversions[\"RegExp\"] = function (V, opts) {\r\n    if (!(V instanceof RegExp)) {\r\n        V = new RegExp(V);\r\n    }\r\n\r\n    return V;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLGlFQUFpRSxxQ0FBcUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxra2FjcFxcRGVza3RvcFxcU3BlY3Jlc0NSTXYyXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXG5vZGVfbW9kdWxlc1xcd2ViaWRsLWNvbnZlcnNpb25zXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNvbnZlcnNpb25zID0ge307XHJcbm1vZHVsZS5leHBvcnRzID0gY29udmVyc2lvbnM7XHJcblxyXG5mdW5jdGlvbiBzaWduKHgpIHtcclxuICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlblJvdW5kKHgpIHtcclxuICAgIC8vIFJvdW5kIHggdG8gdGhlIG5lYXJlc3QgaW50ZWdlciwgY2hvb3NpbmcgdGhlIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28uXHJcbiAgICBpZiAoKHggJSAxKSA9PT0gMC41ICYmICh4ICYgMSkgPT09IDApIHsgLy8gW2V2ZW4gbnVtYmVyXS41OyByb3VuZCBkb3duIChpLmUuIGZsb29yKVxyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTnVtYmVyQ29udmVyc2lvbihiaXRMZW5ndGgsIHR5cGVPcHRzKSB7XHJcbiAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLS1iaXRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsb3dlckJvdW5kID0gdHlwZU9wdHMudW5zaWduZWQgPyAwIDogLU1hdGgucG93KDIsIGJpdExlbmd0aCk7XHJcbiAgICBjb25zdCB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDE7XHJcblxyXG4gICAgY29uc3QgbW9kdWxvVmFsID0gdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoID8gTWF0aC5wb3coMiwgdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoKSA6IE1hdGgucG93KDIsIGJpdExlbmd0aCk7XHJcbiAgICBjb25zdCBtb2R1bG9Cb3VuZCA9IHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCA/IE1hdGgucG93KDIsIHR5cGVPcHRzLm1vZHVsb0JpdExlbmd0aCAtIDEpIDogTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKFYsIG9wdHMpIHtcclxuICAgICAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcclxuXHJcbiAgICAgICAgbGV0IHggPSArVjtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZW5mb3JjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgZmluaXRlIG51bWJlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeCA9IHNpZ24oeCkgKiBNYXRoLmZsb29yKE1hdGguYWJzKHgpKTtcclxuICAgICAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGluIGJ5dGUgcmFuZ2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc05hTih4KSAmJiBvcHRzLmNsYW1wKSB7XHJcbiAgICAgICAgICAgIHggPSBldmVuUm91bmQoeCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQpIHggPSBsb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBpZiAoeCA+IHVwcGVyQm91bmQpIHggPSB1cHBlckJvdW5kO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0gc2lnbih4KSAqIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkpO1xyXG4gICAgICAgIHggPSB4ICUgbW9kdWxvVmFsO1xyXG5cclxuICAgICAgICBpZiAoIXR5cGVPcHRzLnVuc2lnbmVkICYmIHggPj0gbW9kdWxvQm91bmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHggLSBtb2R1bG9WYWw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlT3B0cy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICAgICAgICB4ICs9IG1vZHVsb1ZhbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh4ID09PSAtMCkgeyAvLyBkb24ndCByZXR1cm4gbmVnYXRpdmUgemVyb1xyXG4gICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxufVxyXG5cclxuY29udmVyc2lvbnNbXCJ2b2lkXCJdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiYm9vbGVhblwiXSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiAhIXZhbDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiYnl0ZVwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1wib2N0ZXRcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDgsIHsgdW5zaWduZWQ6IHRydWUgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcInNob3J0XCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigxNiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1widW5zaWduZWQgc2hvcnRcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDE2LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xyXG5cclxuY29udmVyc2lvbnNbXCJsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XHJcbmNvbnZlcnNpb25zW1widW5zaWduZWQgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IHRydWUgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcImxvbmcgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IGZhbHNlLCBtb2R1bG9CaXRMZW5ndGg6IDY0IH0pO1xyXG5jb252ZXJzaW9uc1tcInVuc2lnbmVkIGxvbmcgbG9uZ1wiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMzIsIHsgdW5zaWduZWQ6IHRydWUsIG1vZHVsb0JpdExlbmd0aDogNjQgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcImRvdWJsZVwiXSA9IGZ1bmN0aW9uIChWKSB7XHJcbiAgICBjb25zdCB4ID0gK1Y7XHJcblxyXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgZmluaXRlIGZsb2F0aW5nLXBvaW50IHZhbHVlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZG91YmxlXCJdID0gZnVuY3Rpb24gKFYpIHtcclxuICAgIGNvbnN0IHggPSArVjtcclxuXHJcbiAgICBpZiAoaXNOYU4oeCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgTmFOXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG59O1xyXG5cclxuLy8gbm90IHF1aXRlIHZhbGlkLCBidXQgZ29vZCBlbm91Z2ggZm9yIEpTXHJcbmNvbnZlcnNpb25zW1wiZmxvYXRcIl0gPSBjb252ZXJzaW9uc1tcImRvdWJsZVwiXTtcclxuY29udmVyc2lvbnNbXCJ1bnJlc3RyaWN0ZWQgZmxvYXRcIl0gPSBjb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBkb3VibGVcIl07XHJcblxyXG5jb252ZXJzaW9uc1tcIkRPTVN0cmluZ1wiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcclxuXHJcbiAgICBpZiAob3B0cy50cmVhdE51bGxBc0VtcHR5U3RyaW5nICYmIFYgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gU3RyaW5nKFYpO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJCeXRlU3RyaW5nXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGNvbnN0IHggPSBTdHJpbmcoVik7XHJcbiAgICBsZXQgYyA9IHVuZGVmaW5lZDtcclxuICAgIGZvciAobGV0IGkgPSAwOyAoYyA9IHguY29kZVBvaW50QXQoaSkpICE9PSB1bmRlZmluZWQ7ICsraSkge1xyXG4gICAgICAgIGlmIChjID4gMjU1KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSB2YWxpZCBieXRlc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiVVNWU3RyaW5nXCJdID0gZnVuY3Rpb24gKFYpIHtcclxuICAgIGNvbnN0IFMgPSBTdHJpbmcoVik7XHJcbiAgICBjb25zdCBuID0gUy5sZW5ndGg7XHJcbiAgICBjb25zdCBVID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGMgPSBTLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+IDB4REZGRikge1xyXG4gICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoYykpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoMHhEQzAwIDw9IGMgJiYgYyA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IFMuY2hhckNvZGVBdChpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoMHhEQzAwIDw9IGQgJiYgZCA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gYyAmIDB4M0ZGO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBkICYgMHgzRkY7XHJcbiAgICAgICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KCgyIDw8IDE1KSArICgyIDw8IDkpICogYSArIGIpKTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVS5qb2luKCcnKTtcclxufTtcclxuXHJcbmNvbnZlcnNpb25zW1wiRGF0ZVwiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgaXMgbm90IGEgRGF0ZSBvYmplY3RcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOYU4oVikpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJSZWdFeHBcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgaWYgKCEoViBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcclxuICAgICAgICBWID0gbmV3IFJlZ0V4cChWKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ })

};
;