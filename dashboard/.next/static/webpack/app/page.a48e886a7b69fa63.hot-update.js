"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activityLogsApi: () => (/* binding */ activityLogsApi),\n/* harmony export */   authApi: () => (/* binding */ authApi),\n/* harmony export */   callsApi: () => (/* binding */ callsApi),\n/* harmony export */   clientsApi: () => (/* binding */ clientsApi),\n/* harmony export */   csvImportApi: () => (/* binding */ csvImportApi),\n/* harmony export */   dashboardApi: () => (/* binding */ dashboardApi),\n/* harmony export */   getAvatarUrl: () => (/* binding */ getAvatarUrl),\n/* harmony export */   getCanvasClientsWithPriority: () => (/* binding */ getCanvasClientsWithPriority),\n/* harmony export */   getCanvasStatusColor: () => (/* binding */ getCanvasStatusColor),\n/* harmony export */   locationsApi: () => (/* binding */ locationsApi),\n/* harmony export */   notificationsApi: () => (/* binding */ notificationsApi),\n/* harmony export */   performanceApi: () => (/* binding */ performanceApi),\n/* harmony export */   permissionsApi: () => (/* binding */ permissionsApi),\n/* harmony export */   reportsApi: () => (/* binding */ reportsApi),\n/* harmony export */   storageApi: () => (/* binding */ storageApi),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   teamApi: () => (/* binding */ teamApi)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabaseUrl = \"https://pkhuggdkcglicghgxiyp.supabase.co\" || 0;\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBraHVnZ2RrY2dsaWNnaGd4aXlwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk5MTEwNzEsImV4cCI6MjA2NTQ4NzA3MX0.LbWtb-modRDlvnkGF5IswRHe1lJpd4zCMgkQ3_E0QQk\" || 0;\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Funkcja pomocnicza do generowania poprawnych URL-i avatarów z Supabase Storage\nconst getAvatarUrl = (avatarUrl)=>{\n    if (!avatarUrl) return null;\n    // Jeśli to już pełny URL (zaczyna się od http), zwróć bez zmian\n    if (avatarUrl.startsWith('http')) {\n        return avatarUrl;\n    }\n    // Jeśli to ścieżka w bucket'u (zawiera folder), wygeneruj publiczny URL\n    if (avatarUrl.includes('/')) {\n        try {\n            const { data } = supabase.storage.from('avatars').getPublicUrl(avatarUrl);\n            return data.publicUrl;\n        } catch (error) {\n            console.error('Błąd generowania URL avatara:', error);\n            return null;\n        }\n    }\n    // Fallback - prawdopodobnie niepoprawny format\n    console.warn('Nierozpoznany format avatar_url:', avatarUrl);\n    return null;\n};\n// Storage API dla plików CSV\nconst storageApi = {\n    // Upload pliku CSV do bucket\n    async uploadCSV (file, user) {\n        try {\n            // Oczyszczenie nazwy pliku z problematycznych znaków\n            const cleanFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_') // Zastąp wszystkie znaki specjalne podkreśleniami\n            .replace(/_{2,}/g, '_') // Zamień wielokrotne podkreślenia na pojedyncze\n            .replace(/^_+|_+$/g, '') // Usuń podkreślenia z początku i końca\n            .toLowerCase() // Małe litery dla consistency\n            ;\n            const fileName = \"\".concat(user.id, \"_\").concat(Date.now(), \"_\").concat(cleanFileName);\n            const filePath = \"csv-imports/\".concat(fileName);\n            console.log(\"\\uD83D\\uDCC1 Uploading CSV: \".concat(filePath));\n            console.log(\"\\uD83D\\uDCC1 Original filename: \".concat(file.name));\n            console.log(\"\\uD83D\\uDCC1 Cleaned filename: \".concat(cleanFileName));\n            const { data, error } = await supabase.storage.from('csv-files').upload(filePath, file, {\n                cacheControl: '3600',\n                upsert: false\n            });\n            if (error) {\n                console.error('❌ Storage upload error:', error);\n                throw new Error(\"Błąd uploadu: \".concat(error.message));\n            }\n            console.log('✅ File uploaded successfully:', data.path);\n            return data.path;\n        } catch (error) {\n            console.error('❌ Upload failed:', error);\n            throw error;\n        }\n    },\n    // Pobierz publiczny URL pliku\n    getPublicUrl (path) {\n        const { data } = supabase.storage.from('csv-files').getPublicUrl(path);\n        return data.publicUrl;\n    },\n    // Usuń plik z bucket\n    async deleteFile (path) {\n        const { error } = await supabase.storage.from('csv-files').remove([\n            path\n        ]);\n        if (error) {\n            console.error('❌ File deletion error:', error);\n            throw new Error(\"Błąd usuwania pliku: \".concat(error.message));\n        }\n    }\n};\n// CSV Import API\nconst csvImportApi = {\n    // Parsuj CSV i zwróć dane\n    parseCSV (csvText) {\n        const lines = csvText.split('\\n').filter((line)=>line.trim() !== '');\n        if (lines.length < 2) {\n            throw new Error('Plik CSV jest pusty lub zawiera tylko nagłówki');\n        }\n        // Parsowanie z obsługą cudzysłowów\n        const parseCSVLine = (line)=>{\n            const result = [];\n            let current = '';\n            let inQuotes = false;\n            for(let i = 0; i < line.length; i++){\n                const char = line[i];\n                if (char === '\"') {\n                    inQuotes = !inQuotes;\n                } else if (char === ',' && !inQuotes) {\n                    result.push(current.trim());\n                    current = '';\n                } else {\n                    current += char;\n                }\n            }\n            result.push(current.trim());\n            return result.map((cell)=>cell.replace(/^\"|\"$/g, '')) // Usuń cudzysłowy\n            ;\n        };\n        const headers = parseCSVLine(lines[0]);\n        const rows = lines.slice(1).map(parseCSVLine);\n        return {\n            headers,\n            rows\n        };\n    },\n    // Mapuj nagłówki CSV na pola bazy danych\n    mapHeaders (headers) {\n        const mapping = {};\n        const fieldMappings = [\n            {\n                fields: [\n                    'first_name',\n                    'imię',\n                    'name',\n                    'firstName'\n                ],\n                dbField: 'first_name'\n            },\n            {\n                fields: [\n                    'last_name',\n                    'nazwisko',\n                    'surname',\n                    'lastName'\n                ],\n                dbField: 'last_name'\n            },\n            {\n                fields: [\n                    'company_name',\n                    'firma',\n                    'company',\n                    'companyName',\n                    'nazwa'\n                ],\n                dbField: 'company_name'\n            },\n            {\n                fields: [\n                    'nip',\n                    'tax_id',\n                    'taxId'\n                ],\n                dbField: 'nip'\n            },\n            {\n                fields: [\n                    'phone',\n                    'telefon',\n                    'telephone'\n                ],\n                dbField: 'phone'\n            },\n            {\n                fields: [\n                    'email',\n                    'e-mail',\n                    'mail'\n                ],\n                dbField: 'email'\n            },\n            {\n                fields: [\n                    'website',\n                    'www',\n                    'strona',\n                    'url'\n                ],\n                dbField: 'website'\n            },\n            {\n                fields: [\n                    'notes',\n                    'notatka',\n                    'note',\n                    'comment'\n                ],\n                dbField: 'notes'\n            },\n            {\n                fields: [\n                    'status'\n                ],\n                dbField: 'status'\n            }\n        ];\n        for (const fieldMapping of fieldMappings){\n            for(let i = 0; i < headers.length; i++){\n                const header = headers[i].toLowerCase().trim();\n                if (fieldMapping.fields.some((field)=>header.includes(field))) {\n                    mapping[fieldMapping.dbField] = i;\n                    break;\n                }\n            }\n        }\n        return mapping;\n    },\n    // Waliduj wymagane pola\n    validateRequiredFields (mapping) {\n        const requiredFields = [\n            'company_name'\n        ];\n        const missingFields = requiredFields.filter((field)=>!(field in mapping));\n        if (missingFields.length > 0) {\n            throw new Error(\"Brak wymaganych kolumn: \".concat(missingFields.join(', '), \". Wymagane: Firma/Nazwa\"));\n        }\n    },\n    // Sprawdź dostępne kolumny i pokaż informacje\n    analyzeColumns (mapping, headers) {\n        const allPossibleFields = [\n            {\n                field: 'first_name',\n                displayName: 'Imię',\n                required: false\n            },\n            {\n                field: 'last_name',\n                displayName: 'Nazwisko',\n                required: false\n            },\n            {\n                field: 'company_name',\n                displayName: 'Firma/Nazwa',\n                required: true\n            },\n            {\n                field: 'phone',\n                displayName: 'Telefon',\n                required: false\n            },\n            {\n                field: 'email',\n                displayName: 'Email',\n                required: false\n            },\n            {\n                field: 'nip',\n                displayName: 'NIP',\n                required: false\n            },\n            {\n                field: 'website',\n                displayName: 'Strona WWW',\n                required: false\n            },\n            {\n                field: 'notes',\n                displayName: 'Notatki',\n                required: false\n            },\n            {\n                field: 'status',\n                displayName: 'Status',\n                required: false\n            }\n        ];\n        const found = [];\n        const missing = [];\n        const optional = [];\n        allPossibleFields.forEach((param)=>{\n            let { field, displayName, required } = param;\n            if (field in mapping) {\n                found.push(displayName);\n            } else if (required) {\n                missing.push(displayName);\n            } else {\n                optional.push(displayName);\n            }\n        });\n        return {\n            found,\n            missing,\n            optional\n        };\n    },\n    // Przekształć wiersz CSV na obiekt klienta\n    rowToClient (row, mapping, user, locationId) {\n        const getField = function(field) {\n            let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'brak informacji';\n            const index = mapping[field];\n            if (index === undefined) {\n                return defaultValue;\n            }\n            const value = (row[index] || '').trim();\n            return value === '' ? defaultValue : value;\n        };\n        // Walidacja statusu\n        const rawStatus = getField('status', 'canvas').toLowerCase();\n        const validStatuses = [\n            'canvas',\n            'brak_kontaktu',\n            'nie_zainteresowany',\n            'zdenerwowany',\n            'antysale',\n            'sale',\n            '$$'\n        ];\n        const status = validStatuses.includes(rawStatus) ? rawStatus : 'canvas';\n        return {\n            first_name: getField('first_name'),\n            last_name: getField('last_name'),\n            company_name: getField('company_name', ''),\n            nip: getField('nip'),\n            phone: getField('phone'),\n            email: getField('email'),\n            website: getField('website'),\n            notes: getField('notes'),\n            status,\n            edited_by: user.id,\n            edited_at: new Date().toISOString(),\n            owner_id: user.id,\n            location_id: locationId || user.location_id,\n            last_edited_by_name: user.full_name,\n            last_edited_by_avatar_url: user.avatar_url\n        };\n    },\n    // Import pełnego CSV do bazy danych\n    async importCSV (file, user, locationId, onProgress) {\n        try {\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 0,\n                total: 100,\n                status: 'Uploading pliku...'\n            });\n            // 1. Upload pliku do Storage\n            const filePath = await storageApi.uploadCSV(file, user);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 20,\n                total: 100,\n                status: 'Parsowanie CSV...'\n            });\n            // 2. Czytanie i parsowanie CSV\n            const csvText = await file.text();\n            const { headers, rows } = csvImportApi.parseCSV(csvText);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 40,\n                total: 100,\n                status: 'Mapowanie kolumn...'\n            });\n            // 3. Mapowanie nagłówków\n            const mapping = csvImportApi.mapHeaders(headers);\n            csvImportApi.validateRequiredFields(mapping);\n            // 4. Analiza dostępnych kolumn\n            const columnAnalysis = csvImportApi.analyzeColumns(mapping, headers);\n            console.log('📊 CSV Headers:', headers);\n            console.log('📊 Field mapping:', mapping);\n            console.log('📊 Rows to import:', rows.length);\n            console.log('✅ Znalezione kolumny:', columnAnalysis.found);\n            console.log('❌ Brakujące wymagane:', columnAnalysis.missing);\n            console.log('⚪ Opcjonalne (będą \"brak informacji\"):', columnAnalysis.optional);\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 50,\n                total: 100,\n                status: \"Importowanie \".concat(rows.length, \" klient\\xf3w...\")\n            });\n            // 4. Import wierszy do bazy\n            const results = {\n                success: 0,\n                errors: []\n            };\n            for(let i = 0; i < rows.length; i++){\n                try {\n                    const row = rows[i];\n                    // Sprawdź czy wiersz nie jest pusty\n                    if (row.every((cell)=>cell.trim() === '')) {\n                        continue;\n                    }\n                    const clientData = csvImportApi.rowToClient(row, mapping, user, locationId);\n                    // Walidacja podstawowych danych\n                    if (!clientData.company_name || clientData.company_name.trim() === '') {\n                        results.errors.push({\n                            row: i + 2,\n                            error: 'Brak wymaganych danych: firma/nazwa',\n                            data: row\n                        });\n                        continue;\n                    }\n                    // Dodaj klienta do bazy\n                    await clientsApi.createClient(clientData, user);\n                    results.success++;\n                    // Aktualizuj progress\n                    const progress = 50 + Math.floor(i / rows.length * 40);\n                    onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                        current: progress,\n                        total: 100,\n                        status: \"Zaimportowano \".concat(results.success, \"/\").concat(rows.length, \" klient\\xf3w\")\n                    });\n                } catch (error) {\n                    console.error(\"❌ Błąd importu wiersza \".concat(i + 2, \":\"), error);\n                    results.errors.push({\n                        row: i + 2,\n                        error: error instanceof Error ? error.message : 'Nieznany błąd',\n                        data: rows[i]\n                    });\n                }\n            }\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 95,\n                total: 100,\n                status: 'Finalizowanie...'\n            });\n            // 5. Opcjonalnie usuń plik z Storage (lub zachowaj dla historii)\n            // await storageApi.deleteFile(filePath)\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress({\n                current: 100,\n                total: 100,\n                status: 'Zakończono!'\n            });\n            console.log(\"✅ Import zakończony: \".concat(results.success, \" sukces, \").concat(results.errors.length, \" błęd\\xf3w\"));\n            return results;\n        } catch (error) {\n            console.error('❌ CSV Import failed:', error);\n            throw error;\n        }\n    }\n};\n// Funkcje sprawdzania uprawnień z hierarchią i lokalizacją\nconst permissionsApi = {\n    // Sprawdź czy użytkownik może widzieć klienta (zgodnie z RLS)\n    canView: (client, user)=>{\n        // Szef i admin widzą wszystko\n        if ([\n            'szef',\n            'admin'\n        ].includes(user.role)) {\n            return true;\n        }\n        // Sprawdź czy klient jest w tej samej lokalizacji co użytkownik\n        const sameLocation = client.location_id === user.location_id;\n        if (!sameLocation) {\n            return false;\n        }\n        switch(user.role){\n            case 'pracownik':\n                // Pracownik widzi tylko swoich klientów w swojej lokalizacji\n                return client.owner_id === user.id || client.owner_id === null || client.edited_by === user.id;\n            case 'junior_manager':\n            case 'manager':\n            case 'project_manager':\n                // Menedżerowie widzą wszystkich klientów w swojej lokalizacji\n                return true;\n            default:\n                return false;\n        }\n    },\n    // Sprawdź czy użytkownik może edytować klienta\n    canEdit: (client, user)=>{\n        // Takie same reguły jak canView\n        return permissionsApi.canView(client, user);\n    },\n    // Sprawdź czy użytkownik może usunąć klienta\n    canDelete: (client, user)=>{\n        // Szef i admin mogą usuwać wszystko\n        if ([\n            'szef',\n            'admin'\n        ].includes(user.role)) {\n            return true;\n        }\n        // Menedżerowie mogą usuwać w swojej lokalizacji\n        if ([\n            'manager',\n            'project_manager',\n            'junior_manager'\n        ].includes(user.role)) {\n            return client.location_id === user.location_id;\n        }\n        // Pracownicy nie mogą usuwać\n        return false;\n    },\n    // Sprawdź czy użytkownik może przypisywać klientów\n    canAssignClients: (user)=>{\n        return [\n            'manager',\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(user.role);\n    },\n    // Sprawdź czy użytkownik może zmieniać role innych użytkowników\n    canChangeRoles: (user)=>{\n        return [\n            'szef',\n            'admin'\n        ].includes(user.role);\n    },\n    // Sprawdź czy użytkownik może dostęp do zaawansowanych raportów\n    canAccessAdvancedReports: (user)=>{\n        return [\n            'manager',\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(user.role);\n    },\n    // Sprawdź czy użytkownik może widzieć wszystkie lokalizacje\n    canViewAllLocations: (user)=>{\n        return [\n            'szef',\n            'admin'\n        ].includes(user.role);\n    },\n    // Sprawdź czy użytkownik może filtrować po lokalizacjach\n    canFilterByLocation: (user)=>{\n        return [\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(user.role);\n    },\n    // Sprawdź poziom hierarchii - czy user1 może zarządzać user2\n    canManageUser: (user1, user2)=>{\n        // Admin może zarządzać wszystkimi\n        if (user1.role === 'admin') return true;\n        // Szef może zarządzać wszystkimi oprócz adminów\n        if (user1.role === 'szef' && user2.role !== 'admin') return true;\n        // Inni mogą zarządzać tylko podwładnymi w tej samej lokalizacji\n        const sameLocation = user1.location_id === user2.location_id;\n        const higherInHierarchy = (user1.role_hierarchy_level || 99) < (user2.role_hierarchy_level || 99);\n        return sameLocation && higherInHierarchy;\n    }\n};\n// Funkcje API dla klientów z systemem uprawnień\nconst clientsApi = {\n    // Funkcja testowa - podstawowe zapytanie do klientów\n    async testBasicQuery () {\n        try {\n            console.log('🔍 Testowe zapytanie do tabeli clients...');\n            const { data, error } = await supabase.from('clients').select('*').limit(5);\n            console.log('Wynik testu - data:', data);\n            console.log('Wynik testu - error:', error);\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            console.error('Błąd testowego zapytania:', error);\n            return {\n                data: null,\n                error\n            };\n        }\n    },\n    // Pobierz klientów z filtrami uprawnień\n    // 🚀 NOWE: Funkcja z paginacją zwracająca obiekt z metadanymi\n    async getClientsPaginated (user, filters) {\n        try {\n            console.log('🔄 Rozpoczynam pobieranie klientów dla użytkownika:', user.id, user.role);\n            // Użyj JOIN aby pobrać klientów z danymi właścicieli i lokalizacji w jednym zapytaniu\n            // 🚀 OPTYMALIZACJA: Wybierz tylko niezbędne pola + lokalizacja + reminder\n            let query = supabase.from('clients').select(\"\\n          id,\\n          first_name,\\n          last_name,\\n          company_name,\\n          nip,\\n          phone,\\n          email,\\n          website,\\n          status,\\n          notes,\\n          reminder,\\n          owner_id,\\n          location_id,\\n          edited_by,\\n          edited_at,\\n          created_at,\\n          updated_at,\\n          status_changed_at,\\n          last_phone_click,\\n          last_edited_by_name,\\n          last_edited_by_avatar_url,\\n          owner:users!owner_id (\\n            id,\\n            full_name,\\n            email,\\n            avatar_url\\n          ),\\n          location:locations!location_id (\\n            id,\\n            name,\\n            code,\\n            currency,\\n            timezone\\n          )\\n        \", {\n                count: 'exact'\n            });\n            // 🚀 SORTOWANIE: Obsługa dynamicznego sortowania\n            const sortField = (filters === null || filters === void 0 ? void 0 : filters.sortBy) || 'updated_at';\n            const isAscending = (filters === null || filters === void 0 ? void 0 : filters.sortDirection) === 'asc';\n            query = query.order(sortField, {\n                ascending: isAscending\n            });\n            // Dodatkowe filtry\n            if (filters === null || filters === void 0 ? void 0 : filters.date) {\n                query = query.gte('updated_at', filters.date);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.status) {\n                query = query.eq('status', filters.status);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.employee) {\n                query = query.eq('edited_by', filters.employee);\n            }\n            // 🚀 NOWE: Filtr wyszukiwania\n            if (filters === null || filters === void 0 ? void 0 : filters.search) {\n                const searchTerm = filters.search.toLowerCase();\n                query = query.or(\"first_name.ilike.%\".concat(searchTerm, \"%,last_name.ilike.%\").concat(searchTerm, \"%,company_name.ilike.%\").concat(searchTerm, \"%,phone.ilike.%\").concat(searchTerm, \"%,email.ilike.%\").concat(searchTerm, \"%\"));\n            }\n            // 🚀 NOWE: Filtr lokalizacji\n            if (filters === null || filters === void 0 ? void 0 : filters.location) {\n                query = query.eq('location_id', filters.location);\n            }\n            // 🚀 NOWE: Paginacja\n            if ((filters === null || filters === void 0 ? void 0 : filters.page) && (filters === null || filters === void 0 ? void 0 : filters.pageSize)) {\n                const from = (filters.page - 1) * filters.pageSize;\n                const to = from + filters.pageSize - 1;\n                query = query.range(from, to);\n                console.log(\"\\uD83D\\uDCC4 Paginacja: strona \".concat(filters.page, \", rozmiar \").concat(filters.pageSize, \", zakres: \").concat(from, \"-\").concat(to));\n            }\n            console.log('🔄 Wykonuję zapytanie z JOIN i liczeniem...');\n            const { data: clients, error, count } = await query;\n            if (error) {\n                console.error('❌ Błąd zapytania clients:', error);\n                throw error;\n            }\n            if (!clients || clients.length === 0) {\n                console.log('ℹ️ Brak klientów w bazie danych');\n                return {\n                    clients: [],\n                    total: 0,\n                    page: (filters === null || filters === void 0 ? void 0 : filters.page) || 1,\n                    pageSize: (filters === null || filters === void 0 ? void 0 : filters.pageSize) || 0\n                };\n            }\n            // Przekształć dane - Supabase JOIN zwraca owner i location jako tablice, ale potrzebujemy pojedynczych obiektów\n            const transformedClients = clients.map((client)=>({\n                    ...client,\n                    owner: client.owner && Array.isArray(client.owner) && client.owner.length > 0 ? client.owner[0] // Weź pierwszy element z tablicy\n                     : client.owner && !Array.isArray(client.owner) ? client.owner // Już jest pojedynczym obiektem\n                     : null,\n                    location: client.location && Array.isArray(client.location) && client.location.length > 0 ? client.location[0] // Weź pierwszy element z tablicy\n                     : client.location && !Array.isArray(client.location) ? client.location // Już jest pojedynczym obiektem\n                     : null // Brak lokalizacji\n                }));\n            // DEBUG: Sprawdź dane właścicieli\n            const clientsWithOwners = transformedClients.filter((client)=>client.owner);\n            const clientsWithoutOwners = transformedClients.filter((client)=>!client.owner);\n            console.log('✅ Klienci z właścicielami:', clientsWithOwners.length);\n            console.log('❌ Klienci bez właścicieli:', clientsWithoutOwners.length);\n            if (clientsWithOwners.length > 0) {\n                var _clientsWithOwners__owner, _clientsWithOwners__owner1;\n                console.log('👤 Przykład klienta z właścicielem:', {\n                    client: \"\".concat(clientsWithOwners[0].first_name, \" \").concat(clientsWithOwners[0].last_name),\n                    owner_id: clientsWithOwners[0].owner_id,\n                    owner_name: (_clientsWithOwners__owner = clientsWithOwners[0].owner) === null || _clientsWithOwners__owner === void 0 ? void 0 : _clientsWithOwners__owner.full_name,\n                    owner_email: (_clientsWithOwners__owner1 = clientsWithOwners[0].owner) === null || _clientsWithOwners__owner1 === void 0 ? void 0 : _clientsWithOwners__owner1.email\n                });\n            }\n            // 🚀 NOWE: Zwróć dane z informacją o paginacji\n            return {\n                clients: transformedClients,\n                total: count || transformedClients.length,\n                page: (filters === null || filters === void 0 ? void 0 : filters.page) || 1,\n                pageSize: (filters === null || filters === void 0 ? void 0 : filters.pageSize) || transformedClients.length\n            };\n        } catch (error) {\n            console.error('❌ Błąd w getClientsPaginated:', error);\n            throw error;\n        }\n    },\n    // 🔄 KOMPATYBILNOŚĆ: Stara funkcja zwracająca tylko tablicę klientów\n    async getClients (user, filters) {\n        try {\n            const result = await this.getClientsPaginated(user, filters);\n            return result.clients;\n        } catch (error) {\n            console.error('❌ Błąd w getClients:', error);\n            throw error;\n        }\n    },\n    // Dodaj nowego klienta z automatycznym przypisaniem właściciela\n    async createClient (client, user) {\n        // ZABEZPIECZENIE: Upewnij się że status nie jest pusty\n        const safeStatus = client.status || 'canvas';\n        const clientToCreate = {\n            ...client,\n            status: safeStatus,\n            owner_id: user.id,\n            location_id: client.location_id || user.location_id,\n            edited_by: user.id,\n            last_edited_by_name: user.full_name,\n            last_edited_by_avatar_url: user.avatar_url,\n            // Jeśli status to \"canvas\", ustaw status_changed_at\n            ...safeStatus === 'canvas' && {\n                status_changed_at: new Date().toISOString()\n            },\n            // Konwertuj undefined reminder na null dla bazy danych\n            reminder: client.reminder || null\n        };\n        console.log('📊 Tworzenie klienta z danymi:', clientToCreate);\n        const { data, error } = await supabase.from('clients').insert([\n            clientToCreate\n        ]).select().single();\n        if (error) {\n            console.error('❌ Błąd createClient:', error);\n            throw error;\n        }\n        return data;\n    },\n    // Zaktualizuj klienta z sprawdzeniem uprawnień\n    async updateClient (id, updates, user) {\n        try {\n            console.log('🔄 updateClient START:', {\n                id,\n                updates,\n                user: user.email\n            });\n            // Pobierz aktualny stan klienta aby sprawdzić czy status się zmienia\n            const { data: currentClient, error: fetchError } = await supabase.from('clients').select('status, owner_id').eq('id', id).single();\n            if (fetchError) {\n                console.error('❌ Błąd pobierania aktualnego klienta:', fetchError);\n                throw new Error(\"Nie można pobrać aktualnego stanu klienta: \".concat(fetchError.message));\n            }\n            console.log('✅ Aktualny stan klienta:', currentClient);\n            // NOWA LOGIKA: Każda osoba która edytuje klienta zostaje jego właścicielem\n            let updatedData = {\n                ...updates\n            };\n            // ZABEZPIECZENIE: Jeśli status jest w aktualizacji, upewnij się że nie jest pusty\n            if ('status' in updatedData && !updatedData.status) {\n                console.log('⚠️ UWAGA: Pusty status w aktualizacji - ustawiam domyślny \"canvas\"');\n                updatedData.status = 'canvas';\n            }\n            // Sprawdź czy status się zmienia\n            const statusChanged = updatedData.status && updatedData.status !== currentClient.status;\n            if (statusChanged) {\n                updatedData.status_changed_at = new Date().toISOString();\n                console.log('\\uD83D\\uDCCA Status zmieniony z \"'.concat(currentClient.status, '\" na \"').concat(updates.status, '\" - ustawiam status_changed_at'));\n                // Powiadomienie o zmianie na canvas\n                if (updates.status === 'canvas') {\n                    console.log('🔔 POWIADOMIENIE: Klient przeszedł na status CANVAS - start trackingu czasu!');\n                }\n            }\n            // Zawsze przypisz edytującego jako właściciela\n            updatedData.owner_id = user.id;\n            console.log(\"\\uD83C\\uDFAF Przypisuję klienta \".concat(id, \" do użytkownika \").concat(user.id, \" (\").concat(user.email, \") jako właściciela\"));\n            // Zapisz informacje o edytorze (szczególnie ważne dla pracowników)\n            updatedData.last_edited_by_name = user.full_name;\n            updatedData.last_edited_by_avatar_url = user.avatar_url;\n            console.log(\"\\uD83D\\uDC64 Zapisuję dane edytora: \".concat(user.full_name, \" (rola: \").concat(user.role, \")\"));\n            // Jeśli to pracownik i zmienia status - dodatkowy log\n            if (user.role === 'pracownik' && statusChanged) {\n                console.log(\"\\uD83D\\uDC77 Pracownik \".concat(user.email, ' zmienia status z \"').concat(currentClient.status, '\" na \"').concat(updates.status, '\"'));\n            }\n            console.log('🔄 Dane do aktualizacji:', updatedData);\n            // Przygotuj finalne dane do UPDATE\n            const finalData = {\n                ...updatedData,\n                edited_by: user.id,\n                updated_at: new Date().toISOString(),\n                // Konwertuj undefined reminder na null dla bazy danych\n                ...updatedData.reminder !== undefined && {\n                    reminder: updatedData.reminder || null\n                }\n            };\n            console.log('🔄 Finalne dane do UPDATE:', finalData);\n            // Bezpośrednia aktualizacja\n            const { data, error } = await supabase.from('clients').update(finalData).eq('id', id).select().single();\n            if (error) {\n                console.error('❌ Błąd UPDATE clients:', error);\n                console.error('❌ Kod błędu:', error.code);\n                console.error('❌ Szczegóły:', error.details);\n                console.error('❌ Hint:', error.hint);\n                throw new Error(\"Błąd aktualizacji: \".concat(error.message, \" (kod: \").concat(error.code, \")\"));\n            }\n            console.log('✅ updateClient SUCCESS:', data);\n            return data;\n        } catch (error) {\n            console.error('❌ updateClient FAILED:', error);\n            throw error;\n        }\n    },\n    // Aktualizuj czas ostatniego kliknięcia telefonu\n    async updateLastPhoneClick (clientId, user) {\n        console.log('📞 Aktualizuję czas ostatniego kliknięcia telefonu:', clientId);\n        const { data, error } = await supabase.from('clients').update({\n            last_phone_click: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        }).eq('id', clientId).select().single();\n        if (error) {\n            console.error('❌ Błąd updateLastPhoneClick:', error);\n            throw error;\n        }\n        // Zaloguj w activity_logs\n        try {\n            await activityLogsApi.createLog({\n                client_id: clientId,\n                changed_by: user.id,\n                change_type: 'update',\n                field_changed: 'last_phone_click',\n                old_value: undefined,\n                new_value: data.last_phone_click\n            });\n        } catch (logError) {\n            console.error('❌ Błąd logowania activity_logs (updateLastPhoneClick):', logError);\n        }\n        return data;\n    },\n    // Usuń klienta z sprawdzeniem uprawnień\n    async deleteClient (id, user) {\n        // Bezpośrednie usunięcie bez sprawdzania uprawnień\n        const { error } = await supabase.from('clients').delete().eq('id', id);\n        if (error) throw error;\n    },\n    // Przypisz klienta do innego użytkownika (tylko manager+)\n    async assignClient (clientId, newOwnerId, user) {\n        if (!permissionsApi.canAssignClients(user)) {\n            throw new Error('Brak uprawnień do przypisywania klientów');\n        }\n        const { data, error } = await supabase.from('clients').update({\n            owner_id: newOwnerId,\n            edited_by: user.id,\n            updated_at: new Date().toISOString()\n        }).eq('id', clientId).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Funkcja do czyszczenia nieistniejących owner_id\n    async cleanupInvalidOwnerIds () {\n        try {\n            console.log('🧹 Rozpoczynam czyszczenie nieistniejących owner_id...');\n            // Pobierz wszystkich klientów z owner_id\n            const { data: allClients, error: clientsError } = await supabase.from('clients').select('id, owner_id, first_name, last_name').not('owner_id', 'is', null);\n            if (clientsError) throw clientsError;\n            console.log('📊 Znaleziono klientów z owner_id:', (allClients === null || allClients === void 0 ? void 0 : allClients.length) || 0);\n            if (!allClients || allClients.length === 0) {\n                return {\n                    cleaned: 0,\n                    errors: []\n                };\n            }\n            // Pobierz wszystkie unikalne owner_id\n            const ownerIds = [\n                ...new Set(allClients.map((c)=>c.owner_id))\n            ];\n            console.log('🔍 Sprawdzam owner_id:', ownerIds);\n            // Sprawdź które użytkownicy istnieją\n            const { data: existingUsers, error: usersError } = await supabase.from('users').select('id').in('id', ownerIds);\n            if (usersError) throw usersError;\n            const existingUserIds = (existingUsers || []).map((u)=>u.id);\n            console.log('✅ Istniejący użytkownicy:', existingUserIds);\n            // Znajdź klientów z nieistniejącymi owner_id\n            const clientsToClean = allClients.filter((client)=>client.owner_id && !existingUserIds.includes(client.owner_id));\n            console.log('🧹 Klienci do wyczyszczenia:', clientsToClean.length);\n            if (clientsToClean.length === 0) {\n                console.log('✅ Brak klientów do wyczyszczenia');\n                return {\n                    cleaned: 0,\n                    errors: []\n                };\n            }\n            // Wyczyść owner_id dla problematycznych klientów\n            const cleanupResults = [];\n            const errors = [];\n            for (const client of clientsToClean){\n                try {\n                    console.log(\"\\uD83E\\uDDF9 Czyszczę owner_id dla \".concat(client.first_name, \" \").concat(client.last_name, \" (\").concat(client.owner_id, \")\"));\n                    const { error } = await supabase.from('clients').update({\n                        owner_id: null\n                    }).eq('id', client.id);\n                    if (error) {\n                        console.error(\"❌ Błąd czyszczenia \".concat(client.id, \":\"), error);\n                        errors.push({\n                            client: client.id,\n                            error: error.message\n                        });\n                    } else {\n                        cleanupResults.push(client.id);\n                    }\n                } catch (err) {\n                    console.error(\"❌ Wyjątek podczas czyszczenia \".concat(client.id, \":\"), err);\n                    errors.push({\n                        client: client.id,\n                        error: String(err)\n                    });\n                }\n            }\n            console.log(\"✅ Wyczyszczono \".concat(cleanupResults.length, \" klient\\xf3w\"));\n            if (errors.length > 0) {\n                console.error(\"❌ Błędy przy \".concat(errors.length, \" klientach:\"), errors);\n            }\n            return {\n                cleaned: cleanupResults.length,\n                errors,\n                cleanedClients: clientsToClean.filter((c)=>cleanupResults.includes(c.id))\n            };\n        } catch (error) {\n            console.error('❌ Błąd w cleanupInvalidOwnerIds:', error);\n            throw error;\n        }\n    },\n    // Subskrypcja na zmiany w czasie rzeczywistym\n    subscribeToChanges (callback) {\n        return supabase.channel('clients_changes').on('postgres_changes', {\n            event: '*',\n            schema: 'public',\n            table: 'clients'\n        }, callback).subscribe();\n    },\n    // Subskrypcja na zmiany owner_id dla real-time aktualizacji\n    subscribeToOwnerChanges (callback) {\n        try {\n            // Sprawdź czy callback jest funkcją\n            if (typeof callback !== 'function') {\n                console.error('❌ Callback nie jest funkcją w subscribeToOwnerChanges');\n                throw new Error('Callback musi być funkcją');\n            }\n            console.log('📡 Tworzę kanał Supabase dla owner changes...');\n            // Najpierw sprawdź czy real-time jest włączony i dostępny\n            const channelName = \"clients_owner_changes_\".concat(Date.now());\n            console.log('📡 Nazwa kanału:', channelName);\n            const channel = supabase.channel(channelName).on('postgres_changes', {\n                event: 'UPDATE',\n                schema: 'public',\n                table: 'clients',\n                filter: 'owner_id=neq.null' // Tylko gdy owner_id się zmienia\n            }, (payload)=>{\n                try {\n                    console.log('📡 Real-time payload otrzymany:', {\n                        eventType: payload.eventType,\n                        table: payload.table,\n                        changes: payload.new ? {\n                            id: payload.new.id,\n                            owner_id: payload.new.owner_id,\n                            first_name: payload.new.first_name,\n                            last_name: payload.new.last_name\n                        } : 'brak danych'\n                    });\n                    if (typeof callback === 'function') {\n                        callback(payload);\n                    } else {\n                        console.error('❌ Callback nie jest funkcją podczas wywołania');\n                    }\n                } catch (callbackError) {\n                    console.error('❌ Błąd w callback:', callbackError);\n                }\n            }).subscribe((status, err)=>{\n                console.log('📡 Subskrypcja owner_changes status:', status);\n                if (status === 'SUBSCRIBED') {\n                    console.log('✅ Subskrypcja owner_changes aktywna');\n                } else if (status === 'CLOSED') {\n                    console.warn('⚠️ Subskrypcja owner_changes zamknięta - prawdopodobnie problem z autoryzacją real-time');\n                    console.warn('💡 Real-time może być wyłączony w ustawieniach Supabase lub brakuje uprawnień');\n                } else if (status === 'CHANNEL_ERROR') {\n                    console.error('❌ Błąd kanału real-time:', err);\n                    console.error('💡 Sprawdź ustawienia real-time w Supabase Dashboard');\n                } else if (status === 'TIMED_OUT') {\n                    console.warn('⏰ Timeout subskrypcji - problemy z połączeniem WebSocket');\n                } else {\n                    console.log('📡 Status subskrypcji:', status);\n                }\n            });\n            // Sprawdź stan kanału po krótkim czasie\n            setTimeout(()=>{\n                if (channel.state === 'closed') {\n                    console.warn('⚠️ Kanał real-time został zamknięty - prawdopodobnie RLS blokuje real-time lub feature jest wyłączony');\n                }\n            }, 2000);\n            console.log('✅ Kanał owner changes utworzony');\n            return channel;\n        } catch (error) {\n            console.error('❌ Błąd w subscribeToOwnerChanges:', error);\n            console.warn('💡 Real-time nie będzie działać - aplikacja będzie używać okresowego odświeżania');\n            // Zwróć mock object aby nie powodować błędów\n            return {\n                unsubscribe: ()=>{\n                    console.log('🧹 Mock unsubscribe dla błędnego kanału');\n                }\n            };\n        }\n    },\n    // Pobierz klientów z przypomnieniami na konkretny dzień\n    async getClientsWithReminders (user, targetDate) {\n        try {\n            const today = targetDate || new Date().toISOString().split('T')[0] // format YYYY-MM-DD\n            ;\n            console.log(\"\\uD83D\\uDCC5 Pobieranie klient\\xf3w z przypomnieniami na: \".concat(today));\n            // Pobierz wszystkich klientów użytkownika (bez paginacji)\n            const allClients = await this.getClients(user);\n            // Filtruj tylko tych z przypomnieniami na dziś\n            const clientsWithTodayReminders = allClients.filter((client)=>{\n                // Sprawdź czy klient ma aktywne przypomnienie\n                const reminder = client.reminder || {\n                    enabled: false,\n                    date: '',\n                    time: '',\n                    note: ''\n                };\n                return reminder.enabled && reminder.date === today;\n            });\n            // Sortuj według godziny przypomnienia\n            const sortedClients = clientsWithTodayReminders.sort((a, b)=>{\n                var _a_reminder, _b_reminder;\n                const timeA = ((_a_reminder = a.reminder) === null || _a_reminder === void 0 ? void 0 : _a_reminder.time) || '00:00';\n                const timeB = ((_b_reminder = b.reminder) === null || _b_reminder === void 0 ? void 0 : _b_reminder.time) || '00:00';\n                return timeA.localeCompare(timeB);\n            });\n            console.log(\"✅ Znaleziono \".concat(sortedClients.length, \" klient\\xf3w z przypomnieniami na \").concat(today));\n            return sortedClients;\n        } catch (error) {\n            console.error('❌ Błąd pobierania klientów z przypomnieniami:', error);\n            throw error;\n        }\n    },\n    // Pobierz przypomnienia pogrupowane według slotów czasowych dla dashboardu\n    async getDailyScheduleWithClients (user, targetDate) {\n        try {\n            const clientsWithReminders = await this.getClientsWithReminders(user, targetDate);\n            // Definicja slotów czasowych (zgodnie z obecną strukturą dashboardu)\n            const timeSlots = [\n                {\n                    time: '8:00 - 10:00',\n                    type: 'canvas',\n                    color: '#06b6d4',\n                    startTime: '08:00',\n                    endTime: '10:00',\n                    statuses: [\n                        'canvas'\n                    ]\n                },\n                {\n                    time: '10:10 - 12:00',\n                    type: 'sales',\n                    color: '#10b981',\n                    startTime: '10:10',\n                    endTime: '12:00',\n                    statuses: [\n                        'sale'\n                    ]\n                },\n                {\n                    time: '12:30 - 15:00',\n                    type: 'antysales',\n                    color: '#f59e0b',\n                    startTime: '12:30',\n                    endTime: '15:00',\n                    statuses: [\n                        'antysale'\n                    ]\n                },\n                {\n                    time: '15:10 - 16:30',\n                    type: 'canvas + sales',\n                    color: '#8b5cf6',\n                    startTime: '15:10',\n                    endTime: '16:30',\n                    statuses: [\n                        'canvas',\n                        'sale'\n                    ]\n                }\n            ];\n            // Przypisz klientów do odpowiednich slotów na podstawie TYLKO czasu przypomnienia\n            const slotsWithClients = timeSlots.map((slot)=>{\n                const slotClients = clientsWithReminders.filter((client)=>{\n                    var _client_reminder;\n                    const reminderTime = ((_client_reminder = client.reminder) === null || _client_reminder === void 0 ? void 0 : _client_reminder.time) || '00:00';\n                    const [hours, minutes] = reminderTime.split(':').map(Number);\n                    const reminderMinutes = hours * 60 + minutes;\n                    const [startHours, startMins] = slot.startTime.split(':').map(Number);\n                    const [endHours, endMins] = slot.endTime.split(':').map(Number);\n                    const startMinutes = startHours * 60 + startMins;\n                    const endMinutes = endHours * 60 + endMins;\n                    // Sprawdź czy godzina przypomnienia mieści się w slocie czasowym\n                    const timeInSlot = reminderMinutes >= startMinutes && reminderMinutes <= endMinutes;\n                    console.log(\"\\uD83D\\uDD50 Klient \".concat(client.first_name, \" \").concat(client.last_name, \": czas \").concat(reminderTime, \" (\").concat(reminderMinutes, \"min) vs slot \").concat(slot.time, \" (\").concat(startMinutes, \"-\").concat(endMinutes, \"min) = \").concat(timeInSlot ? 'PASUJE' : 'NIE PASUJE'));\n                    return timeInSlot;\n                });\n                console.log(\"\\uD83D\\uDCCA Slot \".concat(slot.time, \": \").concat(slotClients.length, \" klient\\xf3w\"));\n                return {\n                    ...slot,\n                    clients: slotClients\n                };\n            });\n            console.log(\"\\uD83D\\uDCCA Plan dnia z \".concat(slotsWithClients.reduce((sum, slot)=>sum + slot.clients.length, 0), \" klientami\"));\n            return slotsWithClients;\n        } catch (error) {\n            console.error('❌ Błąd tworzenia planu dnia:', error);\n            throw error;\n        }\n    }\n};\n// Funkcje API dla logów aktywności\nconst activityLogsApi = {\n    // Pobierz logi aktywności\n    async getLogs (clientId) {\n        let query = supabase.from('activity_logs').select(\"\\n        *,\\n        clients(first_name, last_name)\\n      \").order('timestamp', {\n            ascending: false\n        }).limit(50);\n        if (clientId) {\n            query = query.eq('client_id', clientId);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        return data;\n    },\n    // Pobierz historię zmian dla konkretnego klienta\n    async getClientHistory (clientId) {\n        try {\n            console.log('Pobieranie historii dla klienta:', clientId);\n            // Sprawdź czy użytkownik jest zalogowany\n            const { data: { user } } = await supabase.auth.getUser();\n            console.log('Aktualny użytkownik:', user === null || user === void 0 ? void 0 : user.id);\n            if (!user) {\n                console.error('Użytkownik nie jest zalogowany');\n                return [];\n            }\n            const { data, error } = await supabase.from('activity_logs').select(\"\\n          id,\\n          client_id,\\n          changed_by,\\n          change_type,\\n          field_changed,\\n          old_value,\\n          new_value,\\n          timestamp\\n        \").eq('client_id', clientId).order('timestamp', {\n                ascending: false\n            }).limit(20);\n            if (error) {\n                var _error_message;\n                console.error('Błąd query activity_logs:', error);\n                console.error('Szczegóły błędu:', JSON.stringify(error, null, 2));\n                // Sprawdź czy to problem z RLS\n                if (error.code === 'PGRST116' || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('RLS'))) {\n                    console.error('Problem z Row Level Security - użytkownik może nie mieć dostępu');\n                }\n                // Zwróć pustą tablicę zamiast rzucania błędem\n                return [];\n            }\n            console.log('Pobrano logi:', (data === null || data === void 0 ? void 0 : data.length) || 0);\n            // Jeśli nie ma logów, zwróć pustą tablicę\n            if (!data || data.length === 0) {\n                return [];\n            }\n            // Pobierz informacje o użytkownikach osobno z avatarami\n            const userIds = [\n                ...new Set(data.map((log)=>log.changed_by).filter(Boolean))\n            ];\n            console.log('Pobieranie użytkowników:', userIds);\n            const { data: users, error: usersError } = await supabase.from('users').select('id, full_name, role, avatar_url').in('id', userIds);\n            if (usersError) {\n                console.error('Błąd pobierania użytkowników:', usersError);\n            // Kontynuuj bez danych użytkowników\n            }\n            console.log('Pobrano użytkowników:', (users === null || users === void 0 ? void 0 : users.length) || 0);\n            // Mapuj użytkowników do słownika dla szybkiego dostępu\n            const usersMap = (users || []).reduce((acc, user)=>{\n                acc[user.id] = user;\n                return acc;\n            }, {});\n            // Przekształć dane z informacjami o edytorze\n            const result = data.map((log)=>{\n                const user = usersMap[log.changed_by];\n                return {\n                    id: log.id,\n                    client_id: log.client_id,\n                    changed_by: log.changed_by,\n                    change_type: log.change_type,\n                    field_changed: log.field_changed,\n                    old_value: log.old_value,\n                    new_value: log.new_value,\n                    timestamp: log.timestamp,\n                    editor_name: (user === null || user === void 0 ? void 0 : user.full_name) || log.changed_by || 'Nieznany użytkownik',\n                    editor_role: (user === null || user === void 0 ? void 0 : user.role) || 'unknown',\n                    editor_avatar: (user === null || user === void 0 ? void 0 : user.avatar_url) || null\n                };\n            });\n            console.log('Zwracanie historii:', result.length, 'wpisów');\n            return result;\n        } catch (error) {\n            console.error('Błąd w getClientHistory:', error);\n            throw error;\n        }\n    },\n    // Dodaj log aktywności\n    async createLog (log) {\n        const { data, error } = await supabase.from('activity_logs').insert([\n            {\n                ...log,\n                timestamp: new Date().toISOString()\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Funkcja testowa do sprawdzania dostępu do activity_logs\n    async testActivityLogsAccess () {\n        try {\n            console.log('Testowanie dostępu do activity_logs...');\n            // Sprawdź autoryzację\n            const { data: { user } } = await supabase.auth.getUser();\n            console.log('Test - użytkownik:', user === null || user === void 0 ? void 0 : user.id, user === null || user === void 0 ? void 0 : user.email);\n            if (!user) {\n                return {\n                    success: false,\n                    error: 'Brak autoryzacji - użytkownik nie jest zalogowany'\n                };\n            }\n            // Sprawdź czy użytkownik istnieje w tabeli users\n            const { data: userProfile, error: userError } = await supabase.from('users').select('id, email, role').eq('id', user.id).single();\n            console.log('Test - profil użytkownika:', userProfile);\n            console.log('Test - błąd profilu:', userError);\n            if (userError || !userProfile) {\n                return {\n                    success: false,\n                    error: 'Użytkownik nie istnieje w tabeli users'\n                };\n            }\n            // Testuj dostęp do activity_logs\n            const { data, error, count } = await supabase.from('activity_logs').select('*', {\n                count: 'exact'\n            }).limit(1);\n            console.log('Test activity_logs - data:', data);\n            console.log('Test activity_logs - error:', error);\n            console.log('Test activity_logs - count:', count);\n            return {\n                success: !error,\n                data,\n                error,\n                count,\n                user: userProfile\n            };\n        } catch (error) {\n            console.error('Błąd testu activity_logs:', error);\n            return {\n                success: false,\n                error\n            };\n        }\n    }\n};\n// Funkcje API dla raportów\nconst reportsApi = {\n    // Pobierz statystyki tylko pracowników z prowizją\n    async getEmployeeStats (user) {\n        try {\n            console.log('📊 Pobieranie statystyk pracowników...');\n            // KROK 1: Pobierz wszystkich użytkowników z rolą 'pracownik'\n            const { data: allEmployees, error: usersError } = await supabase.from('users').select(\"\\n          id,\\n          full_name,\\n          email,\\n          avatar_url,\\n          role\\n        \").eq('role', 'pracownik').order('full_name', {\n                ascending: true\n            });\n            if (usersError) {\n                console.error('❌ Błąd pobierania użytkowników-pracowników:', usersError);\n                throw usersError;\n            }\n            if (!allEmployees || allEmployees.length === 0) {\n                console.log('⚠️ Brak użytkowników z rolą pracownik');\n                return [];\n            }\n            console.log('✅ Pobrano wszystkich pracowników:', allEmployees.length, allEmployees.map((e)=>e.full_name));\n            // KROK 2: Pobierz statystyki z tabeli employee_stats dla tych pracowników\n            const employeeIds = allEmployees.map((emp)=>emp.id);\n            let existingStats = [];\n            try {\n                const { data, error: statsError } = await supabase.from('employee_stats').select('*').in('user_id', employeeIds);\n                if (statsError) {\n                    console.warn('⚠️ Błąd pobierania employee_stats:', statsError);\n                } else {\n                    existingStats = data || [];\n                }\n            } catch (error) {\n                console.warn('⚠️ Nie udało się pobrać employee_stats:', error);\n            }\n            console.log('✅ Pobrano statystyki dla pracowników:', (existingStats === null || existingStats === void 0 ? void 0 : existingStats.length) || 0);\n            // KROK 3: Pobierz dzisiejsze statystyki z tabeli clients (z obsługą błędów)\n            const today = new Date().toISOString().split('T')[0];\n            let todayClients = [];\n            try {\n                const { data, error: clientsError } = await supabase.from('clients').select('status, edited_by, created_at, updated_at').gte('updated_at', \"\".concat(today, \"T00:00:00\")).lt('updated_at', \"\".concat(today, \"T23:59:59\"));\n                if (clientsError) {\n                    console.warn('⚠️ Błąd pobierania klientów z dzisiaj:', clientsError);\n                } else {\n                    todayClients = data || [];\n                }\n            } catch (error) {\n                console.warn('⚠️ Nie udało się pobrać dzisiejszych klientów:', error);\n            }\n            console.log('✅ Pobrano dzisiejszych klientów:', todayClients.length);\n            // KROK 4: Pobierz wczorajsze statystyki dla kar (z obsługą błędów)\n            const yesterday = new Date();\n            yesterday.setDate(yesterday.getDate() - 1);\n            const yesterdayStr = yesterday.toISOString().split('T')[0];\n            let yesterdayClients = [];\n            try {\n                const { data, error: yesterdayError } = await supabase.from('clients').select('status, edited_by').gte('updated_at', \"\".concat(yesterdayStr, \"T00:00:00\")).lt('updated_at', \"\".concat(yesterdayStr, \"T23:59:59\"));\n                if (yesterdayError) {\n                    console.warn('⚠️ Błąd pobierania wczorajszych klientów:', yesterdayError);\n                } else {\n                    yesterdayClients = data || [];\n                }\n            } catch (error) {\n                console.warn('⚠️ Nie udało się pobrać wczorajszych klientów:', error);\n            }\n            // KROK 5: Pobierz WSZYSTKICH klientów przypisanych do pracowników (z obsługą błędów)\n            let allOwnedClients = [];\n            try {\n                const { data, error: ownedError } = await supabase.from('clients').select('status, owner_id').not('owner_id', 'is', null).in('owner_id', employeeIds);\n                if (ownedError) {\n                    console.warn('⚠️ Błąd pobierania klientów przypisanych:', ownedError);\n                } else {\n                    allOwnedClients = data || [];\n                }\n            } catch (error) {\n                console.warn('⚠️ Nie udało się pobrać przypisanych klientów:', error);\n            }\n            console.log('✅ Pobrano wszystkich przypisanych klientów:', allOwnedClients.length);\n            // KROK 6: Agreguj dzisiejsze statystyki per pracownik\n            const todayStats = todayClients.reduce((acc, client)=>{\n                const userId = client.edited_by;\n                if (!userId) return acc;\n                if (!acc[userId]) {\n                    acc[userId] = {\n                        total: 0,\n                        canvas: 0,\n                        antysale: 0,\n                        sale: 0,\n                        other: 0\n                    };\n                }\n                acc[userId].total++;\n                if (client.status === 'canvas') acc[userId].canvas++;\n                else if (client.status === 'antysale') acc[userId].antysale++;\n                else if (client.status === 'sale') acc[userId].sale++;\n                else acc[userId].other++;\n                return acc;\n            }, {});\n            // KROK 7: Agreguj wczorajsze statystyki per pracownik\n            const yesterdayStats = yesterdayClients.reduce((acc, client)=>{\n                const userId = client.edited_by;\n                if (userId) {\n                    acc[userId] = (acc[userId] || 0) + 1;\n                }\n                return acc;\n            }, {});\n            // KROK 8: Agreguj statusy WSZYSTKICH przypisanych klientów per pracownik\n            const ownedClientsStats = allOwnedClients.reduce((acc, client)=>{\n                const ownerId = client.owner_id;\n                if (!ownerId) return acc;\n                if (!acc[ownerId]) {\n                    acc[ownerId] = {\n                        total: 0,\n                        canvas: 0,\n                        antysale: 0,\n                        sale: 0,\n                        brak_kontaktu: 0,\n                        nie_zainteresowany: 0,\n                        zdenerwowany: 0,\n                        '$$': 0\n                    };\n                }\n                acc[ownerId].total++;\n                switch(client.status){\n                    case 'canvas':\n                        acc[ownerId].canvas++;\n                        break;\n                    case 'antysale':\n                        acc[ownerId].antysale++;\n                        break;\n                    case 'sale':\n                        acc[ownerId].sale++;\n                        break;\n                    case 'brak_kontaktu':\n                        acc[ownerId].brak_kontaktu++;\n                        break;\n                    case 'nie_zainteresowany':\n                        acc[ownerId].nie_zainteresowany++;\n                        break;\n                    case 'zdenerwowany':\n                        acc[ownerId].zdenerwowany++;\n                        break;\n                    case '$$':\n                        acc[ownerId]['$$']++;\n                        break;\n                }\n                return acc;\n            }, {});\n            console.log('📊 Statystyki przypisanych klientów:', ownedClientsStats);\n            // KROK 9: Stwórz mapę statystyk employee_stats\n            const statsMap = new Map();\n            existingStats.forEach((stat)=>{\n                statsMap.set(stat.user_id, stat);\n            });\n            // KROK 10: Kombinuj dane - dla WSZYSTKICH pracowników (zawsze zwraca listę)\n            const enhancedStats = allEmployees.map((employee)=>{\n                const userId = employee.id;\n                // Pobierz statystyki z employee_stats lub utwórz domyślne\n                const basicStat = statsMap.get(userId) || {\n                    id: 'temp_' + userId,\n                    user_id: userId,\n                    daily_target: 20,\n                    commission_rate: 3.0,\n                    monthly_canvas: 0,\n                    monthly_antysale: 0,\n                    monthly_sale: 0,\n                    total_commissions: 0,\n                    total_penalties: 0,\n                    custom_clients_count: 0,\n                    custom_total_payments: 0,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                const todayForUser = todayStats[userId] || {\n                    total: 0,\n                    canvas: 0,\n                    antysale: 0,\n                    sale: 0\n                };\n                const yesterdayForUser = yesterdayStats[userId] || 0;\n                const ownedForUser = ownedClientsStats[userId] || {\n                    total: 0,\n                    canvas: 0,\n                    antysale: 0,\n                    sale: 0,\n                    brak_kontaktu: 0,\n                    nie_zainteresowany: 0,\n                    zdenerwowany: 0,\n                    '$$': 0\n                };\n                // Oblicz karę za wczoraj\n                const yesterdayShortage = Math.max(0, basicStat.daily_target - yesterdayForUser);\n                const penalty = yesterdayShortage * 15;\n                // Oblicz prowizję na podstawie przypisanych klientów Sale\n                const commission = ownedForUser.sale * basicStat.commission_rate / 100 * 100;\n                console.log(\"\\uD83D\\uDC64 Pracownik \".concat(employee.full_name, \": Canvas=\").concat(ownedForUser.canvas, \", AntyS=\").concat(ownedForUser.antysale, \", Sale=\").concat(ownedForUser.sale));\n                return {\n                    ...basicStat,\n                    // WAŻNE: Dołącz dane użytkownika\n                    user: {\n                        id: employee.id,\n                        full_name: employee.full_name,\n                        email: employee.email,\n                        avatar_url: employee.avatar_url,\n                        role: employee.role\n                    },\n                    daily_achieved: todayForUser.total,\n                    yesterday_shortage: yesterdayShortage,\n                    status_changes_today: {\n                        canvas: todayForUser.canvas,\n                        antysale: todayForUser.antysale,\n                        sale: todayForUser.sale,\n                        other: todayForUser.other\n                    },\n                    // Używaj statystyk opartych na owner_id (przypisanych klientów)\n                    monthly_canvas: ownedForUser.canvas,\n                    monthly_antysale: ownedForUser.antysale,\n                    monthly_sale: ownedForUser.sale,\n                    total_commissions: commission,\n                    total_penalties: penalty\n                };\n            });\n            console.log('✅ Przygotowano rozszerzone statystyki dla wszystkich pracowników:', enhancedStats.length);\n            console.log('👥 Lista pracowników:', enhancedStats.map((s)=>{\n                var _s_user;\n                return (_s_user = s.user) === null || _s_user === void 0 ? void 0 : _s_user.full_name;\n            }).join(', '));\n            return enhancedStats;\n        } catch (error) {\n            console.error('❌ Błąd pobierania statystyk pracowników:', error);\n            // W przypadku błędu, zwróć pustą listę zamiast rzucać błąd\n            return [];\n        }\n    },\n    // Podsumowanie dnia\n    async getDailySummary (date) {\n        const { data, error } = await supabase.from('clients').select('status, edited_by').gte('updated_at', \"\".concat(date, \"T00:00:00\")).lt('updated_at', \"\".concat(date, \"T23:59:59\"));\n        if (error) throw error;\n        // Agregacja danych\n        const statusBreakdown = data.reduce((acc, client)=>{\n            acc[client.status] = (acc[client.status] || 0) + 1;\n            return acc;\n        }, {});\n        const employeeStats = data.reduce((acc, client)=>{\n            acc[client.edited_by] = (acc[client.edited_by] || 0) + 1;\n            return acc;\n        }, {});\n        return {\n            totalClients: data.length,\n            statusBreakdown,\n            employeeStats\n        };\n    },\n    // Podsumowanie tygodniowe\n    async getWeeklySummary (startDate, endDate) {\n        const { data, error } = await supabase.from('clients').select('status, edited_by, updated_at').gte('updated_at', startDate).lt('updated_at', endDate);\n        if (error) throw error;\n        return data;\n    },\n    // Aktualizuj statystyki pracownika (dla manager/project_manager/junior_manager/szef/admin)\n    async updateEmployeeStats (userId, updates, currentUser) {\n        // Sprawdź uprawnienia\n        if (![\n            'manager',\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(currentUser.role)) {\n            throw new Error('Brak uprawnień do modyfikacji statystyk');\n        }\n        const { data, error } = await supabase.from('employee_stats').update(updates).eq('user_id', userId).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Edytuj ilość klientów i sumę wpłat pracownika (dla manager/project_manager/junior_manager/szef/admin)\n    async updateEmployeeClientStats (userId, clientsCount, totalPayments, currentUser) {\n        // Sprawdź uprawnienia\n        if (![\n            'manager',\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(currentUser.role)) {\n            throw new Error('Brak uprawnień do modyfikacji statystyk');\n        }\n        try {\n            console.log(\"\\uD83D\\uDCDD Aktualizuję statystyki pracownika \".concat(userId, \": klienci=\").concat(clientsCount, \", wpłaty=\").concat(totalPayments));\n            // METODA 1: Spróbuj prostą aktualizację w employee_stats\n            try {\n                console.log('📝 Próba prostej aktualizacji w employee_stats');\n                const legacyUpdates = {\n                    custom_clients_count: clientsCount,\n                    custom_total_payments: totalPayments,\n                    updated_at: new Date().toISOString()\n                };\n                const { data, error } = await supabase.from('employee_stats').update(legacyUpdates).eq('user_id', userId).select(\"\\n            *,\\n            user:users!user_id (\\n              id,\\n              full_name,\\n              email,\\n              avatar_url,\\n              role\\n            )\\n          \").single();\n                if (!error && data) {\n                    console.log('✅ Zaktualizowano statystyki w employee_stats (metoda 1)');\n                    console.log(\"\\uD83D\\uDCCA Klienci: \".concat(clientsCount, \", Wpłaty: €\").concat(totalPayments));\n                    return data;\n                } else {\n                    console.warn('⚠️ Metoda 1 nie zadziałała:', error);\n                    throw error;\n                }\n            } catch (method1Error) {\n                console.warn('⚠️ Metoda 1 (prosta aktualizacja) nie zadziałała:', method1Error);\n                // METODA 2: Spróbuj INSERT z ON CONFLICT\n                try {\n                    console.log('📝 Próba INSERT z ON CONFLICT w employee_stats');\n                    const insertData = {\n                        user_id: userId,\n                        daily_target: 20,\n                        commission_rate: 3.0,\n                        monthly_canvas: 0,\n                        monthly_antysale: 0,\n                        monthly_sale: 0,\n                        total_commissions: 0,\n                        total_penalties: 0,\n                        custom_clients_count: clientsCount,\n                        custom_total_payments: totalPayments,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    };\n                    const { data, error } = await supabase.from('employee_stats').upsert(insertData, {\n                        onConflict: 'user_id',\n                        ignoreDuplicates: false\n                    }).select(\"\\n              *,\\n              user:users!user_id (\\n                id,\\n                full_name,\\n                email,\\n                avatar_url,\\n                role\\n              )\\n            \").single();\n                    if (!error && data) {\n                        console.log('✅ Zaktualizowano statystyki w employee_stats (metoda 2)');\n                        console.log(\"\\uD83D\\uDCCA Klienci: \".concat(clientsCount, \", Wpłaty: €\").concat(totalPayments));\n                        return data;\n                    } else {\n                        console.warn('⚠️ Metoda 2 nie zadziałała:', error);\n                        throw error;\n                    }\n                } catch (method2Error) {\n                    console.warn('⚠️ Metoda 2 (upsert) nie zadziałała:', method2Error);\n                    // METODA 3: Zaktualizuj tylko w pamięci (fallback)\n                    console.log('📝 Fallback - zwracam symulowane dane');\n                    return {\n                        id: 'temp_' + userId,\n                        user_id: userId,\n                        daily_target: 20,\n                        commission_rate: 3.0,\n                        monthly_canvas: 0,\n                        monthly_antysale: 0,\n                        monthly_sale: 0,\n                        total_commissions: 0,\n                        total_penalties: 0,\n                        custom_clients_count: clientsCount,\n                        custom_total_payments: totalPayments,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString(),\n                        user: {\n                            id: userId,\n                            full_name: 'Pracownik',\n                            email: 'brak@email.com',\n                            avatar_url: null,\n                            role: 'pracownik'\n                        }\n                    };\n                }\n            }\n        } catch (error) {\n            console.error('❌ Błąd w updateEmployeeClientStats:', error);\n            throw error;\n        }\n    },\n    // Stwórz statystyki dla nowego pracownika\n    async createEmployeeStats (userId, currentUser) {\n        // Sprawdź uprawnienia\n        if (![\n            'manager',\n            'project_manager',\n            'junior_manager',\n            'szef',\n            'admin'\n        ].includes(currentUser.role)) {\n            throw new Error('Brak uprawnień do tworzenia statystyk');\n        }\n        const { data, error } = await supabase.from('employee_stats').insert([\n            {\n                user_id: userId,\n                daily_target: 20,\n                commission_rate: 3.0\n            }\n        ]).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // 📊 Nowa funkcja: Pobierz statystyki wykorzystania bazy (klienci z/bez właściciela)\n    async getDatabaseUtilization () {\n        try {\n            console.log('📊 Pobieranie statystyk wykorzystania bazy...');\n            // Zlicz wszystkich klientów\n            const { count: totalCount, error: totalError } = await supabase.from('clients').select('*', {\n                count: 'exact',\n                head: true\n            });\n            if (totalError) {\n                console.error('❌ Błąd pobierania łącznej liczby klientów:', totalError);\n                throw totalError;\n            }\n            // Zlicz klientów z właścicielem (owner_id != null)\n            const { count: withOwnerCount, error: withOwnerError } = await supabase.from('clients').select('*', {\n                count: 'exact',\n                head: true\n            }).not('owner_id', 'is', null);\n            if (withOwnerError) {\n                console.error('❌ Błąd pobierania klientów z właścicielem:', withOwnerError);\n                throw withOwnerError;\n            }\n            // Oblicz klientów bez właściciela\n            const withoutOwnerCount = (totalCount || 0) - (withOwnerCount || 0);\n            // Oblicz procent wykorzystania\n            const utilizationPercentage = totalCount ? Math.round((withOwnerCount || 0) / totalCount * 100) : 0;\n            const result = {\n                withOwner: withOwnerCount || 0,\n                withoutOwner: withoutOwnerCount,\n                total: totalCount || 0,\n                utilizationPercentage\n            };\n            console.log('📊 Statystyki wykorzystania bazy:', result);\n            return result;\n        } catch (error) {\n            console.error('❌ Błąd pobierania statystyk wykorzystania bazy:', error);\n            throw error;\n        }\n    },\n    // 🔄 ADMIN: Resetuj właścicieli wszystkich klientów\n    async resetAllClientOwners (currentUser) {\n        // Sprawdź uprawnienia - tylko admin\n        if (currentUser.role !== 'admin') {\n            throw new Error('Brak uprawnień! Tylko administrator może resetować właścicieli klientów.');\n        }\n        try {\n            console.log('🔄 Rozpoczynam resetowanie właścicieli klientów...');\n            // Pobierz liczbę klientów z właścicielem przed resetowaniem\n            const { count: beforeCount, error: beforeError } = await supabase.from('clients').select('*', {\n                count: 'exact',\n                head: true\n            }).not('owner_id', 'is', null);\n            if (beforeError) {\n                console.error('❌ Błąd sprawdzania stanu przed resetowaniem:', beforeError);\n                throw beforeError;\n            }\n            // Resetuj owner_id dla wszystkich klientów\n            const { data, error } = await supabase.from('clients').update({\n                owner_id: null\n            }).not('owner_id', 'is', null) // Tylko te które mają właściciela\n            .select('id, first_name, last_name');\n            if (error) {\n                console.error('❌ Błąd resetowania właścicieli:', error);\n                throw error;\n            }\n            const resetCount = (data === null || data === void 0 ? void 0 : data.length) || 0;\n            // Loguj akcję do activity_logs\n            try {\n                await activityLogsApi.createLog({\n                    client_id: 'bulk_action',\n                    changed_by: currentUser.id,\n                    change_type: 'update',\n                    field_changed: 'owner_id',\n                    old_value: 'various',\n                    new_value: 'null (reset by admin)'\n                });\n            } catch (logError) {\n                console.error('⚠️ Nie udało się zalogować akcji:', logError);\n            // Nie przerywamy procesu z powodu błędu logowania\n            }\n            console.log(\"✅ Zresetowano właścicieli dla \".concat(resetCount, \" klient\\xf3w\"));\n            return {\n                success: resetCount,\n                message: \"Pomyślnie zresetowano właścicieli dla \".concat(resetCount, \" klient\\xf3w. Wszyscy klienci są teraz bez przypisanego właściciela.\")\n            };\n        } catch (error) {\n            console.error('❌ Błąd resetowania właścicieli klientów:', error);\n            throw error;\n        }\n    },\n    // Pobierz statystyki aktywności pracowników z tabeli employee_statistics\n    async getEmployeeActivityStats (user) {\n        try {\n            console.log('📊 Pobieranie statystyk aktywności pracowników...');\n            // Sprawdź uprawnienia\n            if (!user || ![\n                'manager',\n                'project_manager',\n                'junior_manager',\n                'szef',\n                'admin'\n            ].includes(user.role)) {\n                console.warn('⚠️ Brak uprawnień do podglądu statystyk aktywności');\n                return [];\n            }\n            // KROK 1: Pobierz wszystkich użytkowników z rolą 'pracownik'\n            let allEmployees = [];\n            try {\n                const { data: employees, error: usersError } = await supabase.from('users').select(\"\\n            id,\\n            full_name,\\n            email,\\n            avatar_url,\\n            role\\n          \").eq('role', 'pracownik').order('full_name', {\n                    ascending: true\n                });\n                if (usersError) {\n                    console.error('❌ Błąd pobierania użytkowników-pracowników:', usersError);\n                    return [];\n                }\n                allEmployees = employees || [];\n                console.log(\"\\uD83D\\uDC65 Znaleziono pracownik\\xf3w: \".concat(allEmployees.length));\n                if (allEmployees.length === 0) {\n                    console.log('⚠️ Brak użytkowników z rolą pracownik');\n                    return [];\n                }\n            } catch (error) {\n                console.error('❌ Błąd pobierania pracowników:', error);\n                return [];\n            }\n            // KROK 2: Pobierz statystyki aktywności - z obsługą błędów RLS\n            let activityStats = [];\n            try {\n                const employeeIds = allEmployees.map((emp)=>emp.id);\n                console.log(\"\\uD83D\\uDD0D Pobieranie statystyk dla ID: \".concat(employeeIds.slice(0, 3).join(', '), \"... (\").concat(employeeIds.length, \" total)\"));\n                const { data: stats, error: statsError } = await supabase.from('employee_statistics').select('*').eq('period_type', 'monthly').in('user_id', employeeIds).order('period_end', {\n                    ascending: false\n                });\n                if (statsError) {\n                    var _statsError_message, _statsError_message1;\n                    console.error('❌ Błąd pobierania statystyk aktywności:', statsError);\n                    // Jeśli to błąd RLS (403), nie przerywaj - użyj domyślnych danych\n                    if (statsError.code === 'PGRST116' || ((_statsError_message = statsError.message) === null || _statsError_message === void 0 ? void 0 : _statsError_message.includes('RLS')) || ((_statsError_message1 = statsError.message) === null || _statsError_message1 === void 0 ? void 0 : _statsError_message1.includes('permission'))) {\n                        console.warn('🔒 Problem z RLS - używam domyślnych danych aktywności');\n                        activityStats = [];\n                    } else {\n                        console.error('💥 Krytyczny błąd pobierania statystyk - przerywam');\n                        return [];\n                    }\n                } else {\n                    activityStats = stats || [];\n                    console.log(\"\\uD83D\\uDCCA Znaleziono rekord\\xf3w aktywności: \".concat(activityStats.length));\n                }\n            } catch (error) {\n                console.error('❌ Błąd zapytania o statystyki aktywności:', error);\n                activityStats = [];\n            }\n            // KROK 3: Stwórz mapę najnowszych statystyk dla każdego pracownika\n            const latestStatsMap = new Map();\n            if (activityStats && activityStats.length > 0) {\n                activityStats.forEach((stat)=>{\n                    const userId = stat.user_id;\n                    if (!latestStatsMap.has(userId)) {\n                        latestStatsMap.set(userId, stat);\n                    }\n                });\n                console.log(\"\\uD83D\\uDDFA️ Zmapowano statystyki dla \".concat(latestStatsMap.size, \" pracownik\\xf3w\"));\n            } else {\n                console.log('⚠️ Brak danych aktywności - użyję domyślnych wartości');\n            }\n            // KROK 4: Kombinuj dane pracowników ze statystykami aktywności\n            const result = allEmployees.map((employee)=>{\n                const userId = employee.id;\n                const activityStat = latestStatsMap.get(userId);\n                if (activityStat) {\n                    // Mamy statystyki - użyj prawdziwych danych\n                    return {\n                        ...activityStat,\n                        user: {\n                            id: employee.id,\n                            full_name: employee.full_name,\n                            email: employee.email,\n                            avatar_url: employee.avatar_url,\n                            role: employee.role\n                        }\n                    };\n                } else {\n                    // Brak statystyk - stwórz domyślne dane\n                    const currentDate = new Date();\n                    const currentMonth = currentDate.getMonth() + 1;\n                    const currentYear = currentDate.getFullYear();\n                    const monthStart = \"\".concat(currentYear, \"-\").concat(currentMonth.toString().padStart(2, '0'), \"-01\");\n                    const monthEnd = new Date(currentYear, currentMonth, 0).toISOString().split('T')[0];\n                    return {\n                        id: 'temp_' + userId,\n                        user_id: userId,\n                        period_type: 'monthly',\n                        period_start: monthStart,\n                        period_end: monthEnd,\n                        total_work_minutes: 0,\n                        average_daily_minutes: 0,\n                        expected_work_minutes: 176 * 60,\n                        efficiency_percentage: 0,\n                        total_activities: 0,\n                        average_daily_activities: 0,\n                        days_worked: 0,\n                        days_absent: 0,\n                        user: {\n                            id: employee.id,\n                            full_name: employee.full_name,\n                            email: employee.email,\n                            avatar_url: employee.avatar_url,\n                            role: employee.role\n                        }\n                    };\n                }\n            });\n            console.log(\"✅ Przygotowano statystyki aktywności dla wszystkich pracownik\\xf3w: \".concat(result.length));\n            console.log(\"\\uD83D\\uDC65 Lista pracownik\\xf3w: \".concat(result.map((s)=>{\n                var _s_user;\n                return (_s_user = s.user) === null || _s_user === void 0 ? void 0 : _s_user.full_name;\n            }).join(', ')));\n            // Pokaż statystyki podsumowujące\n            const withData = result.filter((r)=>r.total_work_minutes > 0).length;\n            const withoutData = result.length - withData;\n            console.log(\"\\uD83D\\uDCCA Pracownicy z danymi: \".concat(withData, \", bez danych: \").concat(withoutData));\n            return result;\n        } catch (error) {\n            console.error('❌ Błąd pobierania statystyk aktywności:', error);\n            // Graceful fallback - zwróć pustą tablicę zamiast crashować\n            console.log('🔄 Graceful fallback - zwracam pustą tablicę');\n            return [];\n        }\n    },\n    // Pobierz trendy sprzedażowe z ostatnich 7 dni\n    async getSalesTrends (user) {\n        try {\n            console.log('📈 Pobieranie trendów sprzedażowych z ostatnich 7 dni...');\n            // Pobierz dane z ostatnich 7 dni\n            const endDate = new Date();\n            const startDate = new Date();\n            startDate.setDate(endDate.getDate() - 6) // 7 dni wstecz (włącznie z dzisiaj)\n            ;\n            const { data, error } = await supabase.from('clients').select('status, updated_at, status_changed_at, owner_id, edited_by').gte('updated_at', startDate.toISOString().split('T')[0]).lte('updated_at', endDate.toISOString().split('T')[0] + 'T23:59:59').in('status', [\n                'canvas',\n                'sale',\n                'antysale'\n            ]).order('updated_at', {\n                ascending: true\n            });\n            if (error) {\n                console.error('❌ Błąd pobierania trendów sprzedażowych:', error);\n                throw error;\n            }\n            console.log(\"✅ Pobrano \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" rekord\\xf3w z ostatnich 7 dni\"));\n            // Filtruj klientów według uprawnień użytkownika\n            let filteredData = data || [];\n            if (user.role === 'pracownik') {\n                filteredData = filteredData.filter((client)=>client.owner_id === user.id || client.owner_id === null || client.edited_by === user.id);\n            }\n            // Stwórz mapę dla dni tygodnia\n            const dayNames = [\n                'Ndz',\n                'Pon',\n                'Wt',\n                'Śr',\n                'Czw',\n                'Pt',\n                'Sob'\n            ];\n            const trends = {};\n            // Inicjalizuj ostatnie 7 dni\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                trends[dayName] = {\n                    canvas: 0,\n                    sale: 0,\n                    antysale: 0\n                };\n            }\n            // Grupuj dane według dni\n            filteredData.forEach((client)=>{\n                const date = new Date(client.updated_at);\n                const dayName = dayNames[date.getDay()];\n                if (trends[dayName]) {\n                    if (client.status === 'canvas') trends[dayName].canvas++;\n                    else if (client.status === 'sale') trends[dayName].sale++;\n                    else if (client.status === 'antysale') trends[dayName].antysale++;\n                }\n            });\n            // Przekształć na format dla wykresu (ostatnie 7 dni w kolejności)\n            const result = [];\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                result.push({\n                    day: dayName,\n                    canvas: trends[dayName].canvas,\n                    sale: trends[dayName].sale,\n                    antysale: trends[dayName].antysale\n                });\n            }\n            console.log('✅ Trendy sprzedażowe przygotowane:', result);\n            return result;\n        } catch (error) {\n            console.error('❌ Błąd pobierania trendów sprzedażowych:', error);\n            // W przypadku błędu zwróć puste dane dla ostatnich 7 dni\n            const dayNames = [\n                'Ndz',\n                'Pon',\n                'Wt',\n                'Śr',\n                'Czw',\n                'Pt',\n                'Sob'\n            ];\n            const result = [];\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                result.push({\n                    day: dayName,\n                    canvas: 0,\n                    sale: 0,\n                    antysale: 0\n                });\n            }\n            return result;\n        }\n    },\n    // Pobierz statystyki kliknięć telefonu tylko dla pracowników\n    async getPhoneClicksStats (user) {\n        try {\n            console.log('📞 Pobieranie statystyk kliknięć telefonu...');\n            // Pobierz wszystkich pracowników\n            const { data: employees, error: employeesError } = await supabase.from('users').select('id').eq('role', 'pracownik');\n            if (employeesError) {\n                console.error('❌ Błąd pobierania pracowników:', employeesError);\n                throw employeesError;\n            }\n            const employeeIds = (employees || []).map((emp)=>emp.id);\n            console.log(\"\\uD83D\\uDC65 Znaleziono \".concat(employeeIds.length, \" pracownik\\xf3w\"));\n            if (employeeIds.length === 0) {\n                return {\n                    totalPhoneCalls: 0,\n                    totalPhoneCallsToday: 0\n                };\n            }\n            // Pobierz wszystkie kliknięcia telefonu z activity_logs tylko dla pracowników\n            const { data: allPhoneClicks, error: allClicksError } = await supabase.from('activity_logs').select('id, changed_by, timestamp').eq('field_changed', 'last_phone_click').in('changed_by', employeeIds);\n            if (allClicksError) {\n                console.error('❌ Błąd pobierania kliknięć telefonu:', allClicksError);\n                throw allClicksError;\n            }\n            const totalPhoneCalls = (allPhoneClicks === null || allPhoneClicks === void 0 ? void 0 : allPhoneClicks.length) || 0;\n            // Pobierz dzisiejsze kliknięcia telefonu\n            const today = new Date().toISOString().split('T')[0] // YYYY-MM-DD\n            ;\n            const { data: todayPhoneClicks, error: todayClicksError } = await supabase.from('activity_logs').select('id, changed_by, timestamp').eq('field_changed', 'last_phone_click').in('changed_by', employeeIds).gte('timestamp', \"\".concat(today, \"T00:00:00\")).lt('timestamp', \"\".concat(today, \"T23:59:59\"));\n            if (todayClicksError) {\n                console.error('❌ Błąd pobierania dzisiejszych kliknięć telefonu:', todayClicksError);\n                throw todayClicksError;\n            }\n            const totalPhoneCallsToday = (todayPhoneClicks === null || todayPhoneClicks === void 0 ? void 0 : todayPhoneClicks.length) || 0;\n            console.log(\"✅ Statystyki kliknięć telefonu: łącznie \".concat(totalPhoneCalls, \", dziś \").concat(totalPhoneCallsToday));\n            return {\n                totalPhoneCalls,\n                totalPhoneCallsToday\n            };\n        } catch (error) {\n            console.error('❌ Błąd pobierania statystyk kliknięć telefonu:', error);\n            // W przypadku błędu zwróć zerowe statystyki\n            return {\n                totalPhoneCalls: 0,\n                totalPhoneCallsToday: 0\n            };\n        }\n    },\n    // Pobierz dane trendów wydajności zespołu z ostatnich 7 dni\n    async getTeamPerformanceTrends (user) {\n        try {\n            console.log('📊 Pobieranie trendów wydajności zespołu z ostatnich 7 dni...');\n            // Pobierz wszystkich pracowników\n            const { data: employees, error: employeesError } = await supabase.from('users').select('id').eq('role', 'pracownik');\n            if (employeesError) {\n                console.error('❌ Błąd pobierania pracowników:', employeesError);\n                throw employeesError;\n            }\n            const employeeIds = (employees || []).map((emp)=>emp.id);\n            console.log(\"\\uD83D\\uDC65 Znaleziono \".concat(employeeIds.length, \" pracownik\\xf3w\"));\n            if (employeeIds.length === 0) {\n                // Zwróć puste dane dla ostatnich 7 dni\n                const dayNames = [\n                    'Ndz',\n                    'Pon',\n                    'Wt',\n                    'Śr',\n                    'Czw',\n                    'Pt',\n                    'Sob'\n                ];\n                const result = [];\n                for(let i = 6; i >= 0; i--){\n                    const date = new Date();\n                    date.setDate(date.getDate() - i);\n                    const dayName = dayNames[date.getDay()];\n                    result.push({\n                        day: dayName,\n                        telefony: 0,\n                        konwersja: 0,\n                        klienci: 0\n                    });\n                }\n                return result;\n            }\n            // Pobierz dane z ostatnich 7 dni\n            const endDate = new Date();\n            const startDate = new Date();\n            startDate.setDate(endDate.getDate() - 6) // 7 dni wstecz (włącznie z dzisiaj)\n            ;\n            // 1. Pobierz kliknięcia telefonu z activity_logs (tylko pracownicy)\n            const { data: phoneClicks, error: phoneError } = await supabase.from('activity_logs').select('changed_by, timestamp').eq('field_changed', 'last_phone_click').in('changed_by', employeeIds).gte('timestamp', startDate.toISOString().split('T')[0]).lte('timestamp', endDate.toISOString().split('T')[0] + 'T23:59:59');\n            if (phoneError) {\n                console.error('❌ Błąd pobierania kliknięć telefonu:', phoneError);\n                throw phoneError;\n            }\n            // 2. Pobierz zmiany klientów z ostatnich 7 dni (tylko przez pracowników)\n            const { data: clientChanges, error: changesError } = await supabase.from('clients').select('updated_at, status, edited_by').in('edited_by', employeeIds).gte('updated_at', startDate.toISOString().split('T')[0]).lte('updated_at', endDate.toISOString().split('T')[0] + 'T23:59:59').order('updated_at', {\n                ascending: true\n            });\n            if (changesError) {\n                console.error('❌ Błąd pobierania zmian klientów:', changesError);\n                throw changesError;\n            }\n            console.log(\"✅ Pobrano \".concat((phoneClicks === null || phoneClicks === void 0 ? void 0 : phoneClicks.length) || 0, \" kliknięć telefonu i \").concat((clientChanges === null || clientChanges === void 0 ? void 0 : clientChanges.length) || 0, \" zmian klient\\xf3w\"));\n            // Stwórz mapę dla dni tygodnia\n            const dayNames = [\n                'Ndz',\n                'Pon',\n                'Wt',\n                'Śr',\n                'Czw',\n                'Pt',\n                'Sob'\n            ];\n            const trendsData = {};\n            // Inicjalizuj ostatnie 7 dni\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                trendsData[dayName] = {\n                    telefony: 0,\n                    klienci: 0,\n                    sales: 0\n                };\n            }\n            // Grupuj kliknięcia telefonu według dni\n            if (phoneClicks && Array.isArray(phoneClicks)) {\n                phoneClicks.forEach((click)=>{\n                    const date = new Date(click.timestamp);\n                    const dayName = dayNames[date.getDay()];\n                    if (trendsData[dayName]) {\n                        trendsData[dayName].telefony++;\n                    }\n                });\n            }\n            // Grupuj zmiany klientów według dni\n            if (clientChanges && Array.isArray(clientChanges)) {\n                clientChanges.forEach((change)=>{\n                    const date = new Date(change.updated_at);\n                    const dayName = dayNames[date.getDay()];\n                    if (trendsData[dayName]) {\n                        trendsData[dayName].klienci++;\n                        if (change.status === 'sale') {\n                            trendsData[dayName].sales++;\n                        }\n                    }\n                });\n            }\n            // Przekształć na format dla wykresu (ostatnie 7 dni w kolejności)\n            const result = [];\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                const dayData = trendsData[dayName];\n                // Oblicz konwersję (procent sales względem wszystkich klientów)\n                const konwersja = dayData.klienci > 0 ? Math.round(dayData.sales / dayData.klienci * 100) : 0;\n                result.push({\n                    day: dayName,\n                    telefony: dayData.telefony,\n                    konwersja: konwersja,\n                    klienci: dayData.klienci\n                });\n            }\n            console.log('✅ Trendy wydajności zespołu przygotowane:', result);\n            return result;\n        } catch (error) {\n            console.error('❌ Błąd pobierania trendów wydajności zespołu:', error);\n            // W przypadku błędu zwróć puste dane dla ostatnich 7 dni\n            const dayNames = [\n                'Ndz',\n                'Pon',\n                'Wt',\n                'Śr',\n                'Czw',\n                'Pt',\n                'Sob'\n            ];\n            const result = [];\n            for(let i = 6; i >= 0; i--){\n                const date = new Date();\n                date.setDate(date.getDate() - i);\n                const dayName = dayNames[date.getDay()];\n                result.push({\n                    day: dayName,\n                    telefony: 0,\n                    konwersja: 0,\n                    klienci: 0\n                });\n            }\n            return result;\n        }\n    },\n    // API dla statystyk osobistych pracownika\n    async getMyPersonalStats (user) {\n        try {\n            console.log('📊 Pobieranie osobistych statystyk pracownika:', user.id, user.role);\n            // Sprawdź czy użytkownik to pracownik\n            if (user.role !== 'pracownik') {\n                console.error('❌ Nieautoryzowana rola:', user.role);\n                throw new Error('Dostęp tylko dla pracowników');\n            }\n            console.log('✅ Użytkownik autoryzowany jako pracownik');\n            const currentDate = new Date();\n            const currentMonth = currentDate.toISOString().slice(0, 7) // YYYY-MM\n            ;\n            // Ustaw pierwszy i ostatni dzień miesiąca prawidłowo\n            const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);\n            const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0, 23, 59, 59);\n            // 1. Pobierz liczbę telefonów w tym miesiącu (kliknięcia telefonu)\n            const { data: phoneClicks, error: phoneError } = await supabase.from('activity_logs').select('id, timestamp').eq('changed_by', user.id).eq('field_changed', 'last_phone_click').gte('timestamp', startOfMonth.toISOString()).lte('timestamp', endOfMonth.toISOString());\n            if (phoneError) {\n                console.error('❌ Błąd pobierania kliknięć telefonu:', phoneError);\n                throw phoneError;\n            }\n            const phoneCallsThisMonth = (phoneClicks === null || phoneClicks === void 0 ? void 0 : phoneClicks.length) || 0;\n            console.log(\"\\uD83D\\uDCDE Znaleziono \".concat(phoneCallsThisMonth, \" kliknięć telefonu w tym miesiącu\"));\n            // 2. Pobierz klientów przypisanych do pracownika\n            console.log('👥 Pobieranie klientów przypisanych do pracownika...');\n            const { data: myClients, error: clientsError } = await supabase.from('clients').select('id, status, first_name, last_name, company_name').eq('owner_id', user.id);\n            if (clientsError) {\n                console.error('❌ Błąd pobierania klientów:', clientsError);\n                throw clientsError;\n            }\n            const clients = myClients || [];\n            const totalClients = clients.length;\n            console.log(\"\\uD83D\\uDC64 Pracownik ma \".concat(totalClients, \" przypisanych klient\\xf3w\"));\n            // 3. Agreguj statusy klientów\n            console.log('📊 Agregowanie statusów klientów...');\n            const statusMap = new Map();\n            clients.forEach((client)=>{\n                const status = client.status;\n                statusMap.set(status, (statusMap.get(status) || 0) + 1);\n            });\n            console.log('📈 Statusy klientów:', Object.fromEntries(statusMap));\n            // Mapuj statusy na kolory\n            const statusColors = {\n                canvas: '#06b6d4',\n                sale: '#10b981',\n                antysale: '#f59e0b',\n                brak_kontaktu: '#6b7280',\n                nie_zainteresowany: '#ef4444',\n                zdenerwowany: '#dc2626',\n                '$$': '#fbbf24'\n            };\n            const clientStats = Array.from(statusMap.entries()).map((param)=>{\n                let [status, count] = param;\n                return {\n                    status,\n                    count,\n                    color: statusColors[status] || '#64748b'\n                };\n            });\n            // 4. Pobierz prowizję z tabeli employee_stats\n            console.log('💰 Pobieranie prowizji z tabeli employee_stats...');\n            let commissionTotal = 0 // w EUR\n            ;\n            try {\n                const { data: employeeStats, error: statsError } = await supabase.from('employee_stats').select('total_commissions').eq('user_id', user.id).single();\n                if (statsError) {\n                    console.warn('⚠️ Nie znaleziono statystyk pracownika, prowizja = 0:', statsError);\n                    commissionTotal = 0;\n                } else {\n                    // total_commissions już jest w EUR - używaj bezpośrednio\n                    commissionTotal = employeeStats.total_commissions || 0;\n                    console.log(\"\\uD83D\\uDCB0 Prowizja pobrana z bazy: \".concat(commissionTotal, \" EUR\"));\n                }\n            } catch (error) {\n                console.error('❌ Błąd pobierania prowizji z employee_stats:', error);\n                commissionTotal = 0;\n            }\n            // 5. Pobierz godziny pracy z tego miesiąca na podstawie activity_logs\n            console.log('⏰ Pobieranie aktywności z tego miesiąca...');\n            console.log(\"\\uD83D\\uDCC5 Zakres dat: \".concat(startOfMonth.toISOString(), \" - \").concat(endOfMonth.toISOString()));\n            const { data: activities, error: activitiesError } = await supabase.from('activity_logs').select('timestamp').eq('changed_by', user.id).gte('timestamp', startOfMonth.toISOString()).lte('timestamp', endOfMonth.toISOString()).order('timestamp', {\n                ascending: true\n            });\n            if (activitiesError) {\n                console.error('❌ Błąd pobierania aktywności:', activitiesError);\n                throw activitiesError;\n            }\n            console.log(\"⏰ Znaleziono \".concat((activities === null || activities === void 0 ? void 0 : activities.length) || 0, \" aktywności w tym miesiącu\"));\n            // Grupuj aktywności według dni i oblicz godziny pracy\n            console.log('📅 Grupowanie aktywności według dni...');\n            const dailyActivities = new Map();\n            if (activities && activities.length > 0) {\n                activities.forEach((activity)=>{\n                    const date = new Date(activity.timestamp);\n                    const day = date.toISOString().split('T')[0] // YYYY-MM-DD\n                    ;\n                    const hour = date.getHours();\n                    if (!dailyActivities.has(day)) {\n                        dailyActivities.set(day, new Set());\n                    }\n                    dailyActivities.get(day).add(hour);\n                });\n            }\n            // Przekształć na format dla wykresu\n            const workingHoursThisMonth = Array.from(dailyActivities.entries()).map((param)=>{\n                let [day, hours] = param;\n                return {\n                    day: new Date(day).toLocaleDateString('pl-PL', {\n                        weekday: 'short',\n                        day: 'numeric'\n                    }),\n                    hours: hours.size,\n                    sortDate: new Date(day) // Dodaj pole do sortowania\n                };\n            }).sort((a, b)=>a.sortDate.getTime() - b.sortDate.getTime()).map((param)=>{\n                let { day, hours } = param;\n                return {\n                    day,\n                    hours\n                };\n            }) // Usuń pole sortDate z wynikowych danych\n            ;\n            const totalWorkingHours = Array.from(dailyActivities.values()).reduce((sum, hours)=>sum + hours.size, 0);\n            const totalWorkingDays = dailyActivities.size;\n            console.log('✅ Statystyki osobiste przygotowane:', {\n                phoneCallsThisMonth,\n                totalClients,\n                commissionTotal,\n                totalWorkingHours,\n                totalWorkingDays\n            });\n            return {\n                phoneCallsThisMonth,\n                clientStats,\n                totalClients,\n                commissionTotal,\n                workingHoursThisMonth,\n                totalWorkingHours,\n                totalWorkingDays\n            };\n        } catch (error) {\n            var _error_message, _error_message1;\n            console.error('❌ Błąd pobierania osobistych statystyk:', error);\n            // Szczegółowe informacje o błędzie\n            if (error && typeof error === 'object') {\n                console.error('📋 Szczegóły błędu:', {\n                    message: error.message,\n                    code: error.code,\n                    details: error.details,\n                    hint: error.hint,\n                    stack: error.stack\n                });\n            }\n            // Jeśli to błąd RLS lub uprawnień, zwróć pustą strukturę zamiast crashować\n            if (error && typeof error === 'object' && (error.code === 'PGRST116' || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('RLS')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('permission')))) {\n                console.warn('🔒 Problem z uprawnieniami - zwracam domyślne dane');\n                return {\n                    phoneCallsThisMonth: 0,\n                    clientStats: [],\n                    totalClients: 0,\n                    commissionTotal: 0,\n                    workingHoursThisMonth: [],\n                    totalWorkingHours: 0,\n                    totalWorkingDays: 0\n                };\n            }\n            throw error;\n        }\n    },\n    // Funkcje do zarządzania godzinami pracy pracownika\n    async saveWorkingHours (user, date, hours) {\n        try {\n            console.log(\"⏰ Zapisywanie godzin pracy: \".concat(hours, \"h dla dnia \").concat(date));\n            // Sprawdź czy użytkownik to pracownik\n            if (user.role !== 'pracownik') {\n                throw new Error('Dostęp tylko dla pracowników');\n            }\n            // ENHANCED DEBUG: Sprawdź czy to dzień roboczy (pon-pt) - bezpieczne parsowanie daty\n            console.log('\\uD83D\\uDD0D DEBUG: Input date string: \"'.concat(date, '\"'));\n            const dateParts = date.split('-') // \"2025-06-02\" -> [\"2025\", \"06\", \"02\"]\n            ;\n            console.log(\"\\uD83D\\uDD0D DEBUG: Date parts:\", dateParts);\n            const year = parseInt(dateParts[0]);\n            const month = parseInt(dateParts[1]) - 1 // -1 bo JavaScript używa 0-11 dla miesięcy\n            ;\n            const day = parseInt(dateParts[2]);\n            console.log(\"\\uD83D\\uDD0D DEBUG: Parsed components: year=\".concat(year, \", month=\").concat(month, \" (JS format), day=\").concat(day));\n            const dateObj = new Date(year, month, day);\n            const dayOfWeek = dateObj.getDay();\n            console.log(\"\\uD83D\\uDD0D DEBUG: Created Date object: \".concat(dateObj.toISOString()));\n            console.log(\"\\uD83D\\uDD0D DEBUG: Date in local format: \".concat(dateObj.toLocaleDateString('pl-PL', {\n                weekday: 'long',\n                year: 'numeric',\n                month: 'long',\n                day: 'numeric'\n            })));\n            console.log(\"\\uD83D\\uDDD3️ Sprawdzanie dnia roboczego: \".concat(date, \" => dayOfWeek=\").concat(dayOfWeek, \" (\").concat([\n                'niedziela',\n                'poniedziałek',\n                'wtorek',\n                'środa',\n                'czwartek',\n                'piątek',\n                'sobota'\n            ][dayOfWeek], \")\"));\n            if (dayOfWeek === 0 || dayOfWeek === 6) {\n                console.error(\"❌ BŁĄD: Pr\\xf3ba zapisania godzin dla weekendu! Dzień tygodnia: \".concat(dayOfWeek, \" (\").concat([\n                    'niedziela',\n                    'poniedziałek',\n                    'wtorek',\n                    'środa',\n                    'czwartek',\n                    'piątek',\n                    'sobota'\n                ][dayOfWeek], \")\"));\n                throw new Error('Można wpisywać godziny tylko dla dni roboczych (pon-pt)');\n            }\n            console.log(\"✅ Dzień roboczy potwierdzony: \".concat([\n                'niedziela',\n                'poniedziałek',\n                'wtorek',\n                'środa',\n                'czwartek',\n                'piątek',\n                'sobota'\n            ][dayOfWeek]));\n            // Walidacja godzin (0-12)\n            if (hours < 0 || hours > 12) {\n                throw new Error('Liczba godzin musi być między 0 a 12');\n            }\n            // Upsert godzin pracy w bazie danych (tabela już istnieje)\n            const { error } = await supabase.from('working_hours').upsert({\n                user_id: user.id,\n                work_date: date,\n                hours_worked: hours,\n                updated_at: new Date().toISOString()\n            }, {\n                onConflict: 'user_id,work_date'\n            });\n            if (error) {\n                console.error('❌ Błąd zapisywania godzin pracy do bazy:', error);\n                // Fallback do localStorage tylko przy błędzie bazy danych\n                console.warn('⚠️ Błąd bazy danych - używam localStorage jako fallback');\n                const storageKey = \"working_hours_\".concat(user.id);\n                const existingData = JSON.parse(localStorage.getItem(storageKey) || '{}');\n                existingData[date] = hours;\n                localStorage.setItem(storageKey, JSON.stringify(existingData));\n                console.log(\"✅ Zapisano \".concat(hours, \"h dla dnia \").concat(date, \" (localStorage fallback)\"));\n                return;\n            }\n            console.log(\"✅ Zapisano \".concat(hours, \"h dla dnia \").concat(date, \" (baza danych working_hours)\"));\n        } catch (error) {\n            console.error('❌ Błąd w saveWorkingHours:', error);\n            // Ultimate fallback - localStorage\n            try {\n                console.warn('⚠️ Używam localStorage jako ostateczny fallback');\n                const storageKey = \"working_hours_\".concat(user.id);\n                const existingData = JSON.parse(localStorage.getItem(storageKey) || '{}');\n                existingData[date] = hours;\n                localStorage.setItem(storageKey, JSON.stringify(existingData));\n                console.log(\"✅ Zapisano \".concat(hours, \"h dla dnia \").concat(date, \" (localStorage ultimate fallback)\"));\n            } catch (storageError) {\n                console.error('❌ Nie udało się zapisać nawet do localStorage:', storageError);\n                throw error;\n            }\n        }\n    },\n    async getWorkingHoursForMonth (user, year, month) {\n        try {\n            console.log(\"⏰ Pobieranie godzin pracy dla \".concat(year, \"-\").concat(month));\n            // Sprawdź czy użytkownik to pracownik\n            if (user.role !== 'pracownik') {\n                throw new Error('Dostęp tylko dla pracowników');\n            }\n            // Oblicz pierwszy i ostatni dzień miesiąca (poprawka strefy czasowej)\n            const startDate = \"\".concat(year, \"-\").concat(month.toString().padStart(2, '0'), \"-01\");\n            const endDate = \"\".concat(year, \"-\").concat(month.toString().padStart(2, '0'), \"-\").concat(new Date(year, month, 0).getDate().toString().padStart(2, '0'));\n            console.log(\"\\uD83D\\uDCC5 Pobieranie godzin dla zakresu: \".concat(startDate, \" - \").concat(endDate));\n            // Pobierz godziny pracy z tabeli working_hours (tabela już istnieje)\n            const { data, error } = await supabase.from('working_hours').select('work_date, hours_worked').eq('user_id', user.id).gte('work_date', startDate).lte('work_date', endDate);\n            if (error) {\n                console.error('❌ Błąd pobierania godzin pracy z bazy:', error);\n                console.warn('⚠️ Błąd bazy danych - używam localStorage jako fallback');\n                // Fallback do localStorage tylko przy błędzie bazy danych\n                const storageKey = \"working_hours_\".concat(user.id);\n                const storedData = JSON.parse(localStorage.getItem(storageKey) || '{}');\n                // Filtruj dane dla odpowiedniego miesiąca\n                const hoursMap = {};\n                Object.entries(storedData).forEach((param)=>{\n                    let [date, hours] = param;\n                    // Użyj porównania stringów dla dat w formacie YYYY-MM-DD\n                    if (date >= startDate && date <= endDate) {\n                        hoursMap[date] = hours;\n                    }\n                });\n                console.log(\"✅ Pobrano godziny pracy z localStorage fallback dla \".concat(Object.keys(hoursMap).length, \" dni\"));\n                return hoursMap;\n            }\n            // Konwertuj na obiekt date -> hours\n            const hoursMap = {};\n            if (data) {\n                data.forEach((entry)=>{\n                    hoursMap[entry.work_date] = entry.hours_worked;\n                });\n            }\n            console.log(\"✅ Pobrano godziny pracy z tabeli working_hours dla \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" dni\"));\n            return hoursMap;\n        } catch (error) {\n            console.error('❌ Błąd w getWorkingHoursForMonth:', error);\n            // Ultimate fallback - localStorage\n            try {\n                console.warn('⚠️ Używam localStorage jako ostateczny fallback');\n                const storageKey = \"working_hours_\".concat(user.id);\n                const storedData = JSON.parse(localStorage.getItem(storageKey) || '{}');\n                // Filtruj dane dla odpowiedniego miesiąca\n                const startDateStr = \"\".concat(year, \"-\").concat(month.toString().padStart(2, '0'), \"-01\");\n                const endDateStr = \"\".concat(year, \"-\").concat(month.toString().padStart(2, '0'), \"-\").concat(new Date(year, month, 0).getDate().toString().padStart(2, '0'));\n                const hoursMap = {};\n                Object.entries(storedData).forEach((param)=>{\n                    let [date, hours] = param;\n                    // Użyj porównania stringów dla dat w formacie YYYY-MM-DD\n                    if (date >= startDateStr && date <= endDateStr) {\n                        hoursMap[date] = hours;\n                    }\n                });\n                console.log(\"✅ Pobrano godziny pracy z localStorage ultimate fallback dla \".concat(Object.keys(hoursMap).length, \" dni\"));\n                return hoursMap;\n            } catch (storageError) {\n                console.error('❌ Nie udało się pobrać nawet z localStorage:', storageError);\n                return {};\n            }\n        }\n    },\n    // 🚀 NOWE FUNKCJE PERFORMANCE - Materializowane Widoki\n    // Zastępuje ciężkie JOIN'y - teraz natychmiastowe ładowanie\n    async getMonthlyEmployeePerformance (year, month) {\n        try {\n            console.log(\"\\uD83D\\uDCCA Pobieranie wydajności pracownik\\xf3w dla \".concat(year, \"-\").concat(month, \" (zoptymalizowane)...\"));\n            const { data, error } = await supabase.rpc('get_monthly_employee_performance', {\n                target_year: year,\n                target_month: month\n            });\n            if (error) {\n                console.error('❌ Błąd pobierania wydajności pracowników:', error);\n                throw error;\n            }\n            console.log(\"✅ Wydajność pracownik\\xf3w pobrana: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" rekord\\xf3w\"));\n            return data;\n        } catch (error) {\n            console.error('❌ getMonthlyEmployeePerformance failed:', error);\n            throw error;\n        }\n    },\n    // Szybkie statystyki zespołu na podstawie materializowanych widoków\n    async getTeamSummary (year, month) {\n        try {\n            const { data, error } = await supabase.from('mv_monthly_employee_stats').select('*').eq('year', year).eq('month', month).order('owned_sales', {\n                ascending: false\n            });\n            if (error) throw error;\n            return data;\n        } catch (error) {\n            console.error('❌ getTeamSummary failed:', error);\n            throw error;\n        }\n    },\n    // Performance analytics - top performers\n    async getTopPerformers () {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        try {\n            const { data, error } = await supabase.rpc('get_top_performers', {\n                limit_count: limit\n            });\n            if (error) throw error;\n            return data;\n        } catch (error) {\n            console.error('❌ getTopPerformers failed:', error);\n            throw error;\n        }\n    }\n};\n// API dla lokalizacji/krajów\nconst locationsApi = {\n    // Pobierz wszystkie lokalizacje (podstawowe informacje - dla rejestracji)\n    async getAllLocations () {\n        try {\n            const { data, error } = await supabase.from('locations').select(\"\\n          id,\\n          name,\\n          code,\\n          currency,\\n          timezone,\\n          region,\\n          created_at,\\n          updated_at\\n        \").order('name');\n            if (error) {\n                console.error('❌ Błąd pobierania lokalizacji:', error);\n                throw error;\n            }\n            console.log('✅ Pobrano lokalizacje:', (data === null || data === void 0 ? void 0 : data.length) || 0);\n            return data;\n        } catch (error) {\n            console.error('❌ getAllLocations failed:', error);\n            throw error;\n        }\n    },\n    // Pobierz wszystkie lokalizacje z pełnymi informacjami (dla zalogowanych użytkowników)\n    async getAllLocationsWithManagers () {\n        const { data, error } = await supabase.from('locations').select(\"\\n        id,\\n        name,\\n        code,\\n        currency,\\n        timezone,\\n        region,\\n        project_manager_id,\\n        created_at,\\n        updated_at,\\n        project_manager:users!project_manager_id (\\n          id,\\n          full_name,\\n          email,\\n          avatar_url\\n        )\\n      \").order('name');\n        if (error) throw error;\n        // Przekształć dane - Supabase JOIN zwraca project_manager jako tablicę\n        const transformedData = data === null || data === void 0 ? void 0 : data.map((location)=>({\n                ...location,\n                project_manager: location.project_manager && Array.isArray(location.project_manager) && location.project_manager.length > 0 ? location.project_manager[0] // Weź pierwszy element z tablicy\n                 : location.project_manager && !Array.isArray(location.project_manager) ? location.project_manager // Już jest pojedynczym obiektem\n                 : null // Brak project managera\n            }));\n        return transformedData;\n    },\n    // Pobierz dostępne lokalizacje dla użytkownika\n    async getUserAccessibleLocations (userId) {\n        try {\n            // Najpierw spróbuj użyć funkcji SQL (jeśli istnieje)\n            const { data, error } = await supabase.rpc('get_user_accessible_locations', {\n                user_id: userId\n            });\n            if (error) {\n                console.warn('🔄 Funkcja SQL get_user_accessible_locations nie istnieje, używam fallback logiki');\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.warn('⚠️ Błąd wywołania funkcji SQL, używam JavaScript fallback:', error);\n            // Fallback - implementacja logiki w JavaScript\n            try {\n                // Pobierz użytkownika\n                const { data: user, error: userError } = await supabase.from('users').select('role, location_id').eq('id', userId).single();\n                if (userError) {\n                    console.error('❌ Nie można pobrać danych użytkownika:', userError);\n                    return this.getAllLocations() // Fallback - zwróć wszystkie\n                    ;\n                }\n                // Sprawdź rolę użytkownika\n                if (user.role === 'admin' || user.role === 'szef') {\n                    // Admin i szef widzą wszystkie lokalizacje\n                    console.log('👑 Admin/Szef - zwracam wszystkie lokalizacje');\n                    return this.getAllLocations();\n                } else {\n                    // Pozostali widzą tylko swoją lokalizację\n                    if (!user.location_id) {\n                        console.warn('⚠️ Użytkownik nie ma przypisanej lokalizacji');\n                        return [];\n                    }\n                    console.log('👤 Zwykły użytkownik - zwracam lokalizację:', user.location_id);\n                    const { data: location, error: locationError } = await supabase.from('locations').select('*').eq('id', user.location_id).single();\n                    if (locationError) {\n                        console.error('❌ Nie można pobrać lokalizacji użytkownika:', locationError);\n                        return [];\n                    }\n                    return [\n                        location\n                    ];\n                }\n            } catch (fallbackError) {\n                console.error('❌ Fallback logic failed:', fallbackError);\n                // Ostateczny fallback - wszystkie lokalizacje\n                return this.getAllLocations();\n            }\n        }\n    },\n    // Pobierz lokalizację po ID\n    async getLocationById (id) {\n        const { data, error } = await supabase.from('locations').select(\"\\n        id,\\n        name,\\n        code,\\n        currency,\\n        timezone,\\n        region,\\n        project_manager_id,\\n        created_at,\\n        updated_at,\\n        project_manager:users!project_manager_id (\\n          id,\\n          full_name,\\n          email,\\n          avatar_url\\n        )\\n      \").eq('id', id).single();\n        if (error) throw error;\n        // Przekształć dane - Supabase JOIN zwraca project_manager jako tablicę\n        const transformedData = {\n            ...data,\n            project_manager: data.project_manager && Array.isArray(data.project_manager) && data.project_manager.length > 0 ? data.project_manager[0] // Weź pierwszy element z tablicy\n             : data.project_manager && !Array.isArray(data.project_manager) ? data.project_manager // Już jest pojedynczym obiektem\n             : null // Brak project managera\n        };\n        return transformedData;\n    },\n    // Aktualizuj project managera dla lokalizacji\n    async updateLocationProjectManager (locationId, projectManagerId, currentUser) {\n        if (!permissionsApi.canChangeRoles(currentUser)) {\n            throw new Error('Brak uprawnień do zmiany project managera');\n        }\n        const { data, error } = await supabase.from('locations').update({\n            project_manager_id: projectManagerId,\n            updated_at: new Date().toISOString()\n        }).eq('id', locationId).select().single();\n        if (error) throw error;\n        return data;\n    }\n};\n// Funkcje autoryzacji\nconst authApi = {\n    // Zaloguj użytkownika\n    async signIn (email, password) {\n        const { data, error } = await supabase.auth.signInWithPassword({\n            email,\n            password\n        });\n        if (error) throw error;\n        return data;\n    },\n    // Zarejestruj nowego użytkownika\n    async signUp (email, password, fullName, locationId) {\n        const { data, error } = await supabase.auth.signUp({\n            email,\n            password,\n            options: {\n                data: {\n                    full_name: fullName,\n                    location_id: locationId\n                }\n            }\n        });\n        if (error) throw error;\n        return data;\n    },\n    // Wyloguj użytkownika\n    async signOut () {\n        const { error } = await supabase.auth.signOut();\n        if (error) throw error;\n    },\n    // Pobierz aktualnego użytkownika\n    async getCurrentUser () {\n        const { data: { user } } = await supabase.auth.getUser();\n        return user;\n    },\n    // Pobierz profil użytkownika z rolą\n    async getUserProfile (userId) {\n        const { data, error } = await supabase.from('users').select('*').eq('id', userId).single();\n        if (error) throw error;\n        return data;\n    },\n    // Pobierz wszystkich użytkowników (dla opcji filtrowania)\n    async getAllUsers () {\n        try {\n            console.log('👥 getAllUsers START - sprawdzam RLS...');\n            // Sprawdź aktualnego użytkownika\n            const { data: { user } } = await supabase.auth.getUser();\n            console.log('👤 Aktualny użytkownik:', user === null || user === void 0 ? void 0 : user.email, user === null || user === void 0 ? void 0 : user.id);\n            const { data, error } = await supabase.from('users').select('id, full_name, email, role, avatar_url').order('full_name');\n            console.log('👥 getAllUsers - znaleziono użytkowników:', (data === null || data === void 0 ? void 0 : data.length) || 0);\n            console.log('👥 getAllUsers - błąd:', error);\n            if (error) {\n                var _error_message, _error_message1;\n                console.error('❌ RLS Error in getAllUsers:', error);\n                // Sprawdź czy to problem z RLS\n                if (error.code === 'PGRST116' || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('RLS')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('permission'))) {\n                    console.error('🔒 Problem z Row Level Security - pracownik nie może widzieć innych użytkowników');\n                }\n                throw error;\n            }\n            if (data && data.length > 0) {\n                console.log('👥 Przykład użytkowników:', data.slice(0, 3).map((u)=>({\n                        id: u.id,\n                        name: u.full_name,\n                        role: u.role\n                    })));\n            } else {\n                console.log('👥 UWAGA: Brak danych użytkowników - może RLS blokuje dostęp');\n            }\n            return data;\n        } catch (error) {\n            console.error('❌ getAllUsers FAILED:', error);\n            throw error;\n        }\n    },\n    // Sprawdź sesję użytkownika\n    async getSession () {\n        const { data: { session } } = await supabase.auth.getSession();\n        return session;\n    },\n    // Nasłuchuj zmian w autoryzacji\n    onAuthStateChange (callback) {\n        return supabase.auth.onAuthStateChange(callback);\n    },\n    // Zaktualizuj język użytkownika\n    async updateUserLanguage (userId, language) {\n        const { data, error } = await supabase.from('users').update({\n            language\n        }).eq('id', userId).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Bezpieczne pobieranie użytkowników do wyświetlania (odporne na RLS)\n    async getAllUsersForDisplay () {\n        try {\n            console.log('👥 getAllUsersForDisplay START - bezpieczne pobieranie...');\n            // Sprawdź aktualnego użytkownika\n            const { data: { user } } = await supabase.auth.getUser();\n            console.log('👤 Aktualny użytkownik:', user === null || user === void 0 ? void 0 : user.email, user === null || user === void 0 ? void 0 : user.id);\n            if (!user) {\n                console.log('❌ Brak zalogowanego użytkownika');\n                return [];\n            }\n            const { data, error } = await supabase.from('users').select('id, full_name, email, role, avatar_url').order('full_name');\n            console.log('👥 getAllUsersForDisplay - znaleziono użytkowników:', (data === null || data === void 0 ? void 0 : data.length) || 0);\n            if (error) {\n                var _error_message, _error_message1;\n                console.error('❌ RLS Error in getAllUsersForDisplay:', error);\n                // Jeśli to problem z RLS, zwróć przynajmniej aktualnego użytkownika\n                if (error.code === 'PGRST116' || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('RLS')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('permission'))) {\n                    console.error('🔒 RLS blokuje dostęp - zwracam tylko aktualnego użytkownika');\n                    // Pobierz profil aktualnego użytkownika\n                    try {\n                        const userProfile = await this.getUserProfile(user.id);\n                        console.log('👤 Fallback: używam profilu aktualnego użytkownika:', userProfile.full_name);\n                        return [\n                            userProfile\n                        ];\n                    } catch (profileError) {\n                        console.error('❌ Nie można pobrać profilu użytkownika:', profileError);\n                        return [];\n                    }\n                }\n                // Inny błąd - zwróć pustą tablicę\n                console.error('❌ Inny błąd - zwracam pustą tablicę');\n                return [];\n            }\n            if (data && data.length > 0) {\n                console.log('👥 Udane pobranie użytkowników:', data.length);\n                console.log('👥 Przykład użytkowników:', data.slice(0, 3).map((u)=>({\n                        id: u.id,\n                        name: u.full_name,\n                        role: u.role\n                    })));\n                return data;\n            } else {\n                console.log('👥 UWAGA: Brak danych użytkowników');\n                // Fallback - przynajmniej aktualny użytkownik\n                try {\n                    const userProfile = await this.getUserProfile(user.id);\n                    console.log('👤 Fallback: używam profilu aktualnego użytkownika:', userProfile.full_name);\n                    return [\n                        userProfile\n                    ];\n                } catch (profileError) {\n                    console.error('❌ Nie można pobrać profilu użytkownika:', profileError);\n                    return [];\n                }\n            }\n        } catch (error) {\n            console.error('❌ getAllUsersForDisplay CRITICAL ERROR:', error);\n            // Krytyczny fallback - spróbuj przynajmniej pobrać aktualnego użytkownika\n            try {\n                const { data: { user } } = await supabase.auth.getUser();\n                if (user) {\n                    const userProfile = await this.getUserProfile(user.id);\n                    console.log('👤 Krytyczny fallback: zwracam aktualnego użytkownika:', userProfile.full_name);\n                    return [\n                        userProfile\n                    ];\n                }\n            } catch (criticalError) {\n                console.error('❌ Krytyczny błąd fallback:', criticalError);\n            }\n            return [];\n        }\n    }\n};\n// Funkcja do określania koloru statusu \"canvas\" na podstawie czasu\nconst getCanvasStatusColor = (statusChangedAt)=>{\n    if (!statusChangedAt) {\n        return {\n            color: 'bg-blue-500/20 text-blue-400 border-blue-500/30',\n            description: 'Nowy',\n            priority: 'low'\n        };\n    }\n    const now = new Date();\n    const statusDate = new Date(statusChangedAt);\n    const daysDiff = Math.floor((now.getTime() - statusDate.getTime()) / (1000 * 60 * 60 * 24));\n    if (daysDiff <= 2) {\n        // 0-2 dni - zielony (świeży)\n        return {\n            color: 'bg-green-500/20 text-green-400 border-green-500/30',\n            description: \"Świeży (\".concat(daysDiff, \"d)\"),\n            priority: 'low'\n        };\n    } else if (daysDiff <= 4) {\n        // 2-4 dni - żółty (uwaga)\n        return {\n            color: 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30',\n            description: \"Wymaga uwagi (\".concat(daysDiff, \"d)\"),\n            priority: 'medium'\n        };\n    } else {\n        // 5+ dni - czerwony (pilny)\n        return {\n            color: 'bg-red-500/20 text-red-400 border-red-500/30',\n            description: \"Pilny (\".concat(daysDiff, \"d)\"),\n            priority: 'high'\n        };\n    }\n};\n// Funkcja do pobierania klientów z oznaczeniami priorytetów\nconst getCanvasClientsWithPriority = async (user)=>{\n    try {\n        const clients = await clientsApi.getClients(user);\n        const canvasClients = clients.filter((client)=>client.status === 'canvas');\n        const priorityStats = {\n            high: 0,\n            medium: 0,\n            low: 0,\n            total: canvasClients.length\n        };\n        canvasClients.forEach((client)=>{\n            const { priority } = getCanvasStatusColor(client.status_changed_at);\n            priorityStats[priority]++;\n        });\n        return {\n            clients: canvasClients,\n            stats: priorityStats\n        };\n    } catch (error) {\n        console.error('Błąd pobierania klientów canvas:', error);\n        return {\n            clients: [],\n            stats: {\n                high: 0,\n                medium: 0,\n                low: 0,\n                total: 0\n            }\n        };\n    }\n};\n// 🚀 NOWE API PERFORMANCE - Materializowane Widoki i Optymalizacje\n// Dodane zgodnie z INSTRUKCJE_PERFORMANCE_OPTIMIZATIONS.md\nconst dashboardApi = {\n    // Zastępuje wolne zapytania dashboard - teraz ~10ms zamiast ~200ms\n    async getDashboardMetrics () {\n        try {\n            console.log('⚡ Pobieranie szybkich metryk dashboard z materializowanego widoku...');\n            const { data, error } = await supabase.rpc('get_dashboard_metrics');\n            if (error) {\n                console.error('❌ Błąd pobierania metryk dashboard:', error);\n                throw error;\n            }\n            console.log('✅ Dashboard metrics pobrane w trybie express:', (data === null || data === void 0 ? void 0 : data.length) || 0, 'metryk');\n            return data;\n        } catch (error) {\n            console.error('❌ getDashboardMetrics failed:', error);\n            throw error;\n        }\n    },\n    // Sprawdzenie czy materializowane widoki są świeże\n    async checkViewFreshness () {\n        try {\n            // Sprawdź czy tabela mv_dashboard_summary istnieje\n            const { data, error } = await supabase.from('mv_dashboard_summary').select('last_updated').limit(1).single();\n            if (error) {\n                console.warn('⚠️ Materialized view mv_dashboard_summary nie istnieje lub brak uprawnień:', error);\n                // Fallback - użyj aktualnego czasu\n                return {\n                    lastUpdate: new Date().toISOString(),\n                    minutesSinceUpdate: 0,\n                    isStale: false // Założ że dane są świeże jeśli nie ma widoku\n                };\n            }\n            const lastUpdate = new Date(data.last_updated);\n            const now = new Date();\n            const minutesSinceUpdate = Math.floor((now.getTime() - lastUpdate.getTime()) / (1000 * 60));\n            return {\n                lastUpdate: data.last_updated,\n                minutesSinceUpdate,\n                isStale: minutesSinceUpdate > 30 // Uznaj za nieaktualne po 30 minutach\n            };\n        } catch (error) {\n            console.error('❌ Błąd sprawdzania świeżości widoków:', error);\n            // Graceful fallback\n            return {\n                lastUpdate: new Date().toISOString(),\n                minutesSinceUpdate: 0,\n                isStale: false\n            };\n        }\n    }\n};\n// 🚀 NOWE FUNKCJE PERFORMANCE dodane do istniejącego reportsApi\nconst teamApi = {\n    // Szybki przegląd aktywności zespołu\n    async getTeamActivityOverview () {\n        try {\n            console.log('👥 Pobieranie przeglądu aktywności zespołu (zoptymalizowane)...');\n            const { data, error } = await supabase.from('mv_activity_summary').select('*').in('role', [\n                'pracownik',\n                'manager',\n                'project_manager',\n                'junior_manager',\n                'szef'\n            ]).order('activities_24h', {\n                ascending: false\n            });\n            if (error) {\n                console.error('❌ Błąd pobierania aktywności zespołu:', error);\n                throw error;\n            }\n            console.log(\"✅ Aktywność zespołu pobrana: \".concat((data === null || data === void 0 ? void 0 : data.length) || 0, \" użytkownik\\xf3w\"));\n            return data;\n        } catch (error) {\n            console.error('❌ getTeamActivityOverview failed:', error);\n            throw error;\n        }\n    },\n    // Sprawdzenie aktywnych użytkowników w czasie rzeczywistym\n    async getActiveUsersNow () {\n        try {\n            const { data, error } = await supabase.from('mv_activity_summary').select('user_id, full_name, activity_status, last_activity').eq('activity_status', 'active').order('last_activity', {\n                ascending: false\n            });\n            if (error) throw error;\n            return data;\n        } catch (error) {\n            console.error('❌ getActiveUsersNow failed:', error);\n            throw error;\n        }\n    },\n    // Statystyki produktywności zespołu\n    async getProductivityStats () {\n        try {\n            const { data, error } = await supabase.from('mv_activity_summary').select('activities_24h, activities_7d, phone_clicks, status_changes').in('role', [\n                'pracownik',\n                'manager',\n                'project_manager',\n                'junior_manager',\n                'szef'\n            ]);\n            if (error) throw error;\n            // Oblicz średnie\n            const totalUsers = data.length;\n            const avgDaily = data.reduce((sum, user)=>sum + user.activities_24h, 0) / totalUsers;\n            const avgWeekly = data.reduce((sum, user)=>sum + user.activities_7d, 0) / totalUsers;\n            return {\n                totalUsers,\n                avgDailyActivities: Math.round(avgDaily),\n                avgWeeklyActivities: Math.round(avgWeekly),\n                totalDailyActivities: data.reduce((sum, user)=>sum + user.activities_24h, 0),\n                totalWeeklyActivities: data.reduce((sum, user)=>sum + user.activities_7d, 0)\n            };\n        } catch (error) {\n            console.error('❌ getProductivityStats failed:', error);\n            throw error;\n        }\n    }\n};\n// 🔧 PERFORMANCE MONITORING API\nconst performanceApi = {\n    // Sprawdzenie metryk wydajności systemu\n    async getSystemMetrics () {\n        try {\n            console.log('🔍 Pobieranie metryk wydajności systemu...');\n            const tableStats = [];\n            // Pomocnicza funkcja do bezpiecznego pobierania statystyk tabeli\n            const getTableStats = async (tableName)=>{\n                try {\n                    const { count, error } = await supabase.from(tableName).select('*', {\n                        count: 'exact',\n                        head: true\n                    });\n                    if (error) {\n                        console.warn(\"⚠️ Nie można pobrać statystyk tabeli \".concat(tableName, \":\"), error.message);\n                        return null;\n                    }\n                    return {\n                        table_name: tableName,\n                        record_count: count || 0,\n                        table_size: 'N/A',\n                        last_updated: new Date().toISOString()\n                    };\n                } catch (err) {\n                    console.warn(\"⚠️ Błąd tabeli \".concat(tableName, \":\"), err);\n                    return null;\n                }\n            };\n            // Sprawdź każdą tabelę oddzielnie\n            const tables = [\n                'clients',\n                'users',\n                'activity_logs',\n                'activity_logs_archive'\n            ];\n            for (const tableName of tables){\n                const stats = await getTableStats(tableName);\n                if (stats) {\n                    tableStats.push(stats);\n                }\n            }\n            // Jeśli nie udało się pobrać żadnych statystyk, zwróć podstawowe informacje\n            if (tableStats.length === 0) {\n                console.warn('⚠️ Nie udało się pobrać statystyk żadnej tabeli - zwracam dane przykładowe');\n                tableStats.push({\n                    table_name: 'system_info',\n                    record_count: 0,\n                    table_size: 'Brak dostępu',\n                    last_updated: new Date().toISOString()\n                });\n            }\n            console.log(\"✅ Pobrano statystyki \".concat(tableStats.length, \" tabel\"));\n            return tableStats;\n        } catch (error) {\n            console.error('❌ getSystemMetrics failed:', error);\n            // Graceful fallback - zwróć podstawowe dane zamiast rzucać błąd\n            return [\n                {\n                    table_name: 'error_fallback',\n                    record_count: 0,\n                    table_size: 'Błąd połączenia',\n                    last_updated: new Date().toISOString()\n                }\n            ];\n        }\n    },\n    // Manualne odświeżenie materializowanych widoków\n    async refreshMaterializedViews () {\n        try {\n            console.log('🔄 Manualnie odświeżam materializowane widoki...');\n            const { data, error } = await supabase.rpc('refresh_all_materialized_views');\n            if (error) throw error;\n            console.log('✅ Widoki odświeżone:', data);\n            return data;\n        } catch (error) {\n            console.error('❌ refreshMaterializedViews failed:', error);\n            throw error;\n        }\n    },\n    // Archiwizacja starych logów\n    async archiveOldLogs () {\n        try {\n            console.log('📦 Uruchamiam archiwizację starych logów...');\n            const { data, error } = await supabase.rpc('archive_old_activity_logs');\n            if (error) throw error;\n            console.log(\"✅ Zarchiwizowano \".concat(data, \" starych log\\xf3w\"));\n            return data;\n        } catch (error) {\n            console.error('❌ archiveOldLogs failed:', error);\n            throw error;\n        }\n    },\n    // Optymalizacja bazy danych\n    async optimizeDatabase () {\n        try {\n            console.log('🚀 Uruchamiam optymalizację bazy danych...');\n            const { data, error } = await supabase.rpc('optimize_database_performance');\n            if (error) throw error;\n            console.log('✅ Baza danych zoptymalizowana:', data);\n            return data;\n        } catch (error) {\n            console.error('❌ optimizeDatabase failed:', error);\n            throw error;\n        }\n    }\n};\nconst callsApi = {\n    /**\r\n   * 📞 POBIERZ HISTORIĘ POŁĄCZEŃ\r\n   * \r\n   * Pobiera historię połączeń telefonicznych z activity_logs\r\n   * Uwzględnia uprawnienia użytkownika:\r\n   * - Admin/Szef: wszystkie połączenia z wybranego kraju\r\n   * - Project Manager/Junior Manager: wszystkie z ich lokalizacji\r\n   * - Pracownik: tylko swoje połączenia\r\n   */ async getCalls (user) {\n        let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            console.log('📞 Pobieranie historii połączeń...', {\n                user: user.role,\n                filter\n            });\n            let query = supabase.from('activity_logs').select(\"\\n          id,\\n          client_id,\\n          changed_by,\\n          timestamp,\\n          clients!inner (\\n            id,\\n            first_name,\\n            last_name,\\n            company_name,\\n            phone,\\n            location_id,\\n            location:locations (\\n              id,\\n              name,\\n              code\\n            )\\n          )\\n        \").eq('field_changed', 'last_phone_click').order('timestamp', {\n                ascending: false\n            }).limit(filter.limit || 100);\n            // Filtrowanie według uprawnień użytkownika\n            if (user.role === 'pracownik') {\n                // Pracownik widzi tylko swoje połączenia\n                query = query.eq('changed_by', user.id);\n            } else if ([\n                'junior_manager',\n                'manager',\n                'project_manager'\n            ].includes(user.role)) {\n                // Menedżerowie widzą połączenia z ich lokalizacji\n                if (filter.locationId) {\n                    // Jeśli wybrano konkretną lokalizację, filtruj po niej\n                    query = query.eq('clients.location_id', filter.locationId);\n                } else if (user.location_id) {\n                    // Jeśli nie wybrano lokalizacji, pokaż z lokalizacji użytkownika\n                    query = query.eq('clients.location_id', user.location_id);\n                }\n            } else if ([\n                'szef',\n                'admin'\n            ].includes(user.role)) {\n                // Szef i admin widzą wszystko, opcjonalnie filtrowane po lokalizacji\n                if (filter.locationId) {\n                    query = query.eq('clients.location_id', filter.locationId);\n                }\n            }\n            // Dodatkowe filtry czasowe\n            if (filter.startDate) {\n                query = query.gte('timestamp', filter.startDate);\n            }\n            if (filter.endDate) {\n                query = query.lte('timestamp', filter.endDate);\n            }\n            const { data: callLogs, error } = await query;\n            if (error) {\n                console.error('❌ Błąd pobierania połączeń:', error);\n                throw error;\n            }\n            if (!callLogs || callLogs.length === 0) {\n                console.log('📞 Brak połączeń dla podanych kryteriów');\n                return [];\n            }\n            // Pobierz informacje o użytkownikach (dzwoniących)\n            const callerIds = [\n                ...new Set(callLogs.map((log)=>log.changed_by))\n            ];\n            const { data: callers, error: callersError } = await supabase.from('users').select('id, full_name, role, avatar_url').in('id', callerIds);\n            if (callersError) {\n                console.error('❌ Błąd pobierania użytkowników:', callersError);\n            // Kontynuuj bez szczegółów użytkowników\n            }\n            // Stwórz mapę użytkowników\n            const callersMap = (callers || []).reduce((acc, caller)=>{\n                acc[caller.id] = caller;\n                return acc;\n            }, {});\n            // Przekształć dane na format CallRecord\n            const callRecords = callLogs.map((log)=>{\n                const client = Array.isArray(log.clients) ? log.clients[0] : log.clients;\n                const caller = callersMap[log.changed_by];\n                const location = Array.isArray(client === null || client === void 0 ? void 0 : client.location) ? client.location[0] : client === null || client === void 0 ? void 0 : client.location;\n                return {\n                    id: log.id,\n                    client_id: log.client_id,\n                    client_name: client ? \"\".concat(client.first_name, \" \").concat(client.last_name).trim() : 'Nieznany klient',\n                    client_company: (client === null || client === void 0 ? void 0 : client.company_name) || 'Brak informacji',\n                    client_phone: (client === null || client === void 0 ? void 0 : client.phone) || 'Brak telefonu',\n                    called_by: log.changed_by,\n                    caller_name: (caller === null || caller === void 0 ? void 0 : caller.full_name) || 'Nieznany użytkownik',\n                    caller_role: (caller === null || caller === void 0 ? void 0 : caller.role) || 'unknown',\n                    caller_avatar: (caller === null || caller === void 0 ? void 0 : caller.avatar_url) || null,\n                    call_timestamp: log.timestamp,\n                    location_id: (client === null || client === void 0 ? void 0 : client.location_id) || null,\n                    location_name: (location === null || location === void 0 ? void 0 : location.name) || null,\n                    location_code: (location === null || location === void 0 ? void 0 : location.code) || null\n                };\n            });\n            console.log(\"✅ Pobrano \".concat(callRecords.length, \" rekord\\xf3w połączeń\"));\n            return callRecords;\n        } catch (error) {\n            console.error('❌ Błąd w callsApi.getCalls:', error);\n            throw error;\n        }\n    },\n    /**\r\n   * 📊 POBIERZ STATYSTYKI POŁĄCZEŃ\r\n   * \r\n   * Pobiera statystyki połączeń dla wybranego okresu\r\n   */ async getCallsStats (user) {\n        let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            console.log('📊 Pobieranie statystyk połączeń...');\n            const now = new Date();\n            const today = now.toISOString().split('T')[0];\n            const weekStart = new Date(now.setDate(now.getDate() - now.getDay())).toISOString().split('T')[0];\n            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n            // Pobierz wszystkie połączenia zgodnie z uprawnieniami\n            const allCalls = await callsApi.getCalls(user, {\n                ...filter,\n                limit: 1000\n            });\n            // Zlicz statystyki\n            const totalCalls = allCalls.length;\n            const callsToday = allCalls.filter((call)=>call.call_timestamp.startsWith(today)).length;\n            const callsThisWeek = allCalls.filter((call)=>call.call_timestamp >= weekStart).length;\n            const callsThisMonth = allCalls.filter((call)=>call.call_timestamp >= monthStart).length;\n            // Top dzwoniący\n            const callerCounts = allCalls.reduce((acc, call)=>{\n                const key = call.called_by;\n                if (!acc[key]) {\n                    acc[key] = {\n                        name: call.caller_name,\n                        role: call.caller_role,\n                        avatar: call.caller_avatar,\n                        count: 0\n                    };\n                }\n                acc[key].count++;\n                return acc;\n            }, {});\n            const topCallers = Object.values(callerCounts).sort((a, b)=>b.count - a.count).slice(0, 5);\n            return {\n                totalCalls,\n                callsToday,\n                callsThisWeek,\n                callsThisMonth,\n                topCallers\n            };\n        } catch (error) {\n            console.error('❌ Błąd pobierania statystyk połączeń:', error);\n            return {\n                totalCalls: 0,\n                callsToday: 0,\n                callsThisWeek: 0,\n                callsThisMonth: 0,\n                topCallers: []\n            };\n        }\n    }\n};\n// 📡 NOTIFICATIONS API - System powiadomień\nconst notificationsApi = {\n    // Pobierz powiadomienia dla użytkownika\n    async getNotifications (user, options) {\n        try {\n            let query = supabase.from('notifications').select(\"\\n          id,\\n          user_id,\\n          client_id,\\n          type,\\n          title,\\n          message,\\n          read,\\n          urgent,\\n          metadata,\\n          created_at,\\n          expires_at,\\n          client:clients (\\n            id,\\n            first_name,\\n            last_name,\\n            company_name\\n          )\\n        \").eq('user_id', user.id).order('created_at', {\n                ascending: false\n            });\n            // Filtruj tylko nieprzeczytane\n            if (options === null || options === void 0 ? void 0 : options.unreadOnly) {\n                query = query.eq('read', false);\n            }\n            // Filtruj po typie\n            if (options === null || options === void 0 ? void 0 : options.type) {\n                query = query.eq('type', options.type);\n            }\n            // Limit\n            if (options === null || options === void 0 ? void 0 : options.limit) {\n                query = query.limit(options.limit);\n            }\n            const { data, error } = await query;\n            if (error) {\n                console.error('❌ Błąd pobierania powiadomień:', error);\n                throw error;\n            }\n            return (data || []).map((notification)=>({\n                    ...notification,\n                    // Przekształć dane klienta z JOIN\n                    client: notification.client && Array.isArray(notification.client) && notification.client.length > 0 ? notification.client[0] : notification.client && !Array.isArray(notification.client) ? notification.client : undefined\n                }));\n        } catch (error) {\n            console.error('❌ Błąd w getNotifications:', error);\n            throw error;\n        }\n    },\n    // Pobierz liczbę nieprzeczytanych powiadomień\n    async getUnreadCount (user) {\n        try {\n            const { count, error } = await supabase.from('notifications').select('*', {\n                count: 'exact',\n                head: true\n            }).eq('user_id', user.id).eq('read', false);\n            if (error) {\n                console.error('❌ Błąd pobierania liczby nieprzeczytanych:', error);\n                throw error;\n            }\n            return count || 0;\n        } catch (error) {\n            console.error('❌ Błąd w getUnreadCount:', error);\n            return 0;\n        }\n    },\n    // Oznacz powiadomienie jako przeczytane\n    async markAsRead (notificationId) {\n        try {\n            const { error } = await supabase.rpc('mark_notification_as_read', {\n                notification_id: notificationId\n            });\n            if (error) {\n                console.error('❌ Błąd oznaczania jako przeczytane:', error);\n                throw error;\n            }\n        } catch (error) {\n            console.error('❌ Błąd w markAsRead:', error);\n            throw error;\n        }\n    },\n    // Oznacz wszystkie powiadomienia jako przeczytane\n    async markAllAsRead (user) {\n        try {\n            const { data, error } = await supabase.rpc('mark_all_notifications_as_read');\n            if (error) {\n                console.error('❌ Błąd oznaczania wszystkich jako przeczytane:', error);\n                throw error;\n            }\n            return data || 0;\n        } catch (error) {\n            console.error('❌ Błąd w markAllAsRead:', error);\n            throw error;\n        }\n    },\n    // Utwórz nowe powiadomienie\n    async createNotification (notification) {\n        try {\n            const { data, error } = await supabase.from('notifications').insert([\n                notification\n            ]).select().single();\n            if (error) {\n                console.error('❌ Błąd tworzenia powiadomienia:', error);\n                throw error;\n            }\n            return data;\n        } catch (error) {\n            console.error('❌ Błąd w createNotification:', error);\n            throw error;\n        }\n    },\n    // Usuń powiadomienie\n    async deleteNotification (notificationId) {\n        try {\n            const { error } = await supabase.from('notifications').delete().eq('id', notificationId);\n            if (error) {\n                console.error('❌ Błąd usuwania powiadomienia:', error);\n                throw error;\n            }\n        } catch (error) {\n            console.error('❌ Błąd w deleteNotification:', error);\n            throw error;\n        }\n    },\n    // Wyczyść stare powiadomienia\n    async cleanupOldNotifications () {\n        try {\n            const { error } = await supabase.rpc('cleanup_old_notifications');\n            if (error) {\n                console.error('❌ Błąd czyszczenia starych powiadomień:', error);\n                throw error;\n            }\n        } catch (error) {\n            console.error('❌ Błąd w cleanupOldNotifications:', error);\n            throw error;\n        }\n    },\n    // Pobierz dzisiejsze przypomnienia dla dashboard\n    async getTodayReminders (user) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            const { data, error } = await supabase.from('notifications').select(\"\\n          id,\\n          user_id,\\n          client_id,\\n          type,\\n          title,\\n          message,\\n          read,\\n          urgent,\\n          metadata,\\n          created_at,\\n          expires_at,\\n          client:clients (\\n            id,\\n            first_name,\\n            last_name,\\n            company_name\\n          )\\n        \").eq('user_id', user.id).eq('type', 'reminder').gte('created_at', \"\".concat(today, \"T00:00:00.000Z\")).lt('created_at', \"\".concat(today, \"T23:59:59.999Z\")).order('created_at', {\n                ascending: true\n            });\n            if (error) {\n                console.error('❌ Błąd pobierania dzisiejszych przypomnień:', error);\n                throw error;\n            }\n            return (data || []).map((notification)=>({\n                    ...notification,\n                    client: notification.client && Array.isArray(notification.client) && notification.client.length > 0 ? notification.client[0] : notification.client && !Array.isArray(notification.client) ? notification.client : undefined\n                }));\n        } catch (error) {\n            console.error('❌ Błąd w getTodayReminders:', error);\n            return [];\n        }\n    },\n    // Uruchom funkcje generowania powiadomień (do testowania)\n    async triggerReminderCheck () {\n        try {\n            const { error } = await supabase.rpc('create_reminder_notifications');\n            if (error) {\n                console.error('❌ Błąd uruchamiania sprawdzania przypomnień:', error);\n                throw error;\n            }\n        } catch (error) {\n            console.error('❌ Błąd w triggerReminderCheck:', error);\n            throw error;\n        }\n    },\n    async triggerAntisaleCheck () {\n        try {\n            const { error } = await supabase.rpc('create_antysale_warnings');\n            if (error) {\n                console.error('❌ Błąd uruchamiania sprawdzania antysale:', error);\n                throw error;\n            }\n        } catch (error) {\n            console.error('❌ Błąd w triggerAntisaleCheck:', error);\n            throw error;\n        }\n    },\n    // Subskrypcja na real-time powiadomienia\n    subscribeToNotifications (userId, callback) {\n        return supabase.channel(\"notifications_\".concat(userId)).on('postgres_changes', {\n            event: 'INSERT',\n            schema: 'public',\n            table: 'notifications',\n            filter: \"user_id=eq.\".concat(userId)\n        }, (payload)=>{\n            callback(payload.new);\n        }).subscribe();\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdXBhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFFcEQsTUFBTUMsY0FBY0MsMENBQW9DLElBQUksQ0FBMEM7QUFDdEcsTUFBTUcsa0JBQWtCSCxrTkFBeUMsSUFBSSxDQUFrTjtBQUVoUixNQUFNSyxXQUFXUCxtRUFBWUEsQ0FBQ0MsYUFBYUksaUJBQWdCO0FBRWxFLGlGQUFpRjtBQUMxRSxNQUFNRyxlQUFlLENBQUNDO0lBQzNCLElBQUksQ0FBQ0EsV0FBVyxPQUFPO0lBRXZCLGdFQUFnRTtJQUNoRSxJQUFJQSxVQUFVQyxVQUFVLENBQUMsU0FBUztRQUNoQyxPQUFPRDtJQUNUO0lBRUEsd0VBQXdFO0lBQ3hFLElBQUlBLFVBQVVFLFFBQVEsQ0FBQyxNQUFNO1FBQzNCLElBQUk7WUFDRixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHTCxTQUFTTSxPQUFPLENBQzlCQyxJQUFJLENBQUMsV0FDTEMsWUFBWSxDQUFDTjtZQUVoQixPQUFPRyxLQUFLSSxTQUFTO1FBQ3ZCLEVBQUUsT0FBT0MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLCtDQUErQztJQUMvQ0MsUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ1Y7SUFDakQsT0FBTztBQUNULEVBQUM7QUFFRCw2QkFBNkI7QUFDdEIsTUFBTVcsYUFBYTtJQUN4Qiw2QkFBNkI7SUFDN0IsTUFBTUMsV0FBVUMsSUFBVSxFQUFFQyxJQUFVO1FBQ3BDLElBQUk7WUFDRixxREFBcUQ7WUFDckQsTUFBTUMsZ0JBQWdCRixLQUFLRyxJQUFJLENBQzVCQyxPQUFPLENBQUMsbUJBQW1CLEtBQUssa0RBQWtEO2FBQ2xGQSxPQUFPLENBQUMsVUFBVSxLQUFLLGdEQUFnRDthQUN2RUEsT0FBTyxDQUFDLFlBQVksSUFBSSx1Q0FBdUM7YUFDL0RDLFdBQVcsR0FBRyw4QkFBOEI7O1lBRS9DLE1BQU1DLFdBQVcsR0FBY0MsT0FBWE4sS0FBS08sRUFBRSxFQUFDLEtBQWlCTixPQUFkSyxLQUFLRSxHQUFHLElBQUcsS0FBaUIsT0FBZFA7WUFDN0MsTUFBTVEsV0FBVyxlQUF3QixPQUFUSjtZQUVoQ1YsUUFBUWUsR0FBRyxDQUFDLCtCQUE4QixPQUFURDtZQUNqQ2QsUUFBUWUsR0FBRyxDQUFDLG1DQUFtQyxPQUFWWCxLQUFLRyxJQUFJO1lBQzlDUCxRQUFRZSxHQUFHLENBQUMsa0NBQXNDLE9BQWRUO1lBRXBDLE1BQU0sRUFBRVosSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTTSxPQUFPLENBQzNDQyxJQUFJLENBQUMsYUFDTG9CLE1BQU0sQ0FBQ0YsVUFBVVYsTUFBTTtnQkFDdEJhLGNBQWM7Z0JBQ2RDLFFBQVE7WUFDVjtZQUVGLElBQUluQixPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsMkJBQTJCQTtnQkFDekMsTUFBTSxJQUFJb0IsTUFBTSxpQkFBK0IsT0FBZHBCLE1BQU1xQixPQUFPO1lBQ2hEO1lBRUFwQixRQUFRZSxHQUFHLENBQUMsaUNBQWlDckIsS0FBSzJCLElBQUk7WUFDdEQsT0FBTzNCLEtBQUsyQixJQUFJO1FBRWxCLEVBQUUsT0FBT3RCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkE7WUFDbEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsOEJBQThCO0lBQzlCRixjQUFhd0IsSUFBWTtRQUN2QixNQUFNLEVBQUUzQixJQUFJLEVBQUUsR0FBR0wsU0FBU00sT0FBTyxDQUM5QkMsSUFBSSxDQUFDLGFBQ0xDLFlBQVksQ0FBQ3dCO1FBRWhCLE9BQU8zQixLQUFLSSxTQUFTO0lBQ3ZCO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU13QixZQUFXRCxJQUFZO1FBQzNCLE1BQU0sRUFBRXRCLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVNNLE9BQU8sQ0FDckNDLElBQUksQ0FBQyxhQUNMMkIsTUFBTSxDQUFDO1lBQUNGO1NBQUs7UUFFaEIsSUFBSXRCLE9BQU87WUFDVEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7WUFDeEMsTUFBTSxJQUFJb0IsTUFBTSx3QkFBc0MsT0FBZHBCLE1BQU1xQixPQUFPO1FBQ3ZEO0lBQ0Y7QUFDRixFQUFDO0FBRUQsaUJBQWlCO0FBQ1YsTUFBTUksZUFBZTtJQUMxQiwwQkFBMEI7SUFDMUJDLFVBQVNDLE9BQWU7UUFDdEIsTUFBTUMsUUFBUUQsUUFBUUUsS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxPQUFPO1FBRWpFLElBQUlKLE1BQU1LLE1BQU0sR0FBRyxHQUFHO1lBQ3BCLE1BQU0sSUFBSWIsTUFBTTtRQUNsQjtRQUVBLG1DQUFtQztRQUNuQyxNQUFNYyxlQUFlLENBQUNIO1lBQ3BCLE1BQU1JLFNBQW1CLEVBQUU7WUFDM0IsSUFBSUMsVUFBVTtZQUNkLElBQUlDLFdBQVc7WUFFZixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVAsS0FBS0UsTUFBTSxFQUFFSyxJQUFLO2dCQUNwQyxNQUFNQyxPQUFPUixJQUFJLENBQUNPLEVBQUU7Z0JBRXBCLElBQUlDLFNBQVMsS0FBSztvQkFDaEJGLFdBQVcsQ0FBQ0E7Z0JBQ2QsT0FBTyxJQUFJRSxTQUFTLE9BQU8sQ0FBQ0YsVUFBVTtvQkFDcENGLE9BQU9LLElBQUksQ0FBQ0osUUFBUUosSUFBSTtvQkFDeEJJLFVBQVU7Z0JBQ1osT0FBTztvQkFDTEEsV0FBV0c7Z0JBQ2I7WUFDRjtZQUVBSixPQUFPSyxJQUFJLENBQUNKLFFBQVFKLElBQUk7WUFDeEIsT0FBT0csT0FBT00sR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLakMsT0FBTyxDQUFDLFVBQVUsS0FBSyxrQkFBa0I7O1FBQzFFO1FBRUEsTUFBTWtDLFVBQVVULGFBQWFOLEtBQUssQ0FBQyxFQUFFO1FBQ3JDLE1BQU1nQixPQUFPaEIsTUFBTWlCLEtBQUssQ0FBQyxHQUFHSixHQUFHLENBQUNQO1FBRWhDLE9BQU87WUFBRVM7WUFBU0M7UUFBSztJQUN6QjtJQUVBLHlDQUF5QztJQUN6Q0UsWUFBV0gsT0FBaUI7UUFDMUIsTUFBTUksVUFBa0MsQ0FBQztRQUV6QyxNQUFNQyxnQkFBZ0I7WUFDcEI7Z0JBQUVDLFFBQVE7b0JBQUM7b0JBQWM7b0JBQVE7b0JBQVE7aUJBQVk7Z0JBQUVDLFNBQVM7WUFBYTtZQUM3RTtnQkFBRUQsUUFBUTtvQkFBQztvQkFBYTtvQkFBWTtvQkFBVztpQkFBVztnQkFBRUMsU0FBUztZQUFZO1lBQ2pGO2dCQUFFRCxRQUFRO29CQUFDO29CQUFnQjtvQkFBUztvQkFBVztvQkFBZTtpQkFBUTtnQkFBRUMsU0FBUztZQUFlO1lBQ2hHO2dCQUFFRCxRQUFRO29CQUFDO29CQUFPO29CQUFVO2lCQUFRO2dCQUFFQyxTQUFTO1lBQU07WUFDckQ7Z0JBQUVELFFBQVE7b0JBQUM7b0JBQVM7b0JBQVc7aUJBQVk7Z0JBQUVDLFNBQVM7WUFBUTtZQUM5RDtnQkFBRUQsUUFBUTtvQkFBQztvQkFBUztvQkFBVTtpQkFBTztnQkFBRUMsU0FBUztZQUFRO1lBQ3hEO2dCQUFFRCxRQUFRO29CQUFDO29CQUFXO29CQUFPO29CQUFVO2lCQUFNO2dCQUFFQyxTQUFTO1lBQVU7WUFDbEU7Z0JBQUVELFFBQVE7b0JBQUM7b0JBQVM7b0JBQVc7b0JBQVE7aUJBQVU7Z0JBQUVDLFNBQVM7WUFBUTtZQUNwRTtnQkFBRUQsUUFBUTtvQkFBQztpQkFBUztnQkFBRUMsU0FBUztZQUFTO1NBQ3pDO1FBRUQsS0FBSyxNQUFNQyxnQkFBZ0JILGNBQWU7WUFDeEMsSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlLLFFBQVFWLE1BQU0sRUFBRUssSUFBSztnQkFDdkMsTUFBTWMsU0FBU1QsT0FBTyxDQUFDTCxFQUFFLENBQUM1QixXQUFXLEdBQUdzQixJQUFJO2dCQUM1QyxJQUFJbUIsYUFBYUYsTUFBTSxDQUFDSSxJQUFJLENBQUNDLENBQUFBLFFBQVNGLE9BQU8xRCxRQUFRLENBQUM0RCxTQUFTO29CQUM3RFAsT0FBTyxDQUFDSSxhQUFhRCxPQUFPLENBQUMsR0FBR1o7b0JBQ2hDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU9TO0lBQ1Q7SUFFQSx3QkFBd0I7SUFDeEJRLHdCQUF1QlIsT0FBK0I7UUFDcEQsTUFBTVMsaUJBQWlCO1lBQUM7U0FBZTtRQUN2QyxNQUFNQyxnQkFBZ0JELGVBQWUxQixNQUFNLENBQUN3QixDQUFBQSxRQUFTLENBQUVBLENBQUFBLFNBQVNQLE9BQU07UUFFdEUsSUFBSVUsY0FBY3hCLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSWIsTUFBTSwyQkFBb0QsT0FBekJxQyxjQUFjQyxJQUFJLENBQUMsT0FBTTtRQUN0RTtJQUNGO0lBRUEsOENBQThDO0lBQzlDQyxnQkFBZVosT0FBK0IsRUFBRUosT0FBaUI7UUFDL0QsTUFBTWlCLG9CQUFvQjtZQUN4QjtnQkFBRU4sT0FBTztnQkFBY08sYUFBYTtnQkFBUUMsVUFBVTtZQUFNO1lBQzVEO2dCQUFFUixPQUFPO2dCQUFhTyxhQUFhO2dCQUFZQyxVQUFVO1lBQU07WUFDL0Q7Z0JBQUVSLE9BQU87Z0JBQWdCTyxhQUFhO2dCQUFlQyxVQUFVO1lBQUs7WUFDcEU7Z0JBQUVSLE9BQU87Z0JBQVNPLGFBQWE7Z0JBQVdDLFVBQVU7WUFBTTtZQUMxRDtnQkFBRVIsT0FBTztnQkFBU08sYUFBYTtnQkFBU0MsVUFBVTtZQUFNO1lBQ3hEO2dCQUFFUixPQUFPO2dCQUFPTyxhQUFhO2dCQUFPQyxVQUFVO1lBQU07WUFDcEQ7Z0JBQUVSLE9BQU87Z0JBQVdPLGFBQWE7Z0JBQWNDLFVBQVU7WUFBTTtZQUMvRDtnQkFBRVIsT0FBTztnQkFBU08sYUFBYTtnQkFBV0MsVUFBVTtZQUFNO1lBQzFEO2dCQUFFUixPQUFPO2dCQUFVTyxhQUFhO2dCQUFVQyxVQUFVO1lBQU07U0FDM0Q7UUFFRCxNQUFNQyxRQUFrQixFQUFFO1FBQzFCLE1BQU1DLFVBQW9CLEVBQUU7UUFDNUIsTUFBTUMsV0FBcUIsRUFBRTtRQUU3Qkwsa0JBQWtCTSxPQUFPLENBQUM7Z0JBQUMsRUFBRVosS0FBSyxFQUFFTyxXQUFXLEVBQUVDLFFBQVEsRUFBRTtZQUN6RCxJQUFJUixTQUFTUCxTQUFTO2dCQUNwQmdCLE1BQU12QixJQUFJLENBQUNxQjtZQUNiLE9BQU8sSUFBSUMsVUFBVTtnQkFDbkJFLFFBQVF4QixJQUFJLENBQUNxQjtZQUNmLE9BQU87Z0JBQ0xJLFNBQVN6QixJQUFJLENBQUNxQjtZQUNoQjtRQUNGO1FBRUEsT0FBTztZQUFFRTtZQUFPQztZQUFTQztRQUFTO0lBQ3BDO0lBRUEsMkNBQTJDO0lBQzNDRSxhQUFZQyxHQUFhLEVBQUVyQixPQUErQixFQUFFekMsSUFBVSxFQUFFK0QsVUFBbUI7UUFDekYsTUFBTUMsV0FBVyxTQUFDaEI7Z0JBQWVpQixnRkFBdUI7WUFDdEQsTUFBTUMsUUFBUXpCLE9BQU8sQ0FBQ08sTUFBTTtZQUM1QixJQUFJa0IsVUFBVUMsV0FBVztnQkFDdkIsT0FBT0Y7WUFDVDtZQUNBLE1BQU1HLFFBQVEsQ0FBQ04sR0FBRyxDQUFDSSxNQUFNLElBQUksRUFBQyxFQUFHeEMsSUFBSTtZQUNyQyxPQUFPMEMsVUFBVSxLQUFLSCxlQUFlRztRQUN2QztRQUVBLG9CQUFvQjtRQUNwQixNQUFNQyxZQUFZTCxTQUFTLFVBQVUsVUFBVTVELFdBQVc7UUFDMUQsTUFBTWtFLGdCQUFnQjtZQUFDO1lBQVU7WUFBaUI7WUFBc0I7WUFBZ0I7WUFBWTtZQUFRO1NBQUs7UUFDakgsTUFBTUMsU0FBU0QsY0FBY2xGLFFBQVEsQ0FBQ2lGLGFBQW9CQSxZQUFnQztRQUUxRixPQUFPO1lBQ0xHLFlBQVlSLFNBQVM7WUFDckJTLFdBQVdULFNBQVM7WUFDcEJVLGNBQWNWLFNBQVMsZ0JBQWdCO1lBQ3ZDVyxLQUFLWCxTQUFTO1lBQ2RZLE9BQU9aLFNBQVM7WUFDaEJhLE9BQU9iLFNBQVM7WUFDaEJjLFNBQVNkLFNBQVM7WUFDbEJlLE9BQU9mLFNBQVM7WUFDaEJPO1lBQ0FTLFdBQVdoRixLQUFLTyxFQUFFO1lBQ2xCMEUsV0FBVyxJQUFJM0UsT0FBTzRFLFdBQVc7WUFDakNDLFVBQVVuRixLQUFLTyxFQUFFO1lBQ2pCNkUsYUFBYXJCLGNBQWMvRCxLQUFLb0YsV0FBVztZQUMzQ0MscUJBQXFCckYsS0FBS3NGLFNBQVM7WUFDbkNDLDJCQUEyQnZGLEtBQUt3RixVQUFVO1FBQzVDO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTUMsV0FBVTFGLElBQVUsRUFBRUMsSUFBVSxFQUFFK0QsVUFBbUIsRUFBRTJCLFVBQW1GO1FBQzlJLElBQUk7WUFDRkEsdUJBQUFBLGlDQUFBQSxXQUFhO2dCQUFFNUQsU0FBUztnQkFBRzZELE9BQU87Z0JBQUtwQixRQUFRO1lBQXFCO1lBRXBFLDZCQUE2QjtZQUM3QixNQUFNOUQsV0FBVyxNQUFNWixXQUFXQyxTQUFTLENBQUNDLE1BQU1DO1lBRWxEMEYsdUJBQUFBLGlDQUFBQSxXQUFhO2dCQUFFNUQsU0FBUztnQkFBSTZELE9BQU87Z0JBQUtwQixRQUFRO1lBQW9CO1lBRXBFLCtCQUErQjtZQUMvQixNQUFNbEQsVUFBVSxNQUFNdEIsS0FBSzZGLElBQUk7WUFDL0IsTUFBTSxFQUFFdkQsT0FBTyxFQUFFQyxJQUFJLEVBQUUsR0FBR25CLGFBQWFDLFFBQVEsQ0FBQ0M7WUFFaERxRSx1QkFBQUEsaUNBQUFBLFdBQWE7Z0JBQUU1RCxTQUFTO2dCQUFJNkQsT0FBTztnQkFBS3BCLFFBQVE7WUFBc0I7WUFFdEUseUJBQXlCO1lBQ3pCLE1BQU05QixVQUFVdEIsYUFBYXFCLFVBQVUsQ0FBQ0g7WUFDeENsQixhQUFhOEIsc0JBQXNCLENBQUNSO1lBRXBDLCtCQUErQjtZQUMvQixNQUFNb0QsaUJBQWlCMUUsYUFBYWtDLGNBQWMsQ0FBQ1osU0FBU0o7WUFFNUQxQyxRQUFRZSxHQUFHLENBQUMsbUJBQW1CMkI7WUFDL0IxQyxRQUFRZSxHQUFHLENBQUMscUJBQXFCK0I7WUFDakM5QyxRQUFRZSxHQUFHLENBQUMsc0JBQXNCNEIsS0FBS1gsTUFBTTtZQUM3Q2hDLFFBQVFlLEdBQUcsQ0FBQyx5QkFBeUJtRixlQUFlcEMsS0FBSztZQUN6RDlELFFBQVFlLEdBQUcsQ0FBQyx5QkFBeUJtRixlQUFlbkMsT0FBTztZQUMzRC9ELFFBQVFlLEdBQUcsQ0FBQywwQ0FBMENtRixlQUFlbEMsUUFBUTtZQUU3RStCLHVCQUFBQSxpQ0FBQUEsV0FBYTtnQkFBRTVELFNBQVM7Z0JBQUk2RCxPQUFPO2dCQUFLcEIsUUFBUSxnQkFBNEIsT0FBWmpDLEtBQUtYLE1BQU0sRUFBQztZQUFjO1lBRTFGLDRCQUE0QjtZQUM1QixNQUFNbUUsVUFBVTtnQkFBRUMsU0FBUztnQkFBR0MsUUFBUSxFQUFFO1lBQVU7WUFFbEQsSUFBSyxJQUFJaEUsSUFBSSxHQUFHQSxJQUFJTSxLQUFLWCxNQUFNLEVBQUVLLElBQUs7Z0JBQ3BDLElBQUk7b0JBQ0YsTUFBTThCLE1BQU14QixJQUFJLENBQUNOLEVBQUU7b0JBRW5CLG9DQUFvQztvQkFDcEMsSUFBSThCLElBQUltQyxLQUFLLENBQUM3RCxDQUFBQSxPQUFRQSxLQUFLVixJQUFJLE9BQU8sS0FBSzt3QkFDekM7b0JBQ0Y7b0JBRUEsTUFBTXdFLGFBQWEvRSxhQUFhMEMsV0FBVyxDQUFDQyxLQUFLckIsU0FBU3pDLE1BQU0rRDtvQkFFaEUsZ0NBQWdDO29CQUNoQyxJQUFJLENBQUNtQyxXQUFXeEIsWUFBWSxJQUFJd0IsV0FBV3hCLFlBQVksQ0FBQ2hELElBQUksT0FBTyxJQUFJO3dCQUNyRW9FLFFBQVFFLE1BQU0sQ0FBQzlELElBQUksQ0FBQzs0QkFDbEI0QixLQUFLOUIsSUFBSTs0QkFDVHRDLE9BQU87NEJBQ1BMLE1BQU15RTt3QkFDUjt3QkFDQTtvQkFDRjtvQkFFQSx3QkFBd0I7b0JBQ3hCLE1BQU1xQyxXQUFXMUgsWUFBWSxDQUFDeUgsWUFBWWxHO29CQUMxQzhGLFFBQVFDLE9BQU87b0JBRWYsc0JBQXNCO29CQUN0QixNQUFNSyxXQUFXLEtBQUtDLEtBQUtDLEtBQUssQ0FBQyxJQUFLaEUsS0FBS1gsTUFBTSxHQUFJO29CQUNyRCtELHVCQUFBQSxpQ0FBQUEsV0FBYTt3QkFBRTVELFNBQVNzRTt3QkFBVVQsT0FBTzt3QkFBS3BCLFFBQVEsaUJBQW9DakMsT0FBbkJ3RCxRQUFRQyxPQUFPLEVBQUMsS0FBZSxPQUFaekQsS0FBS1gsTUFBTSxFQUFDO29CQUFXO2dCQUVuSCxFQUFFLE9BQU9qQyxPQUFPO29CQUNkQyxRQUFRRCxLQUFLLENBQUMsMEJBQWdDLE9BQU5zQyxJQUFJLEdBQUUsTUFBSXRDO29CQUNsRG9HLFFBQVFFLE1BQU0sQ0FBQzlELElBQUksQ0FBQzt3QkFDbEI0QixLQUFLOUIsSUFBSTt3QkFDVHRDLE9BQU9BLGlCQUFpQm9CLFFBQVFwQixNQUFNcUIsT0FBTyxHQUFHO3dCQUNoRDFCLE1BQU1pRCxJQUFJLENBQUNOLEVBQUU7b0JBQ2Y7Z0JBQ0Y7WUFDRjtZQUVBMEQsdUJBQUFBLGlDQUFBQSxXQUFhO2dCQUFFNUQsU0FBUztnQkFBSTZELE9BQU87Z0JBQUtwQixRQUFRO1lBQW1CO1lBRW5FLGlFQUFpRTtZQUNqRSx3Q0FBd0M7WUFFeENtQix1QkFBQUEsaUNBQUFBLFdBQWE7Z0JBQUU1RCxTQUFTO2dCQUFLNkQsT0FBTztnQkFBS3BCLFFBQVE7WUFBYztZQUUvRDVFLFFBQVFlLEdBQUcsQ0FBQyx3QkFBbURvRixPQUEzQkEsUUFBUUMsT0FBTyxFQUFDLGFBQWlDLE9BQXRCRCxRQUFRRSxNQUFNLENBQUNyRSxNQUFNLEVBQUM7WUFDckYsT0FBT21FO1FBRVQsRUFBRSxPQUFPcEcsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxNQUFNQTtRQUNSO0lBQ0Y7QUFDRixFQUFDO0FBOElELDJEQUEyRDtBQUNwRCxNQUFNNkcsaUJBQWlCO0lBQzVCLDhEQUE4RDtJQUM5REMsU0FBUyxDQUFDQyxRQUFnQnpHO1FBQ3hCLDhCQUE4QjtRQUM5QixJQUFJO1lBQUM7WUFBUTtTQUFRLENBQUNaLFFBQVEsQ0FBQ1ksS0FBSzBHLElBQUksR0FBRztZQUN6QyxPQUFPO1FBQ1Q7UUFFQSxnRUFBZ0U7UUFDaEUsTUFBTUMsZUFBZUYsT0FBT3JCLFdBQVcsS0FBS3BGLEtBQUtvRixXQUFXO1FBQzVELElBQUksQ0FBQ3VCLGNBQWM7WUFDakIsT0FBTztRQUNUO1FBRUEsT0FBUTNHLEtBQUswRyxJQUFJO1lBQ2YsS0FBSztnQkFDSCw2REFBNkQ7Z0JBQzdELE9BQU9ELE9BQU90QixRQUFRLEtBQUtuRixLQUFLTyxFQUFFLElBQzNCa0csT0FBT3RCLFFBQVEsS0FBSyxRQUNwQnNCLE9BQU96QixTQUFTLEtBQUtoRixLQUFLTyxFQUFFO1lBQ3JDLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCw4REFBOEQ7Z0JBQzlELE9BQU87WUFDVDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVBLCtDQUErQztJQUMvQ3FHLFNBQVMsQ0FBQ0gsUUFBZ0J6RztRQUN4QixnQ0FBZ0M7UUFDaEMsT0FBT3VHLGVBQWVDLE9BQU8sQ0FBQ0MsUUFBUXpHO0lBQ3hDO0lBRUEsNkNBQTZDO0lBQzdDNkcsV0FBVyxDQUFDSixRQUFnQnpHO1FBQzFCLG9DQUFvQztRQUNwQyxJQUFJO1lBQUM7WUFBUTtTQUFRLENBQUNaLFFBQVEsQ0FBQ1ksS0FBSzBHLElBQUksR0FBRztZQUN6QyxPQUFPO1FBQ1Q7UUFFQSxnREFBZ0Q7UUFDaEQsSUFBSTtZQUFDO1lBQVc7WUFBbUI7U0FBaUIsQ0FBQ3RILFFBQVEsQ0FBQ1ksS0FBSzBHLElBQUksR0FBRztZQUN4RSxPQUFPRCxPQUFPckIsV0FBVyxLQUFLcEYsS0FBS29GLFdBQVc7UUFDaEQ7UUFFQSw2QkFBNkI7UUFDN0IsT0FBTztJQUNUO0lBRUEsbURBQW1EO0lBQ25EMEIsa0JBQWtCLENBQUM5RztRQUNqQixPQUFPO1lBQUM7WUFBVztZQUFtQjtZQUFrQjtZQUFRO1NBQVEsQ0FBQ1osUUFBUSxDQUFDWSxLQUFLMEcsSUFBSTtJQUM3RjtJQUVBLGdFQUFnRTtJQUNoRUssZ0JBQWdCLENBQUMvRztRQUNmLE9BQU87WUFBQztZQUFRO1NBQVEsQ0FBQ1osUUFBUSxDQUFDWSxLQUFLMEcsSUFBSTtJQUM3QztJQUVBLGdFQUFnRTtJQUNoRU0sMEJBQTBCLENBQUNoSDtRQUN6QixPQUFPO1lBQUM7WUFBVztZQUFtQjtZQUFrQjtZQUFRO1NBQVEsQ0FBQ1osUUFBUSxDQUFDWSxLQUFLMEcsSUFBSTtJQUM3RjtJQUVBLDREQUE0RDtJQUM1RE8scUJBQXFCLENBQUNqSDtRQUNwQixPQUFPO1lBQUM7WUFBUTtTQUFRLENBQUNaLFFBQVEsQ0FBQ1ksS0FBSzBHLElBQUk7SUFDN0M7SUFFQSx5REFBeUQ7SUFDekRRLHFCQUFxQixDQUFDbEg7UUFDcEIsT0FBTztZQUFDO1lBQW1CO1lBQWtCO1lBQVE7U0FBUSxDQUFDWixRQUFRLENBQUNZLEtBQUswRyxJQUFJO0lBQ2xGO0lBRUEsNkRBQTZEO0lBQzdEUyxlQUFlLENBQUNDLE9BQWFDO1FBQzNCLGtDQUFrQztRQUNsQyxJQUFJRCxNQUFNVixJQUFJLEtBQUssU0FBUyxPQUFPO1FBRW5DLGdEQUFnRDtRQUNoRCxJQUFJVSxNQUFNVixJQUFJLEtBQUssVUFBVVcsTUFBTVgsSUFBSSxLQUFLLFNBQVMsT0FBTztRQUU1RCxnRUFBZ0U7UUFDaEUsTUFBTUMsZUFBZVMsTUFBTWhDLFdBQVcsS0FBS2lDLE1BQU1qQyxXQUFXO1FBQzVELE1BQU1rQyxvQkFBb0IsQ0FBQ0YsTUFBTUcsb0JBQW9CLElBQUksRUFBQyxJQUFNRixDQUFBQSxNQUFNRSxvQkFBb0IsSUFBSSxFQUFDO1FBRS9GLE9BQU9aLGdCQUFnQlc7SUFDekI7QUFDRixFQUFDO0FBdUJELGdEQUFnRDtBQUN6QyxNQUFNbkIsYUFBYTtJQUN4QixxREFBcUQ7SUFDckQsTUFBTXFCO1FBQ0osSUFBSTtZQUNGN0gsUUFBUWUsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFckIsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFdBQ0xrSSxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDO1lBRVQvSCxRQUFRZSxHQUFHLENBQUMsdUJBQXVCckI7WUFDbkNNLFFBQVFlLEdBQUcsQ0FBQyx3QkFBd0JoQjtZQUVwQyxPQUFPO2dCQUFFTDtnQkFBTUs7WUFBTTtRQUN2QixFQUFFLE9BQU9BLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7WUFDM0MsT0FBTztnQkFBRUwsTUFBTTtnQkFBTUs7WUFBTTtRQUM3QjtJQUNGO0lBRUEsd0NBQXdDO0lBQ3hDLDhEQUE4RDtJQUM5RCxNQUFNaUkscUJBQW9CM0gsSUFBVSxFQUFFNEgsT0FVckM7UUFDQyxJQUFJO1lBQ0ZqSSxRQUFRZSxHQUFHLENBQUMsdURBQXVEVixLQUFLTyxFQUFFLEVBQUVQLEtBQUswRyxJQUFJO1lBRXJGLHNGQUFzRjtZQUN0RiwwRUFBMEU7WUFDMUUsSUFBSW1CLFFBQVE3SSxTQUNUTyxJQUFJLENBQUMsV0FDTGtJLE1BQU0sQ0FBRSwrd0JBbUNOO2dCQUFFSyxPQUFPO1lBQVE7WUFFdEIsaURBQWlEO1lBQ2pELE1BQU1DLFlBQVlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ksTUFBTSxLQUFJO1lBQ3JDLE1BQU1DLGNBQWNMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU00sYUFBYSxNQUFLO1lBQy9DTCxRQUFRQSxNQUFNTSxLQUFLLENBQUNKLFdBQVc7Z0JBQUVLLFdBQVdIO1lBQVk7WUFFeEQsbUJBQW1CO1lBQ25CLElBQUlMLG9CQUFBQSw4QkFBQUEsUUFBU1MsSUFBSSxFQUFFO2dCQUNqQlIsUUFBUUEsTUFBTVMsR0FBRyxDQUFDLGNBQWNWLFFBQVFTLElBQUk7WUFDOUM7WUFFQSxJQUFJVCxvQkFBQUEsOEJBQUFBLFFBQVNyRCxNQUFNLEVBQUU7Z0JBQ25Cc0QsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLFVBQVVYLFFBQVFyRCxNQUFNO1lBQzNDO1lBRUEsSUFBSXFELG9CQUFBQSw4QkFBQUEsUUFBU1ksUUFBUSxFQUFFO2dCQUNyQlgsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLGFBQWFYLFFBQVFZLFFBQVE7WUFDaEQ7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSVosb0JBQUFBLDhCQUFBQSxRQUFTYSxNQUFNLEVBQUU7Z0JBQ25CLE1BQU1DLGFBQWFkLFFBQVFhLE1BQU0sQ0FBQ3JJLFdBQVc7Z0JBQzdDeUgsUUFBUUEsTUFBTWMsRUFBRSxDQUFDLHFCQUFxREQsT0FBaENBLFlBQVcsdUJBQXdEQSxPQUFuQ0EsWUFBVywwQkFBb0RBLE9BQTVCQSxZQUFXLG1CQUE2Q0EsT0FBNUJBLFlBQVcsbUJBQTRCLE9BQVhBLFlBQVc7WUFDOUs7WUFFQSw2QkFBNkI7WUFDN0IsSUFBSWQsb0JBQUFBLDhCQUFBQSxRQUFTZ0IsUUFBUSxFQUFFO2dCQUNyQmYsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLGVBQWVYLFFBQVFnQixRQUFRO1lBQ2xEO1lBRUEscUJBQXFCO1lBQ3JCLElBQUloQixDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNpQixJQUFJLE1BQUlqQixvQkFBQUEsOEJBQUFBLFFBQVNrQixRQUFRLEdBQUU7Z0JBQ3RDLE1BQU12SixPQUFPLENBQUNxSSxRQUFRaUIsSUFBSSxHQUFHLEtBQUtqQixRQUFRa0IsUUFBUTtnQkFDbEQsTUFBTUMsS0FBS3hKLE9BQU9xSSxRQUFRa0IsUUFBUSxHQUFHO2dCQUNyQ2pCLFFBQVFBLE1BQU1tQixLQUFLLENBQUN6SixNQUFNd0o7Z0JBQzFCcEosUUFBUWUsR0FBRyxDQUFDLGtDQUFpRGtILE9BQXpCQSxRQUFRaUIsSUFBSSxFQUFDLGNBQXlDdEosT0FBN0JxSSxRQUFRa0IsUUFBUSxFQUFDLGNBQW9CQyxPQUFSeEosTUFBSyxLQUFNLE9BQUh3SjtZQUNwRztZQUVBcEosUUFBUWUsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFckIsTUFBTTRKLE9BQU8sRUFBRXZKLEtBQUssRUFBRW9JLEtBQUssRUFBRSxHQUFHLE1BQU1EO1lBRTlDLElBQUluSSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtnQkFDM0MsTUFBTUE7WUFDUjtZQUdBLElBQUksQ0FBQ3VKLFdBQVdBLFFBQVF0SCxNQUFNLEtBQUssR0FBRztnQkFDcENoQyxRQUFRZSxHQUFHLENBQUM7Z0JBQ1osT0FBTztvQkFDTHVJLFNBQVMsRUFBRTtvQkFDWHRELE9BQU87b0JBQ1BrRCxNQUFNakIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTaUIsSUFBSSxLQUFJO29CQUN2QkMsVUFBVWxCLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU2tCLFFBQVEsS0FBSTtnQkFDakM7WUFDRjtZQUVBLGdIQUFnSDtZQUNoSCxNQUFNSSxxQkFBcUJELFFBQVE5RyxHQUFHLENBQUMsQ0FBQ3NFLFNBQWlCO29CQUN2RCxHQUFHQSxNQUFNO29CQUNUMEMsT0FBTzFDLE9BQU8wQyxLQUFLLElBQUlDLE1BQU1DLE9BQU8sQ0FBQzVDLE9BQU8wQyxLQUFLLEtBQUsxQyxPQUFPMEMsS0FBSyxDQUFDeEgsTUFBTSxHQUFHLElBQ3hFOEUsT0FBTzBDLEtBQUssQ0FBQyxFQUFFLENBQUMsaUNBQWlDO3VCQUNqRDFDLE9BQU8wQyxLQUFLLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDNUMsT0FBTzBDLEtBQUssSUFDM0MxQyxPQUFPMEMsS0FBSyxDQUFDLGdDQUFnQzt1QkFDN0M7b0JBQ0pQLFVBQVVuQyxPQUFPbUMsUUFBUSxJQUFJUSxNQUFNQyxPQUFPLENBQUM1QyxPQUFPbUMsUUFBUSxLQUFLbkMsT0FBT21DLFFBQVEsQ0FBQ2pILE1BQU0sR0FBRyxJQUNwRjhFLE9BQU9tQyxRQUFRLENBQUMsRUFBRSxDQUFDLGlDQUFpQzt1QkFDcERuQyxPQUFPbUMsUUFBUSxJQUFJLENBQUNRLE1BQU1DLE9BQU8sQ0FBQzVDLE9BQU9tQyxRQUFRLElBQ2pEbkMsT0FBT21DLFFBQVEsQ0FBQyxnQ0FBZ0M7dUJBQ2hELEtBQUssbUJBQW1CO2dCQUM5QjtZQUVBLGtDQUFrQztZQUNsQyxNQUFNVSxvQkFBb0JKLG1CQUFtQjFILE1BQU0sQ0FBQyxDQUFDaUYsU0FBbUJBLE9BQU8wQyxLQUFLO1lBQ3BGLE1BQU1JLHVCQUF1QkwsbUJBQW1CMUgsTUFBTSxDQUFDLENBQUNpRixTQUFtQixDQUFDQSxPQUFPMEMsS0FBSztZQUN4RnhKLFFBQVFlLEdBQUcsQ0FBQyw4QkFBOEI0SSxrQkFBa0IzSCxNQUFNO1lBQ2xFaEMsUUFBUWUsR0FBRyxDQUFDLDhCQUE4QjZJLHFCQUFxQjVILE1BQU07WUFFckUsSUFBSTJILGtCQUFrQjNILE1BQU0sR0FBRyxHQUFHO29CQUlsQjJILDJCQUNDQTtnQkFKZjNKLFFBQVFlLEdBQUcsQ0FBQyx1Q0FBdUM7b0JBQ2pEK0YsUUFBUSxHQUFzQzZDLE9BQW5DQSxpQkFBaUIsQ0FBQyxFQUFFLENBQUM5RSxVQUFVLEVBQUMsS0FBa0MsT0FBL0I4RSxpQkFBaUIsQ0FBQyxFQUFFLENBQUM3RSxTQUFTO29CQUM1RVUsVUFBVW1FLGlCQUFpQixDQUFDLEVBQUUsQ0FBQ25FLFFBQVE7b0JBQ3ZDcUUsVUFBVSxHQUFFRiw0QkFBQUEsaUJBQWlCLENBQUMsRUFBRSxDQUFDSCxLQUFLLGNBQTFCRyxnREFBQUEsMEJBQTRCaEUsU0FBUztvQkFDakRtRSxXQUFXLEdBQUVILDZCQUFBQSxpQkFBaUIsQ0FBQyxFQUFFLENBQUNILEtBQUssY0FBMUJHLGlEQUFBQSwyQkFBNEJ6RSxLQUFLO2dCQUNoRDtZQUNGO1lBRUEsK0NBQStDO1lBQy9DLE9BQU87Z0JBQ0xvRSxTQUFTQztnQkFDVHZELE9BQU9tQyxTQUFTb0IsbUJBQW1CdkgsTUFBTTtnQkFDekNrSCxNQUFNakIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTaUIsSUFBSSxLQUFJO2dCQUN2QkMsVUFBVWxCLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU2tCLFFBQVEsS0FBSUksbUJBQW1CdkgsTUFBTTtZQUMxRDtRQUVJLEVBQUUsT0FBT2pDLE9BQU87WUFDbEJDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE1BQU1BO1FBQ1I7SUFDRjtJQUVGLHFFQUFxRTtJQUNyRSxNQUFNZ0ssWUFBVzFKLElBQVUsRUFBRTRILE9BUTVCO1FBQ0MsSUFBSTtZQUNGLE1BQU0vRixTQUFTLE1BQU0sSUFBSSxDQUFDOEYsbUJBQW1CLENBQUMzSCxNQUFNNEg7WUFDcEQsT0FBTy9GLE9BQU9vSCxPQUFPO1FBQ3ZCLEVBQUUsT0FBT3ZKLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsZ0VBQWdFO0lBQ2hFLE1BQU1qQixjQUFhZ0ksTUFBd0QsRUFBRXpHLElBQVU7UUFDckYsdURBQXVEO1FBQ3ZELE1BQU0ySixhQUFhbEQsT0FBT2xDLE1BQU0sSUFBSTtRQUVwQyxNQUFNcUYsaUJBQWlCO1lBQ3JCLEdBQUduRCxNQUFNO1lBQ1RsQyxRQUFRb0Y7WUFDUnhFLFVBQVVuRixLQUFLTyxFQUFFO1lBQ2pCNkUsYUFBYXFCLE9BQU9yQixXQUFXLElBQUlwRixLQUFLb0YsV0FBVztZQUNuREosV0FBV2hGLEtBQUtPLEVBQUU7WUFDbEI4RSxxQkFBcUJyRixLQUFLc0YsU0FBUztZQUNuQ0MsMkJBQTJCdkYsS0FBS3dGLFVBQVU7WUFDMUMsb0RBQW9EO1lBQ3BELEdBQUltRSxlQUFlLFlBQVk7Z0JBQUVFLG1CQUFtQixJQUFJdkosT0FBTzRFLFdBQVc7WUFBRyxDQUFDO1lBQzlFLHVEQUF1RDtZQUN2RDRFLFVBQVVyRCxPQUFPcUQsUUFBUSxJQUFJO1FBQy9CO1FBRUFuSyxRQUFRZSxHQUFHLENBQUMsa0NBQWtDa0o7UUFFOUMsTUFBTSxFQUFFdkssSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFdBQ0x3SyxNQUFNLENBQUM7WUFBQ0g7U0FBZSxFQUN2Qm5DLE1BQU0sR0FDTnVDLE1BQU07UUFFVCxJQUFJdEssT0FBTztZQUNUQyxRQUFRRCxLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxNQUFNQTtRQUNSO1FBRUEsT0FBT0w7SUFDVDtJQUVBLCtDQUErQztJQUMvQyxNQUFNNEssY0FBYTFKLEVBQVUsRUFBRTJKLE9BQXdCLEVBQUVsSyxJQUFVO1FBQ2pFLElBQUk7WUFDRkwsUUFBUWUsR0FBRyxDQUFDLDBCQUEwQjtnQkFBRUg7Z0JBQUkySjtnQkFBU2xLLE1BQU1BLEtBQUs2RSxLQUFLO1lBQUM7WUFFdEUscUVBQXFFO1lBQ3JFLE1BQU0sRUFBRXhGLE1BQU04SyxhQUFhLEVBQUV6SyxPQUFPMEssVUFBVSxFQUFFLEdBQUcsTUFBTXBMLFNBQ3RETyxJQUFJLENBQUMsV0FDTGtJLE1BQU0sQ0FBQyxvQkFDUGMsRUFBRSxDQUFDLE1BQU1oSSxJQUNUeUosTUFBTTtZQUVULElBQUlJLFlBQVk7Z0JBQ2R6SyxRQUFRRCxLQUFLLENBQUMseUNBQXlDMEs7Z0JBQ3ZELE1BQU0sSUFBSXRKLE1BQU0sOENBQWlFLE9BQW5Cc0osV0FBV3JKLE9BQU87WUFDbEY7WUFFQXBCLFFBQVFlLEdBQUcsQ0FBQyw0QkFBNEJ5SjtZQUV4QywyRUFBMkU7WUFDM0UsSUFBSUUsY0FBYztnQkFBRSxHQUFHSCxPQUFPO1lBQUM7WUFFL0Isa0ZBQWtGO1lBQ2xGLElBQUksWUFBWUcsZUFBZSxDQUFDQSxZQUFZOUYsTUFBTSxFQUFFO2dCQUNsRDVFLFFBQVFlLEdBQUcsQ0FBQztnQkFDWjJKLFlBQVk5RixNQUFNLEdBQUc7WUFDdkI7WUFFQSxpQ0FBaUM7WUFDakMsTUFBTStGLGdCQUFnQkQsWUFBWTlGLE1BQU0sSUFBSThGLFlBQVk5RixNQUFNLEtBQUs0RixjQUFjNUYsTUFBTTtZQUN2RixJQUFJK0YsZUFBZTtnQkFDakJELFlBQVlSLGlCQUFpQixHQUFHLElBQUl2SixPQUFPNEUsV0FBVztnQkFDdER2RixRQUFRZSxHQUFHLENBQUMsb0NBQXVEd0osT0FBN0JDLGNBQWM1RixNQUFNLEVBQUMsVUFBdUIsT0FBZjJGLFFBQVEzRixNQUFNLEVBQUM7Z0JBRWxGLG9DQUFvQztnQkFDcEMsSUFBSTJGLFFBQVEzRixNQUFNLEtBQUssVUFBVTtvQkFDL0I1RSxRQUFRZSxHQUFHLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBLCtDQUErQztZQUMvQzJKLFlBQVlsRixRQUFRLEdBQUduRixLQUFLTyxFQUFFO1lBQzlCWixRQUFRZSxHQUFHLENBQUMsbUNBQThDVixPQUFyQk8sSUFBRyxvQkFBOEJQLE9BQVpBLEtBQUtPLEVBQUUsRUFBQyxNQUFlLE9BQVhQLEtBQUs2RSxLQUFLLEVBQUM7WUFFakYsbUVBQW1FO1lBQ25Fd0YsWUFBWWhGLG1CQUFtQixHQUFHckYsS0FBS3NGLFNBQVM7WUFDaEQrRSxZQUFZOUUseUJBQXlCLEdBQUd2RixLQUFLd0YsVUFBVTtZQUN2RDdGLFFBQVFlLEdBQUcsQ0FBQyx1Q0FBc0RWLE9BQXpCQSxLQUFLc0YsU0FBUyxFQUFDLFlBQW9CLE9BQVZ0RixLQUFLMEcsSUFBSSxFQUFDO1lBRTVFLHNEQUFzRDtZQUN0RCxJQUFJMUcsS0FBSzBHLElBQUksS0FBSyxlQUFlNEQsZUFBZTtnQkFDOUMzSyxRQUFRZSxHQUFHLENBQUMsMEJBQWdEeUosT0FBaENuSyxLQUFLNkUsS0FBSyxFQUFDLHVCQUFrRHFGLE9BQTdCQyxjQUFjNUYsTUFBTSxFQUFDLFVBQXVCLE9BQWYyRixRQUFRM0YsTUFBTSxFQUFDO1lBQzFHO1lBRUE1RSxRQUFRZSxHQUFHLENBQUMsNEJBQTRCMko7WUFFeEMsbUNBQW1DO1lBQ25DLE1BQU1FLFlBQVk7Z0JBQ2hCLEdBQUdGLFdBQVc7Z0JBQ2RyRixXQUFXaEYsS0FBS08sRUFBRTtnQkFDbEJpSyxZQUFZLElBQUlsSyxPQUFPNEUsV0FBVztnQkFDbEMsdURBQXVEO2dCQUN2RCxHQUFJbUYsWUFBWVAsUUFBUSxLQUFLM0YsYUFBYTtvQkFBRTJGLFVBQVVPLFlBQVlQLFFBQVEsSUFBSTtnQkFBSyxDQUFDO1lBQ3RGO1lBRUFuSyxRQUFRZSxHQUFHLENBQUMsOEJBQThCNko7WUFFMUMsNEJBQTRCO1lBQzVCLE1BQU0sRUFBRWxMLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxXQUNMa0wsTUFBTSxDQUFDRixXQUNQaEMsRUFBRSxDQUFDLE1BQU1oSSxJQUNUa0gsTUFBTSxHQUNOdUMsTUFBTTtZQUVULElBQUl0SyxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtnQkFDeENDLFFBQVFELEtBQUssQ0FBQyxnQkFBZ0JBLE1BQU1nTCxJQUFJO2dCQUN4Qy9LLFFBQVFELEtBQUssQ0FBQyxnQkFBZ0JBLE1BQU1pTCxPQUFPO2dCQUMzQ2hMLFFBQVFELEtBQUssQ0FBQyxXQUFXQSxNQUFNa0wsSUFBSTtnQkFDbkMsTUFBTSxJQUFJOUosTUFBTSxzQkFBNkNwQixPQUF2QkEsTUFBTXFCLE9BQU8sRUFBQyxXQUFvQixPQUFYckIsTUFBTWdMLElBQUksRUFBQztZQUMxRTtZQUVBL0ssUUFBUWUsR0FBRyxDQUFDLDJCQUEyQnJCO1lBQ3ZDLE9BQU9BO1FBRVQsRUFBRSxPQUFPSyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGlEQUFpRDtJQUNqRCxNQUFNbUwsc0JBQXFCQyxRQUFnQixFQUFFOUssSUFBVTtRQUNyREwsUUFBUWUsR0FBRyxDQUFDLHVEQUF1RG9LO1FBRW5FLE1BQU0sRUFBRXpMLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxXQUNMa0wsTUFBTSxDQUFDO1lBQ05NLGtCQUFrQixJQUFJekssT0FBTzRFLFdBQVc7WUFDeENzRixZQUFZLElBQUlsSyxPQUFPNEUsV0FBVztRQUNwQyxHQUNDcUQsRUFBRSxDQUFDLE1BQU11QyxVQUNUckQsTUFBTSxHQUNOdUMsTUFBTTtRQUVULElBQUl0SyxPQUFPO1lBQ1RDLFFBQVFELEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE1BQU1BO1FBQ1I7UUFFQSwwQkFBMEI7UUFDMUIsSUFBSTtZQUNGLE1BQU1zTCxnQkFBZ0JDLFNBQVMsQ0FBQztnQkFDOUJDLFdBQVdKO2dCQUNYSyxZQUFZbkwsS0FBS08sRUFBRTtnQkFDbkI2SyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxXQUFXbkg7Z0JBQ1hvSCxXQUFXbE0sS0FBSzBMLGdCQUFnQjtZQUNsQztRQUNGLEVBQUUsT0FBT1MsVUFBVTtZQUNqQjdMLFFBQVFELEtBQUssQ0FBQywwREFBMEQ4TDtRQUMxRTtRQUVBLE9BQU9uTTtJQUNUO0lBRUEsd0NBQXdDO0lBQ3hDLE1BQU1vTSxjQUFhbEwsRUFBVSxFQUFFUCxJQUFVO1FBQ3ZDLG1EQUFtRDtRQUNuRCxNQUFNLEVBQUVOLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQ3JCTyxJQUFJLENBQUMsV0FDTG1NLE1BQU0sR0FDTm5ELEVBQUUsQ0FBQyxNQUFNaEk7UUFFWixJQUFJYixPQUFPLE1BQU1BO0lBQ25CO0lBRUEsMERBQTBEO0lBQzFELE1BQU1pTSxjQUFhYixRQUFnQixFQUFFYyxVQUFrQixFQUFFNUwsSUFBVTtRQUNqRSxJQUFJLENBQUN1RyxlQUFlTyxnQkFBZ0IsQ0FBQzlHLE9BQU87WUFDMUMsTUFBTSxJQUFJYyxNQUFNO1FBQ2xCO1FBRUEsTUFBTSxFQUFFekIsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFdBQ0xrTCxNQUFNLENBQUM7WUFDTnRGLFVBQVV5RztZQUNWNUcsV0FBV2hGLEtBQUtPLEVBQUU7WUFDbEJpSyxZQUFZLElBQUlsSyxPQUFPNEUsV0FBVztRQUNwQyxHQUNDcUQsRUFBRSxDQUFDLE1BQU11QyxVQUNUckQsTUFBTSxHQUNOdUMsTUFBTTtRQUVULElBQUl0SyxPQUFPLE1BQU1BO1FBQ2pCLE9BQU9MO0lBQ1Q7SUFFQSxrREFBa0Q7SUFDbEQsTUFBTXdNO1FBQ0osSUFBSTtZQUNGbE0sUUFBUWUsR0FBRyxDQUFDO1lBRVoseUNBQXlDO1lBQ3pDLE1BQU0sRUFBRXJCLE1BQU15TSxVQUFVLEVBQUVwTSxPQUFPcU0sWUFBWSxFQUFFLEdBQUcsTUFBTS9NLFNBQ3JETyxJQUFJLENBQUMsV0FDTGtJLE1BQU0sQ0FBQyx1Q0FDUHVFLEdBQUcsQ0FBQyxZQUFZLE1BQU07WUFFekIsSUFBSUQsY0FBYyxNQUFNQTtZQUV4QnBNLFFBQVFlLEdBQUcsQ0FBQyxzQ0FBc0NvTCxDQUFBQSx1QkFBQUEsaUNBQUFBLFdBQVluSyxNQUFNLEtBQUk7WUFFeEUsSUFBSSxDQUFDbUssY0FBY0EsV0FBV25LLE1BQU0sS0FBSyxHQUFHO2dCQUMxQyxPQUFPO29CQUFFc0ssU0FBUztvQkFBR2pHLFFBQVEsRUFBRTtnQkFBQztZQUNsQztZQUVBLHNDQUFzQztZQUN0QyxNQUFNa0csV0FBVzttQkFBSSxJQUFJQyxJQUFJTCxXQUFXM0osR0FBRyxDQUFDaUssQ0FBQUEsSUFBS0EsRUFBRWpILFFBQVE7YUFBRztZQUM5RHhGLFFBQVFlLEdBQUcsQ0FBQywwQkFBMEJ3TDtZQUV0QyxxQ0FBcUM7WUFDckMsTUFBTSxFQUFFN00sTUFBTWdOLGFBQWEsRUFBRTNNLE9BQU80TSxVQUFVLEVBQUUsR0FBRyxNQUFNdE4sU0FDdERPLElBQUksQ0FBQyxTQUNMa0ksTUFBTSxDQUFDLE1BQ1A4RSxFQUFFLENBQUMsTUFBTUw7WUFFWixJQUFJSSxZQUFZLE1BQU1BO1lBRXRCLE1BQU1FLGtCQUFrQixDQUFDSCxpQkFBaUIsRUFBRSxFQUFFbEssR0FBRyxDQUFDc0ssQ0FBQUEsSUFBS0EsRUFBRWxNLEVBQUU7WUFDM0RaLFFBQVFlLEdBQUcsQ0FBQyw2QkFBNkI4TDtZQUV6Qyw2Q0FBNkM7WUFDN0MsTUFBTUUsaUJBQWlCWixXQUFXdEssTUFBTSxDQUFDaUYsQ0FBQUEsU0FDdkNBLE9BQU90QixRQUFRLElBQUksQ0FBQ3FILGdCQUFnQnBOLFFBQVEsQ0FBQ3FILE9BQU90QixRQUFRO1lBRzlEeEYsUUFBUWUsR0FBRyxDQUFDLGdDQUFnQ2dNLGVBQWUvSyxNQUFNO1lBRWpFLElBQUkrSyxlQUFlL0ssTUFBTSxLQUFLLEdBQUc7Z0JBQy9CaEMsUUFBUWUsR0FBRyxDQUFDO2dCQUNaLE9BQU87b0JBQUV1TCxTQUFTO29CQUFHakcsUUFBUSxFQUFFO2dCQUFDO1lBQ2xDO1lBRUEsaURBQWlEO1lBQ2pELE1BQU0yRyxpQkFBMkIsRUFBRTtZQUNuQyxNQUFNM0csU0FBZ0IsRUFBRTtZQUV4QixLQUFLLE1BQU1TLFVBQVVpRyxlQUFnQjtnQkFDbkMsSUFBSTtvQkFDRi9NLFFBQVFlLEdBQUcsQ0FBQyxzQ0FBaUQrRixPQUFyQkEsT0FBT2pDLFVBQVUsRUFBQyxLQUF3QmlDLE9BQXJCQSxPQUFPaEMsU0FBUyxFQUFDLE1BQW9CLE9BQWhCZ0MsT0FBT3RCLFFBQVEsRUFBQztvQkFFbEcsTUFBTSxFQUFFekYsS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDckJPLElBQUksQ0FBQyxXQUNMa0wsTUFBTSxDQUFDO3dCQUFFdEYsVUFBVTtvQkFBSyxHQUN4Qm9ELEVBQUUsQ0FBQyxNQUFNOUIsT0FBT2xHLEVBQUU7b0JBRXJCLElBQUliLE9BQU87d0JBQ1RDLFFBQVFELEtBQUssQ0FBQyxzQkFBZ0MsT0FBVitHLE9BQU9sRyxFQUFFLEVBQUMsTUFBSWI7d0JBQ2xEc0csT0FBTzlELElBQUksQ0FBQzs0QkFBRXVFLFFBQVFBLE9BQU9sRyxFQUFFOzRCQUFFYixPQUFPQSxNQUFNcUIsT0FBTzt3QkFBQztvQkFDeEQsT0FBTzt3QkFDTDRMLGVBQWV6SyxJQUFJLENBQUN1RSxPQUFPbEcsRUFBRTtvQkFDL0I7Z0JBQ0YsRUFBRSxPQUFPcU0sS0FBSztvQkFDWmpOLFFBQVFELEtBQUssQ0FBQyxpQ0FBMkMsT0FBVitHLE9BQU9sRyxFQUFFLEVBQUMsTUFBSXFNO29CQUM3RDVHLE9BQU85RCxJQUFJLENBQUM7d0JBQUV1RSxRQUFRQSxPQUFPbEcsRUFBRTt3QkFBRWIsT0FBT21OLE9BQU9EO29CQUFLO2dCQUN0RDtZQUNGO1lBRUFqTixRQUFRZSxHQUFHLENBQUMsa0JBQXdDLE9BQXRCaU0sZUFBZWhMLE1BQU0sRUFBQztZQUNwRCxJQUFJcUUsT0FBT3JFLE1BQU0sR0FBRyxHQUFHO2dCQUNyQmhDLFFBQVFELEtBQUssQ0FBQyxnQkFBOEIsT0FBZHNHLE9BQU9yRSxNQUFNLEVBQUMsZ0JBQWNxRTtZQUM1RDtZQUVBLE9BQU87Z0JBQ0xpRyxTQUFTVSxlQUFlaEwsTUFBTTtnQkFDOUJxRTtnQkFDQThHLGdCQUFnQkosZUFBZWxMLE1BQU0sQ0FBQzRLLENBQUFBLElBQUtPLGVBQWV2TixRQUFRLENBQUNnTixFQUFFN0wsRUFBRTtZQUN6RTtRQUVGLEVBQUUsT0FBT2IsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxNQUFNQTtRQUNSO0lBQ0Y7SUFJQSw4Q0FBOEM7SUFDOUNxTixvQkFBbUJDLFFBQWdDO1FBQ2pELE9BQU9oTyxTQUNKaU8sT0FBTyxDQUFDLG1CQUNSQyxFQUFFLENBQUMsb0JBQ0Y7WUFBRUMsT0FBTztZQUFLQyxRQUFRO1lBQVVDLE9BQU87UUFBVSxHQUNqREwsVUFFRE0sU0FBUztJQUNkO0lBRUEsNERBQTREO0lBQzVEQyx5QkFBd0JQLFFBQWdDO1FBQ3RELElBQUk7WUFDRixvQ0FBb0M7WUFDcEMsSUFBSSxPQUFPQSxhQUFhLFlBQVk7Z0JBQ2xDck4sUUFBUUQsS0FBSyxDQUFDO2dCQUNkLE1BQU0sSUFBSW9CLE1BQU07WUFDbEI7WUFFQW5CLFFBQVFlLEdBQUcsQ0FBQztZQUVaLDBEQUEwRDtZQUMxRCxNQUFNOE0sY0FBYyx5QkFBb0MsT0FBWGxOLEtBQUtFLEdBQUc7WUFDckRiLFFBQVFlLEdBQUcsQ0FBQyxvQkFBb0I4TTtZQUVoQyxNQUFNUCxVQUFVak8sU0FDYmlPLE9BQU8sQ0FBQ08sYUFDUk4sRUFBRSxDQUFDLG9CQUNGO2dCQUNFQyxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxPQUFPO2dCQUNQN0wsUUFBUSxvQkFBb0IsaUNBQWlDO1lBQy9ELEdBQ0EsQ0FBQ2lNO2dCQUNDLElBQUk7b0JBQ0Y5TixRQUFRZSxHQUFHLENBQUMsbUNBQW1DO3dCQUM3Q2dOLFdBQVdELFFBQVFDLFNBQVM7d0JBQzVCTCxPQUFPSSxRQUFRSixLQUFLO3dCQUNwQk0sU0FBU0YsUUFBUUcsR0FBRyxHQUFHOzRCQUNyQnJOLElBQUlrTixRQUFRRyxHQUFHLENBQUNyTixFQUFFOzRCQUNsQjRFLFVBQVVzSSxRQUFRRyxHQUFHLENBQUN6SSxRQUFROzRCQUM5QlgsWUFBWWlKLFFBQVFHLEdBQUcsQ0FBQ3BKLFVBQVU7NEJBQ2xDQyxXQUFXZ0osUUFBUUcsR0FBRyxDQUFDbkosU0FBUzt3QkFDbEMsSUFBSTtvQkFDTjtvQkFFQSxJQUFJLE9BQU91SSxhQUFhLFlBQVk7d0JBQ2xDQSxTQUFTUztvQkFDWCxPQUFPO3dCQUNMOU4sUUFBUUQsS0FBSyxDQUFDO29CQUNoQjtnQkFDRixFQUFFLE9BQU9tTyxlQUFlO29CQUN0QmxPLFFBQVFELEtBQUssQ0FBQyxzQkFBc0JtTztnQkFDdEM7WUFDRixHQUVEUCxTQUFTLENBQUMsQ0FBQy9JLFFBQVFxSTtnQkFDbEJqTixRQUFRZSxHQUFHLENBQUMsd0NBQXdDNkQ7Z0JBRXBELElBQUlBLFdBQVcsY0FBYztvQkFDM0I1RSxRQUFRZSxHQUFHLENBQUM7Z0JBQ2QsT0FBTyxJQUFJNkQsV0FBVyxVQUFVO29CQUM5QjVFLFFBQVFDLElBQUksQ0FBQztvQkFDYkQsUUFBUUMsSUFBSSxDQUFDO2dCQUNmLE9BQU8sSUFBSTJFLFdBQVcsaUJBQWlCO29CQUNyQzVFLFFBQVFELEtBQUssQ0FBQyw0QkFBNEJrTjtvQkFDMUNqTixRQUFRRCxLQUFLLENBQUM7Z0JBQ2hCLE9BQU8sSUFBSTZFLFdBQVcsYUFBYTtvQkFDakM1RSxRQUFRQyxJQUFJLENBQUM7Z0JBQ2YsT0FBTztvQkFDTEQsUUFBUWUsR0FBRyxDQUFDLDBCQUEwQjZEO2dCQUN4QztZQUNGO1lBRUYsd0NBQXdDO1lBQ3hDdUosV0FBVztnQkFDVCxJQUFJYixRQUFRYyxLQUFLLEtBQUssVUFBVTtvQkFDOUJwTyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2Y7WUFDRixHQUFHO1lBRUhELFFBQVFlLEdBQUcsQ0FBQztZQUNaLE9BQU91TTtRQUVULEVBQUUsT0FBT3ZOLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkRDLFFBQVFDLElBQUksQ0FBQztZQUViLDZDQUE2QztZQUM3QyxPQUFPO2dCQUNMb08sYUFBYTtvQkFDWHJPLFFBQVFlLEdBQUcsQ0FBQztnQkFDZDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLHdEQUF3RDtJQUN4RCxNQUFNdU4seUJBQXdCak8sSUFBVSxFQUFFa08sVUFBbUI7UUFDM0QsSUFBSTtZQUNGLE1BQU1DLFFBQVFELGNBQWMsSUFBSTVOLE9BQU80RSxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxvQkFBb0I7O1lBRXZGNUIsUUFBUWUsR0FBRyxDQUFDLDZEQUFzRCxPQUFOeU47WUFFNUQsMERBQTBEO1lBQzFELE1BQU1yQyxhQUFhLE1BQU0sSUFBSSxDQUFDcEMsVUFBVSxDQUFDMUo7WUFFekMsK0NBQStDO1lBQy9DLE1BQU1vTyw0QkFBNEJ0QyxXQUFXdEssTUFBTSxDQUFDLENBQUNpRjtnQkFDbkQsOENBQThDO2dCQUM5QyxNQUFNcUQsV0FBV3JELE9BQU9xRCxRQUFRLElBQUk7b0JBQ2xDdUUsU0FBUztvQkFDVGhHLE1BQU07b0JBQ05pRyxNQUFNO29CQUNOQyxNQUFNO2dCQUNSO2dCQUVBLE9BQU96RSxTQUFTdUUsT0FBTyxJQUFJdkUsU0FBU3pCLElBQUksS0FBSzhGO1lBQy9DO1lBRUEsc0NBQXNDO1lBQ3RDLE1BQU1LLGdCQUFnQkosMEJBQTBCSyxJQUFJLENBQUMsQ0FBQ0MsR0FBUUM7b0JBQzlDRCxhQUNBQztnQkFEZCxNQUFNQyxRQUFRRixFQUFBQSxjQUFBQSxFQUFFNUUsUUFBUSxjQUFWNEUsa0NBQUFBLFlBQVlKLElBQUksS0FBSTtnQkFDbEMsTUFBTU8sUUFBUUYsRUFBQUEsY0FBQUEsRUFBRTdFLFFBQVEsY0FBVjZFLGtDQUFBQSxZQUFZTCxJQUFJLEtBQUk7Z0JBQ2xDLE9BQU9NLE1BQU1FLGFBQWEsQ0FBQ0Q7WUFDN0I7WUFFQWxQLFFBQVFlLEdBQUcsQ0FBQyxnQkFBc0V5TixPQUF0REssY0FBYzdNLE1BQU0sRUFBQyxzQ0FBdUMsT0FBTndNO1lBRWxGLE9BQU9LO1FBQ1QsRUFBRSxPQUFPOU8sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaURBQWlEQTtZQUMvRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSwyRUFBMkU7SUFDM0UsTUFBTXFQLDZCQUE0Qi9PLElBQVUsRUFBRWtPLFVBQW1CO1FBQy9ELElBQUk7WUFDRixNQUFNYyx1QkFBdUIsTUFBTSxJQUFJLENBQUNmLHVCQUF1QixDQUFDak8sTUFBTWtPO1lBRXRFLHFFQUFxRTtZQUNyRSxNQUFNZSxZQUFZO2dCQUNoQjtvQkFDRVgsTUFBTTtvQkFDTlksTUFBTTtvQkFDTkMsT0FBTztvQkFDUEMsV0FBVztvQkFDWEMsU0FBUztvQkFDVEMsVUFBVTt3QkFBQztxQkFBUztnQkFDdEI7Z0JBQ0E7b0JBQ0VoQixNQUFNO29CQUNOWSxNQUFNO29CQUNOQyxPQUFPO29CQUNQQyxXQUFXO29CQUNYQyxTQUFTO29CQUNUQyxVQUFVO3dCQUFDO3FCQUFPO2dCQUNwQjtnQkFDQTtvQkFDRWhCLE1BQU07b0JBQ05ZLE1BQU07b0JBQ05DLE9BQU87b0JBQ1BDLFdBQVc7b0JBQ1hDLFNBQVM7b0JBQ1RDLFVBQVU7d0JBQUM7cUJBQVc7Z0JBQ3hCO2dCQUNBO29CQUNFaEIsTUFBTTtvQkFDTlksTUFBTTtvQkFDTkMsT0FBTztvQkFDUEMsV0FBVztvQkFDWEMsU0FBUztvQkFDVEMsVUFBVTt3QkFBQzt3QkFBVTtxQkFBTztnQkFDOUI7YUFDRDtZQUVELGtGQUFrRjtZQUNsRixNQUFNQyxtQkFBbUJOLFVBQVU5TSxHQUFHLENBQUNxTixDQUFBQTtnQkFDckMsTUFBTUMsY0FBY1QscUJBQXFCeE4sTUFBTSxDQUFDaUYsQ0FBQUE7d0JBQ3pCQTtvQkFBckIsTUFBTWlKLGVBQWVqSixFQUFBQSxtQkFBQUEsT0FBT3FELFFBQVEsY0FBZnJELHVDQUFBQSxpQkFBaUI2SCxJQUFJLEtBQUk7b0JBQzlDLE1BQU0sQ0FBQ3FCLE9BQU9DLFFBQVEsR0FBR0YsYUFBYW5PLEtBQUssQ0FBQyxLQUFLWSxHQUFHLENBQUMwTjtvQkFDckQsTUFBTUMsa0JBQWtCSCxRQUFRLEtBQUtDO29CQUVyQyxNQUFNLENBQUNHLFlBQVlDLFVBQVUsR0FBR1IsS0FBS0osU0FBUyxDQUFDN04sS0FBSyxDQUFDLEtBQUtZLEdBQUcsQ0FBQzBOO29CQUM5RCxNQUFNLENBQUNJLFVBQVVDLFFBQVEsR0FBR1YsS0FBS0gsT0FBTyxDQUFDOU4sS0FBSyxDQUFDLEtBQUtZLEdBQUcsQ0FBQzBOO29CQUN4RCxNQUFNTSxlQUFlSixhQUFhLEtBQUtDO29CQUN2QyxNQUFNSSxhQUFhSCxXQUFXLEtBQUtDO29CQUVuQyxpRUFBaUU7b0JBQ2pFLE1BQU1HLGFBQWFQLG1CQUFtQkssZ0JBQWdCTCxtQkFBbUJNO29CQUV6RXpRLFFBQVFlLEdBQUcsQ0FBQyx1QkFBa0MrRixPQUFyQkEsT0FBT2pDLFVBQVUsRUFBQyxLQUE2QmtMLE9BQTFCakosT0FBT2hDLFNBQVMsRUFBQyxXQUEwQnFMLE9BQWpCSixjQUFhLE1BQW1DRixPQUEvQk0saUJBQWdCLGlCQUE2QkssT0FBZFgsS0FBS2xCLElBQUksRUFBQyxNQUFvQjhCLE9BQWhCRCxjQUFhLEtBQXVCRSxPQUFwQkQsWUFBVyxXQUE4QyxPQUFyQ0MsYUFBYSxXQUFXO29CQUVsTSxPQUFPQTtnQkFDVDtnQkFFQTFRLFFBQVFlLEdBQUcsQ0FBQyxxQkFBeUIrTyxPQUFkRCxLQUFLbEIsSUFBSSxFQUFDLE1BQXVCLE9BQW5CbUIsWUFBWTlOLE1BQU0sRUFBQztnQkFFeEQsT0FBTztvQkFDTCxHQUFHNk4sSUFBSTtvQkFDUHZHLFNBQVN3RztnQkFDWDtZQUNGO1lBRUE5UCxRQUFRZSxHQUFHLENBQUMsNEJBQXVGLE9BQXJFNk8saUJBQWlCZSxNQUFNLENBQUMsQ0FBQ0MsS0FBS2YsT0FBU2UsTUFBTWYsS0FBS3ZHLE9BQU8sQ0FBQ3RILE1BQU0sRUFBRSxJQUFHO1lBRW5HLE9BQU80TjtRQUNULEVBQUUsT0FBTzdQLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsTUFBTUE7UUFDUjtJQUNGO0FBQ0YsRUFBQztBQUVELG1DQUFtQztBQUM1QixNQUFNc0wsa0JBQWtCO0lBQzdCLDBCQUEwQjtJQUMxQixNQUFNd0YsU0FBUTFGLFFBQWlCO1FBQzdCLElBQUlqRCxRQUFRN0ksU0FDVE8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFFLGdFQUlSVSxLQUFLLENBQUMsYUFBYTtZQUFFQyxXQUFXO1FBQU0sR0FDdENWLEtBQUssQ0FBQztRQUVULElBQUlvRCxVQUFVO1lBQ1pqRCxRQUFRQSxNQUFNVSxFQUFFLENBQUMsYUFBYXVDO1FBQ2hDO1FBRUEsTUFBTSxFQUFFekwsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNbUk7UUFDOUIsSUFBSW5JLE9BQU8sTUFBTUE7UUFDakIsT0FBT0w7SUFDVDtJQUVBLGlEQUFpRDtJQUNqRCxNQUFNb1Isa0JBQWlCM0YsUUFBZ0I7UUFDckMsSUFBSTtZQUNGbkwsUUFBUWUsR0FBRyxDQUFDLG9DQUFvQ29LO1lBRWhELHlDQUF5QztZQUN6QyxNQUFNLEVBQUV6TCxNQUFNLEVBQUVXLElBQUksRUFBRSxFQUFFLEdBQUcsTUFBTWhCLFNBQVMwUixJQUFJLENBQUNDLE9BQU87WUFDdERoUixRQUFRZSxHQUFHLENBQUMsd0JBQXdCVixpQkFBQUEsMkJBQUFBLEtBQU1PLEVBQUU7WUFFNUMsSUFBSSxDQUFDUCxNQUFNO2dCQUNUTCxRQUFRRCxLQUFLLENBQUM7Z0JBQ2QsT0FBTyxFQUFFO1lBQ1g7WUFFQSxNQUFNLEVBQUVMLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxpQkFDTGtJLE1BQU0sQ0FBRSw2TEFVUmMsRUFBRSxDQUFDLGFBQWF1QyxVQUNoQjNDLEtBQUssQ0FBQyxhQUFhO2dCQUFFQyxXQUFXO1lBQU0sR0FDdENWLEtBQUssQ0FBQztZQUVULElBQUloSSxPQUFPO29CQUt3QkE7Z0JBSmpDQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtnQkFDM0NDLFFBQVFELEtBQUssQ0FBQyxvQkFBb0JrUixLQUFLQyxTQUFTLENBQUNuUixPQUFPLE1BQU07Z0JBRTlELCtCQUErQjtnQkFDL0IsSUFBSUEsTUFBTWdMLElBQUksS0FBSyxnQkFBY2hMLGlCQUFBQSxNQUFNcUIsT0FBTyxjQUFickIscUNBQUFBLGVBQWVOLFFBQVEsQ0FBQyxTQUFRO29CQUMvRE8sUUFBUUQsS0FBSyxDQUFDO2dCQUNoQjtnQkFFQSw4Q0FBOEM7Z0JBQzlDLE9BQU8sRUFBRTtZQUNYO1lBRUFDLFFBQVFlLEdBQUcsQ0FBQyxpQkFBaUJyQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQyxNQUFNLEtBQUk7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ3RDLFFBQVFBLEtBQUtzQyxNQUFNLEtBQUssR0FBRztnQkFDOUIsT0FBTyxFQUFFO1lBQ1g7WUFFQSx3REFBd0Q7WUFDeEQsTUFBTW1QLFVBQVU7bUJBQUksSUFBSTNFLElBQUk5TSxLQUFLOEMsR0FBRyxDQUFDekIsQ0FBQUEsTUFBT0EsSUFBSXlLLFVBQVUsRUFBRTNKLE1BQU0sQ0FBQ3VQO2FBQVU7WUFDN0VwUixRQUFRZSxHQUFHLENBQUMsNEJBQTRCb1E7WUFFeEMsTUFBTSxFQUFFelIsTUFBTTJSLEtBQUssRUFBRXRSLE9BQU80TSxVQUFVLEVBQUUsR0FBRyxNQUFNdE4sU0FDOUNPLElBQUksQ0FBQyxTQUNMa0ksTUFBTSxDQUFDLG1DQUNQOEUsRUFBRSxDQUFDLE1BQU11RTtZQUVaLElBQUl4RSxZQUFZO2dCQUNkM00sUUFBUUQsS0FBSyxDQUFDLGlDQUFpQzRNO1lBQy9DLG9DQUFvQztZQUN0QztZQUVBM00sUUFBUWUsR0FBRyxDQUFDLHlCQUF5QnNRLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT3JQLE1BQU0sS0FBSTtZQUV0RCx1REFBdUQ7WUFDdkQsTUFBTXNQLFdBQVcsQ0FBQ0QsU0FBUyxFQUFFLEVBQUVWLE1BQU0sQ0FBQyxDQUFDWSxLQUFLbFI7Z0JBQzFDa1IsR0FBRyxDQUFDbFIsS0FBS08sRUFBRSxDQUFDLEdBQUdQO2dCQUNmLE9BQU9rUjtZQUNULEdBQUcsQ0FBQztZQUVKLDZDQUE2QztZQUM3QyxNQUFNclAsU0FBU3hDLEtBQUs4QyxHQUFHLENBQUMsQ0FBQ3pCO2dCQUN2QixNQUFNVixPQUFPaVIsUUFBUSxDQUFDdlEsSUFBSXlLLFVBQVUsQ0FBQztnQkFDckMsT0FBTztvQkFDTDVLLElBQUlHLElBQUlILEVBQUU7b0JBQ1YySyxXQUFXeEssSUFBSXdLLFNBQVM7b0JBQ3hCQyxZQUFZekssSUFBSXlLLFVBQVU7b0JBQzFCQyxhQUFhMUssSUFBSTBLLFdBQVc7b0JBQzVCQyxlQUFlM0ssSUFBSTJLLGFBQWE7b0JBQ2hDQyxXQUFXNUssSUFBSTRLLFNBQVM7b0JBQ3hCQyxXQUFXN0ssSUFBSTZLLFNBQVM7b0JBQ3hCNEYsV0FBV3pRLElBQUl5USxTQUFTO29CQUN4QkMsYUFBYXBSLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXNGLFNBQVMsS0FBSTVFLElBQUl5SyxVQUFVLElBQUk7b0JBQ2xEa0csYUFBYXJSLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTTBHLElBQUksS0FBSTtvQkFDM0I0SyxlQUFldFIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNd0YsVUFBVSxLQUFJO2dCQUNyQztZQUNGO1lBRUE3RixRQUFRZSxHQUFHLENBQUMsdUJBQXVCbUIsT0FBT0YsTUFBTSxFQUFFO1lBQ2xELE9BQU9FO1FBRVQsRUFBRSxPQUFPbkMsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTXVMLFdBQVV2SyxHQUEwQztRQUN4RCxNQUFNLEVBQUVyQixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsaUJBQ0x3SyxNQUFNLENBQUM7WUFBQztnQkFDUCxHQUFHckosR0FBRztnQkFDTnlRLFdBQVcsSUFBSTdRLE9BQU80RSxXQUFXO1lBQ25DO1NBQUUsRUFDRHVDLE1BQU0sR0FDTnVDLE1BQU07UUFFVCxJQUFJdEssT0FBTyxNQUFNQTtRQUNqQixPQUFPTDtJQUNUO0lBRUEsMERBQTBEO0lBQzFELE1BQU1rUztRQUNKLElBQUk7WUFDRjVSLFFBQVFlLEdBQUcsQ0FBQztZQUVaLHNCQUFzQjtZQUN0QixNQUFNLEVBQUVyQixNQUFNLEVBQUVXLElBQUksRUFBRSxFQUFFLEdBQUcsTUFBTWhCLFNBQVMwUixJQUFJLENBQUNDLE9BQU87WUFDdERoUixRQUFRZSxHQUFHLENBQUMsc0JBQXNCVixpQkFBQUEsMkJBQUFBLEtBQU1PLEVBQUUsRUFBRVAsaUJBQUFBLDJCQUFBQSxLQUFNNkUsS0FBSztZQUV2RCxJQUFJLENBQUM3RSxNQUFNO2dCQUNULE9BQU87b0JBQ0wrRixTQUFTO29CQUNUckcsT0FBTztnQkFDVDtZQUNGO1lBRUEsaURBQWlEO1lBQ2pELE1BQU0sRUFBRUwsTUFBTW1TLFdBQVcsRUFBRTlSLE9BQU8rUixTQUFTLEVBQUUsR0FBRyxNQUFNelMsU0FDbkRPLElBQUksQ0FBQyxTQUNMa0ksTUFBTSxDQUFDLG1CQUNQYyxFQUFFLENBQUMsTUFBTXZJLEtBQUtPLEVBQUUsRUFDaEJ5SixNQUFNO1lBRVRySyxRQUFRZSxHQUFHLENBQUMsOEJBQThCOFE7WUFDMUM3UixRQUFRZSxHQUFHLENBQUMsd0JBQXdCK1E7WUFFcEMsSUFBSUEsYUFBYSxDQUFDRCxhQUFhO2dCQUM3QixPQUFPO29CQUNMekwsU0FBUztvQkFDVHJHLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLGlDQUFpQztZQUNqQyxNQUFNLEVBQUVMLElBQUksRUFBRUssS0FBSyxFQUFFb0ksS0FBSyxFQUFFLEdBQUcsTUFBTTlJLFNBQ2xDTyxJQUFJLENBQUMsaUJBQ0xrSSxNQUFNLENBQUMsS0FBSztnQkFBRUssT0FBTztZQUFRLEdBQzdCSixLQUFLLENBQUM7WUFFVC9ILFFBQVFlLEdBQUcsQ0FBQyw4QkFBOEJyQjtZQUMxQ00sUUFBUWUsR0FBRyxDQUFDLCtCQUErQmhCO1lBQzNDQyxRQUFRZSxHQUFHLENBQUMsK0JBQStCb0g7WUFFM0MsT0FBTztnQkFDTC9CLFNBQVMsQ0FBQ3JHO2dCQUNWTDtnQkFDQUs7Z0JBQ0FvSTtnQkFDQTlILE1BQU13UjtZQUNSO1FBQ0YsRUFBRSxPQUFPOVIsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtZQUMzQyxPQUFPO2dCQUFFcUcsU0FBUztnQkFBT3JHO1lBQU07UUFDakM7SUFDRjtBQUNGLEVBQUM7QUE4QkQsMkJBQTJCO0FBQ3BCLE1BQU1nUyxhQUFhO0lBQ3hCLGtEQUFrRDtJQUNsRCxNQUFNQyxrQkFBaUIzUixJQUFVO1FBQy9CLElBQUk7WUFDRkwsUUFBUWUsR0FBRyxDQUFDO1lBRVosNkRBQTZEO1lBQzdELE1BQU0sRUFBRXJCLE1BQU11UyxZQUFZLEVBQUVsUyxPQUFPNE0sVUFBVSxFQUFFLEdBQUcsTUFBTXROLFNBQ3JETyxJQUFJLENBQUMsU0FDTGtJLE1BQU0sQ0FBRSw0R0FPUmMsRUFBRSxDQUFDLFFBQVEsYUFDWEosS0FBSyxDQUFDLGFBQWE7Z0JBQUVDLFdBQVc7WUFBSztZQUV4QyxJQUFJa0UsWUFBWTtnQkFDZDNNLFFBQVFELEtBQUssQ0FBQywrQ0FBK0M0TTtnQkFDN0QsTUFBTUE7WUFDUjtZQUVBLElBQUksQ0FBQ3NGLGdCQUFnQkEsYUFBYWpRLE1BQU0sS0FBSyxHQUFHO2dCQUM5Q2hDLFFBQVFlLEdBQUcsQ0FBQztnQkFDWixPQUFPLEVBQUU7WUFDWDtZQUVBZixRQUFRZSxHQUFHLENBQUMscUNBQXFDa1IsYUFBYWpRLE1BQU0sRUFBRWlRLGFBQWF6UCxHQUFHLENBQUMwUCxDQUFBQSxJQUFLQSxFQUFFdk0sU0FBUztZQUV2RywwRUFBMEU7WUFDMUUsTUFBTXdNLGNBQWNGLGFBQWF6UCxHQUFHLENBQUM0UCxDQUFBQSxNQUFPQSxJQUFJeFIsRUFBRTtZQUNsRCxJQUFJeVIsZ0JBQXVCLEVBQUU7WUFFN0IsSUFBSTtnQkFDRixNQUFNLEVBQUUzUyxJQUFJLEVBQUVLLE9BQU91UyxVQUFVLEVBQUUsR0FBRyxNQUFNalQsU0FDdkNPLElBQUksQ0FBQyxrQkFDTGtJLE1BQU0sQ0FBQyxLQUNQOEUsRUFBRSxDQUFDLFdBQVd1RjtnQkFFakIsSUFBSUcsWUFBWTtvQkFDZHRTLFFBQVFDLElBQUksQ0FBQyxzQ0FBc0NxUztnQkFDckQsT0FBTztvQkFDTEQsZ0JBQWdCM1MsUUFBUSxFQUFFO2dCQUM1QjtZQUNGLEVBQUUsT0FBT0ssT0FBTztnQkFDZEMsUUFBUUMsSUFBSSxDQUFDLDJDQUEyQ0Y7WUFDMUQ7WUFFQUMsUUFBUWUsR0FBRyxDQUFDLHlDQUF5Q3NSLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZXJRLE1BQU0sS0FBSTtZQUU5RSw0RUFBNEU7WUFDNUUsTUFBTXdNLFFBQVEsSUFBSTdOLE9BQU80RSxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEQsSUFBSTJRLGVBQXNCLEVBQUU7WUFFNUIsSUFBSTtnQkFDRixNQUFNLEVBQUU3UyxJQUFJLEVBQUVLLE9BQU9xTSxZQUFZLEVBQUUsR0FBRyxNQUFNL00sU0FDekNPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLDZDQUNQYSxHQUFHLENBQUMsY0FBYyxHQUFTLE9BQU42RixPQUFNLGNBQzNCZ0UsRUFBRSxDQUFDLGNBQWMsR0FBUyxPQUFOaEUsT0FBTTtnQkFFN0IsSUFBSXBDLGNBQWM7b0JBQ2hCcE0sUUFBUUMsSUFBSSxDQUFDLDBDQUEwQ21NO2dCQUN6RCxPQUFPO29CQUNMbUcsZUFBZTdTLFFBQVEsRUFBRTtnQkFDM0I7WUFDRixFQUFFLE9BQU9LLE9BQU87Z0JBQ2RDLFFBQVFDLElBQUksQ0FBQyxrREFBa0RGO1lBQ2pFO1lBRUFDLFFBQVFlLEdBQUcsQ0FBQyxvQ0FBb0N3UixhQUFhdlEsTUFBTTtZQUVuRSxtRUFBbUU7WUFDbkUsTUFBTXlRLFlBQVksSUFBSTlSO1lBQ3RCOFIsVUFBVUMsT0FBTyxDQUFDRCxVQUFVRSxPQUFPLEtBQUs7WUFDeEMsTUFBTUMsZUFBZUgsVUFBVWxOLFdBQVcsR0FBRzNELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMxRCxJQUFJaVIsbUJBQTBCLEVBQUU7WUFFaEMsSUFBSTtnQkFDRixNQUFNLEVBQUVuVCxJQUFJLEVBQUVLLE9BQU8rUyxjQUFjLEVBQUUsR0FBRyxNQUFNelQsU0FDM0NPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLHFCQUNQYSxHQUFHLENBQUMsY0FBYyxHQUFnQixPQUFiaUssY0FBYSxjQUNsQ0osRUFBRSxDQUFDLGNBQWMsR0FBZ0IsT0FBYkksY0FBYTtnQkFFcEMsSUFBSUUsZ0JBQWdCO29CQUNsQjlTLFFBQVFDLElBQUksQ0FBQyw2Q0FBNkM2UztnQkFDNUQsT0FBTztvQkFDTEQsbUJBQW1CblQsUUFBUSxFQUFFO2dCQUMvQjtZQUNGLEVBQUUsT0FBT0ssT0FBTztnQkFDZEMsUUFBUUMsSUFBSSxDQUFDLGtEQUFrREY7WUFDakU7WUFFQSxxRkFBcUY7WUFDckYsSUFBSWdULGtCQUF5QixFQUFFO1lBRS9CLElBQUk7Z0JBQ0YsTUFBTSxFQUFFclQsSUFBSSxFQUFFSyxPQUFPaVQsVUFBVSxFQUFFLEdBQUcsTUFBTTNULFNBQ3ZDTyxJQUFJLENBQUMsV0FDTGtJLE1BQU0sQ0FBQyxvQkFDUHVFLEdBQUcsQ0FBQyxZQUFZLE1BQU0sTUFDdEJPLEVBQUUsQ0FBQyxZQUFZdUY7Z0JBRWxCLElBQUlhLFlBQVk7b0JBQ2RoVCxRQUFRQyxJQUFJLENBQUMsNkNBQTZDK1M7Z0JBQzVELE9BQU87b0JBQ0xELGtCQUFrQnJULFFBQVEsRUFBRTtnQkFDOUI7WUFDRixFQUFFLE9BQU9LLE9BQU87Z0JBQ2RDLFFBQVFDLElBQUksQ0FBQyxrREFBa0RGO1lBQ2pFO1lBRUFDLFFBQVFlLEdBQUcsQ0FBQywrQ0FBK0NnUyxnQkFBZ0IvUSxNQUFNO1lBRWpGLHNEQUFzRDtZQUN0RCxNQUFNaVIsYUFBYVYsYUFBYTVCLE1BQU0sQ0FBQyxDQUFDWSxLQUEwQnpLO2dCQUNoRSxNQUFNb00sU0FBU3BNLE9BQU96QixTQUFTO2dCQUMvQixJQUFJLENBQUM2TixRQUFRLE9BQU8zQjtnQkFFcEIsSUFBSSxDQUFDQSxHQUFHLENBQUMyQixPQUFPLEVBQUU7b0JBQ2hCM0IsR0FBRyxDQUFDMkIsT0FBTyxHQUFHO3dCQUFFbE4sT0FBTzt3QkFBR21OLFFBQVE7d0JBQUdDLFVBQVU7d0JBQUdDLE1BQU07d0JBQUdDLE9BQU87b0JBQUU7Z0JBQ3RFO2dCQUVBL0IsR0FBRyxDQUFDMkIsT0FBTyxDQUFDbE4sS0FBSztnQkFDakIsSUFBSWMsT0FBT2xDLE1BQU0sS0FBSyxVQUFVMk0sR0FBRyxDQUFDMkIsT0FBTyxDQUFDQyxNQUFNO3FCQUM3QyxJQUFJck0sT0FBT2xDLE1BQU0sS0FBSyxZQUFZMk0sR0FBRyxDQUFDMkIsT0FBTyxDQUFDRSxRQUFRO3FCQUN0RCxJQUFJdE0sT0FBT2xDLE1BQU0sS0FBSyxRQUFRMk0sR0FBRyxDQUFDMkIsT0FBTyxDQUFDRyxJQUFJO3FCQUM5QzlCLEdBQUcsQ0FBQzJCLE9BQU8sQ0FBQ0ksS0FBSztnQkFFdEIsT0FBTy9CO1lBQ1QsR0FBRyxDQUFDO1lBRUosc0RBQXNEO1lBQ3RELE1BQU1nQyxpQkFBaUJWLGlCQUFpQmxDLE1BQU0sQ0FBQyxDQUFDWSxLQUE2QnpLO2dCQUMzRSxNQUFNb00sU0FBU3BNLE9BQU96QixTQUFTO2dCQUMvQixJQUFJNk4sUUFBUTtvQkFDVjNCLEdBQUcsQ0FBQzJCLE9BQU8sR0FBRyxDQUFDM0IsR0FBRyxDQUFDMkIsT0FBTyxJQUFJLEtBQUs7Z0JBQ3JDO2dCQUNBLE9BQU8zQjtZQUNULEdBQUcsQ0FBQztZQUVKLHlFQUF5RTtZQUN6RSxNQUFNaUMsb0JBQW9CVCxnQkFBZ0JwQyxNQUFNLENBQUMsQ0FBQ1ksS0FBMEJ6SztnQkFDMUUsTUFBTTJNLFVBQVUzTSxPQUFPdEIsUUFBUTtnQkFDL0IsSUFBSSxDQUFDaU8sU0FBUyxPQUFPbEM7Z0JBRXJCLElBQUksQ0FBQ0EsR0FBRyxDQUFDa0MsUUFBUSxFQUFFO29CQUNqQmxDLEdBQUcsQ0FBQ2tDLFFBQVEsR0FBRzt3QkFBRXpOLE9BQU87d0JBQUdtTixRQUFRO3dCQUFHQyxVQUFVO3dCQUFHQyxNQUFNO3dCQUFHSyxlQUFlO3dCQUFHQyxvQkFBb0I7d0JBQUdDLGNBQWM7d0JBQUcsTUFBTTtvQkFBRTtnQkFDaEk7Z0JBRUFyQyxHQUFHLENBQUNrQyxRQUFRLENBQUN6TixLQUFLO2dCQUVsQixPQUFRYyxPQUFPbEMsTUFBTTtvQkFDbkIsS0FBSzt3QkFDSDJNLEdBQUcsQ0FBQ2tDLFFBQVEsQ0FBQ04sTUFBTTt3QkFDbkI7b0JBQ0YsS0FBSzt3QkFDSDVCLEdBQUcsQ0FBQ2tDLFFBQVEsQ0FBQ0wsUUFBUTt3QkFDckI7b0JBQ0YsS0FBSzt3QkFDSDdCLEdBQUcsQ0FBQ2tDLFFBQVEsQ0FBQ0osSUFBSTt3QkFDakI7b0JBQ0YsS0FBSzt3QkFDSDlCLEdBQUcsQ0FBQ2tDLFFBQVEsQ0FBQ0MsYUFBYTt3QkFDMUI7b0JBQ0YsS0FBSzt3QkFDSG5DLEdBQUcsQ0FBQ2tDLFFBQVEsQ0FBQ0Usa0JBQWtCO3dCQUMvQjtvQkFDRixLQUFLO3dCQUNIcEMsR0FBRyxDQUFDa0MsUUFBUSxDQUFDRyxZQUFZO3dCQUN6QjtvQkFDRixLQUFLO3dCQUNIckMsR0FBRyxDQUFDa0MsUUFBUSxDQUFDLEtBQUs7d0JBQ2xCO2dCQUNKO2dCQUVBLE9BQU9sQztZQUNULEdBQUcsQ0FBQztZQUVKdlIsUUFBUWUsR0FBRyxDQUFDLHdDQUF3Q3lTO1lBRXBELCtDQUErQztZQUMvQyxNQUFNSyxXQUFXLElBQUlDO1lBQ3JCekIsY0FBY3BPLE9BQU8sQ0FBQzhQLENBQUFBO2dCQUNwQkYsU0FBU0csR0FBRyxDQUFDRCxLQUFLRSxPQUFPLEVBQUVGO1lBQzdCO1lBRUEsNEVBQTRFO1lBQzVFLE1BQU1HLGdCQUFpQ2pDLGFBQWF6UCxHQUFHLENBQUNxRyxDQUFBQTtnQkFDdEQsTUFBTXFLLFNBQVNySyxTQUFTakksRUFBRTtnQkFFMUIsMERBQTBEO2dCQUMxRCxNQUFNdVQsWUFBWU4sU0FBU08sR0FBRyxDQUFDbEIsV0FBVztvQkFDeEN0UyxJQUFJLFVBQVVzUztvQkFDZGUsU0FBU2Y7b0JBQ1RtQixjQUFjO29CQUNkQyxpQkFBaUI7b0JBQ2pCQyxnQkFBZ0I7b0JBQ2hCQyxrQkFBa0I7b0JBQ2xCQyxjQUFjO29CQUNkQyxtQkFBbUI7b0JBQ25CQyxpQkFBaUI7b0JBQ2pCQyxzQkFBc0I7b0JBQ3RCQyx1QkFBdUI7b0JBQ3ZCQyxZQUFZLElBQUluVSxPQUFPNEUsV0FBVztvQkFDbENzRixZQUFZLElBQUlsSyxPQUFPNEUsV0FBVztnQkFDcEM7Z0JBRUEsTUFBTXdQLGVBQWU5QixVQUFVLENBQUNDLE9BQU8sSUFBSTtvQkFBRWxOLE9BQU87b0JBQUdtTixRQUFRO29CQUFHQyxVQUFVO29CQUFHQyxNQUFNO2dCQUFFO2dCQUN2RixNQUFNMkIsbUJBQW1CekIsY0FBYyxDQUFDTCxPQUFPLElBQUk7Z0JBQ25ELE1BQU0rQixlQUFlekIsaUJBQWlCLENBQUNOLE9BQU8sSUFBSTtvQkFDaERsTixPQUFPO29CQUNQbU4sUUFBUTtvQkFDUkMsVUFBVTtvQkFDVkMsTUFBTTtvQkFDTkssZUFBZTtvQkFDZkMsb0JBQW9CO29CQUNwQkMsY0FBYztvQkFDZCxNQUFNO2dCQUNSO2dCQUVBLHlCQUF5QjtnQkFDekIsTUFBTXNCLG9CQUFvQnhPLEtBQUt5TyxHQUFHLENBQUMsR0FBR2hCLFVBQVVFLFlBQVksR0FBR1c7Z0JBQy9ELE1BQU1JLFVBQVVGLG9CQUFvQjtnQkFFcEMsMERBQTBEO2dCQUMxRCxNQUFNRyxhQUFhLGFBQWNoQyxJQUFJLEdBQUdjLFVBQVVHLGVBQWUsR0FBRyxNQUFPO2dCQUUzRXRVLFFBQVFlLEdBQUcsQ0FBQywwQkFBOENrVSxPQUE5QnBNLFNBQVNsRCxTQUFTLEVBQUMsYUFBeUNzUCxPQUE5QkEsYUFBYTlCLE1BQU0sRUFBQyxZQUF5QzhCLE9BQS9CQSxhQUFhN0IsUUFBUSxFQUFDLFdBQTJCLE9BQWxCNkIsYUFBYTVCLElBQUk7Z0JBRXhJLE9BQU87b0JBQ0wsR0FBR2MsU0FBUztvQkFDWixpQ0FBaUM7b0JBQ2pDOVQsTUFBTTt3QkFDSk8sSUFBSWlJLFNBQVNqSSxFQUFFO3dCQUNmK0UsV0FBV2tELFNBQVNsRCxTQUFTO3dCQUM3QlQsT0FBTzJELFNBQVMzRCxLQUFLO3dCQUNyQlcsWUFBWWdELFNBQVNoRCxVQUFVO3dCQUMvQmtCLE1BQU04QixTQUFTOUIsSUFBSTtvQkFDckI7b0JBQ0F1TyxnQkFBZ0JQLGFBQWEvTyxLQUFLO29CQUNsQ3VQLG9CQUFvQkw7b0JBQ3BCTSxzQkFBc0I7d0JBQ3BCckMsUUFBUTRCLGFBQWE1QixNQUFNO3dCQUMzQkMsVUFBVTJCLGFBQWEzQixRQUFRO3dCQUMvQkMsTUFBTTBCLGFBQWExQixJQUFJO3dCQUN2QkMsT0FBT3lCLGFBQWF6QixLQUFLO29CQUMzQjtvQkFDQSxnRUFBZ0U7b0JBQ2hFaUIsZ0JBQWdCVSxhQUFhOUIsTUFBTTtvQkFDbkNxQixrQkFBa0JTLGFBQWE3QixRQUFRO29CQUN2Q3FCLGNBQWNRLGFBQWE1QixJQUFJO29CQUMvQnFCLG1CQUFtQlc7b0JBQ25CVixpQkFBaUJTO2dCQUNuQjtZQUNGO1lBRUFwVixRQUFRZSxHQUFHLENBQUMscUVBQXFFbVQsY0FBY2xTLE1BQU07WUFDckdoQyxRQUFRZSxHQUFHLENBQUMseUJBQXlCbVQsY0FBYzFSLEdBQUcsQ0FBQ2lULENBQUFBO29CQUFLQTt3QkFBQUEsVUFBQUEsRUFBRXBWLElBQUksY0FBTm9WLDhCQUFBQSxRQUFROVAsU0FBUztlQUFFbEMsSUFBSSxDQUFDO1lBRXBGLE9BQU95UTtRQUVULEVBQUUsT0FBT25VLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q0E7WUFDMUQsMkRBQTJEO1lBQzNELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTTJWLGlCQUFnQmhOLElBQVk7UUFDaEMsTUFBTSxFQUFFaEosSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFdBQ0xrSSxNQUFNLENBQUMscUJBQ1BhLEdBQUcsQ0FBQyxjQUFjLEdBQVEsT0FBTEQsTUFBSyxjQUMxQjhKLEVBQUUsQ0FBQyxjQUFjLEdBQVEsT0FBTDlKLE1BQUs7UUFFNUIsSUFBSTNJLE9BQU8sTUFBTUE7UUFFakIsbUJBQW1CO1FBQ25CLE1BQU00VixrQkFBa0JqVyxLQUFLaVIsTUFBTSxDQUFDLENBQUNZLEtBQVV6SztZQUM3Q3lLLEdBQUcsQ0FBQ3pLLE9BQU9sQyxNQUFNLENBQUMsR0FBRyxDQUFDMk0sR0FBRyxDQUFDekssT0FBT2xDLE1BQU0sQ0FBQyxJQUFJLEtBQUs7WUFDakQsT0FBTzJNO1FBQ1QsR0FBRyxDQUFDO1FBRUosTUFBTXFFLGdCQUFnQmxXLEtBQUtpUixNQUFNLENBQUMsQ0FBQ1ksS0FBVXpLO1lBQzNDeUssR0FBRyxDQUFDekssT0FBT3pCLFNBQVMsQ0FBQyxHQUFHLENBQUNrTSxHQUFHLENBQUN6SyxPQUFPekIsU0FBUyxDQUFDLElBQUksS0FBSztZQUN2RCxPQUFPa007UUFDVCxHQUFHLENBQUM7UUFFSixPQUFPO1lBQ0xzRSxjQUFjblcsS0FBS3NDLE1BQU07WUFDekIyVDtZQUNBQztRQUNGO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTUUsa0JBQWlCQyxTQUFpQixFQUFFQyxPQUFlO1FBQ3ZELE1BQU0sRUFBRXRXLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLGlDQUNQYSxHQUFHLENBQUMsY0FBY29OLFdBQ2xCdkQsRUFBRSxDQUFDLGNBQWN3RDtRQUVwQixJQUFJalcsT0FBTyxNQUFNQTtRQUNqQixPQUFPTDtJQUNUO0lBRUEsMkZBQTJGO0lBQzNGLE1BQU11VyxxQkFBb0IvQyxNQUFjLEVBQUUzSSxPQUErQixFQUFFMkwsV0FBaUI7UUFDMUYsc0JBQXNCO1FBQ3RCLElBQUksQ0FBQztZQUFDO1lBQVc7WUFBbUI7WUFBa0I7WUFBUTtTQUFRLENBQUN6VyxRQUFRLENBQUN5VyxZQUFZblAsSUFBSSxHQUFHO1lBQ2pHLE1BQU0sSUFBSTVGLE1BQU07UUFDbEI7UUFFQSxNQUFNLEVBQUV6QixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsa0JBQ0xrTCxNQUFNLENBQUNQLFNBQ1AzQixFQUFFLENBQUMsV0FBV3NLLFFBQ2RwTCxNQUFNLEdBQ051QyxNQUFNO1FBRVQsSUFBSXRLLE9BQU8sTUFBTUE7UUFDakIsT0FBT0w7SUFDVDtJQUVBLHdHQUF3RztJQUN4RyxNQUFNeVcsMkJBQTBCakQsTUFBYyxFQUFFa0QsWUFBb0IsRUFBRUMsYUFBcUIsRUFBRUgsV0FBaUI7UUFDNUcsc0JBQXNCO1FBQ3RCLElBQUksQ0FBQztZQUFDO1lBQVc7WUFBbUI7WUFBa0I7WUFBUTtTQUFRLENBQUN6VyxRQUFRLENBQUN5VyxZQUFZblAsSUFBSSxHQUFHO1lBQ2pHLE1BQU0sSUFBSTVGLE1BQU07UUFDbEI7UUFFQSxJQUFJO1lBQ0ZuQixRQUFRZSxHQUFHLENBQUMsa0RBQTJEcVYsT0FBbkJsRCxRQUFPLGNBQW9DbUQsT0FBeEJELGNBQWEsYUFBeUIsT0FBZEM7WUFFL0YseURBQXlEO1lBQ3pELElBQUk7Z0JBQ0ZyVyxRQUFRZSxHQUFHLENBQUM7Z0JBRVosTUFBTXVWLGdCQUFnQjtvQkFDcEIxQixzQkFBc0J3QjtvQkFDdEJ2Qix1QkFBdUJ3QjtvQkFDdkJ4TCxZQUFZLElBQUlsSyxPQUFPNEUsV0FBVztnQkFDcEM7Z0JBRUEsTUFBTSxFQUFFN0YsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLGtCQUNMa0wsTUFBTSxDQUFDd0wsZUFDUDFOLEVBQUUsQ0FBQyxXQUFXc0ssUUFDZHBMLE1BQU0sQ0FBRSxtTUFVUnVDLE1BQU07Z0JBRVQsSUFBSSxDQUFDdEssU0FBU0wsTUFBTTtvQkFDbEJNLFFBQVFlLEdBQUcsQ0FBQztvQkFDWmYsUUFBUWUsR0FBRyxDQUFDLHlCQUF5Q3NWLE9BQTFCRCxjQUFhLGVBQTJCLE9BQWRDO29CQUNyRCxPQUFPM1c7Z0JBQ1QsT0FBTztvQkFDTE0sUUFBUUMsSUFBSSxDQUFDLCtCQUErQkY7b0JBQzVDLE1BQU1BO2dCQUNSO1lBRUYsRUFBRSxPQUFPd1csY0FBYztnQkFDckJ2VyxRQUFRQyxJQUFJLENBQUMscURBQXFEc1c7Z0JBRWxFLHlDQUF5QztnQkFDekMsSUFBSTtvQkFDRnZXLFFBQVFlLEdBQUcsQ0FBQztvQkFFWixNQUFNeVYsYUFBYTt3QkFDakJ2QyxTQUFTZjt3QkFDVG1CLGNBQWM7d0JBQ2RDLGlCQUFpQjt3QkFDakJDLGdCQUFnQjt3QkFDaEJDLGtCQUFrQjt3QkFDbEJDLGNBQWM7d0JBQ2RDLG1CQUFtQjt3QkFDbkJDLGlCQUFpQjt3QkFDakJDLHNCQUFzQndCO3dCQUN0QnZCLHVCQUF1QndCO3dCQUN2QnZCLFlBQVksSUFBSW5VLE9BQU80RSxXQUFXO3dCQUNsQ3NGLFlBQVksSUFBSWxLLE9BQU80RSxXQUFXO29CQUNwQztvQkFFQSxNQUFNLEVBQUU3RixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsa0JBQ0xzQixNQUFNLENBQUNzVixZQUFZO3dCQUNsQkMsWUFBWTt3QkFDWkMsa0JBQWtCO29CQUNwQixHQUNDNU8sTUFBTSxDQUFFLHFOQVVSdUMsTUFBTTtvQkFFVCxJQUFJLENBQUN0SyxTQUFTTCxNQUFNO3dCQUNsQk0sUUFBUWUsR0FBRyxDQUFDO3dCQUNaZixRQUFRZSxHQUFHLENBQUMseUJBQXlDc1YsT0FBMUJELGNBQWEsZUFBMkIsT0FBZEM7d0JBQ3JELE9BQU8zVztvQkFDVCxPQUFPO3dCQUNMTSxRQUFRQyxJQUFJLENBQUMsK0JBQStCRjt3QkFDNUMsTUFBTUE7b0JBQ1I7Z0JBRUYsRUFBRSxPQUFPNFcsY0FBYztvQkFDckIzVyxRQUFRQyxJQUFJLENBQUMsd0NBQXdDMFc7b0JBRXJELG1EQUFtRDtvQkFDbkQzVyxRQUFRZSxHQUFHLENBQUM7b0JBRVosT0FBTzt3QkFDTEgsSUFBSSxVQUFVc1M7d0JBQ2RlLFNBQVNmO3dCQUNUbUIsY0FBYzt3QkFDZEMsaUJBQWlCO3dCQUNqQkMsZ0JBQWdCO3dCQUNoQkMsa0JBQWtCO3dCQUNsQkMsY0FBYzt3QkFDZEMsbUJBQW1CO3dCQUNuQkMsaUJBQWlCO3dCQUNqQkMsc0JBQXNCd0I7d0JBQ3RCdkIsdUJBQXVCd0I7d0JBQ3ZCdkIsWUFBWSxJQUFJblUsT0FBTzRFLFdBQVc7d0JBQ2xDc0YsWUFBWSxJQUFJbEssT0FBTzRFLFdBQVc7d0JBQ2xDbEYsTUFBTTs0QkFDSk8sSUFBSXNTOzRCQUNKdk4sV0FBVzs0QkFDWFQsT0FBTzs0QkFDUFcsWUFBWTs0QkFDWmtCLE1BQU07d0JBQ1I7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBT2hILE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHVDQUF1Q0E7WUFDckQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsMENBQTBDO0lBQzFDLE1BQU02VyxxQkFBb0IxRCxNQUFjLEVBQUVnRCxXQUFpQjtRQUN6RCxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDO1lBQUM7WUFBVztZQUFtQjtZQUFrQjtZQUFRO1NBQVEsQ0FBQ3pXLFFBQVEsQ0FBQ3lXLFlBQVluUCxJQUFJLEdBQUc7WUFDakcsTUFBTSxJQUFJNUYsTUFBTTtRQUNsQjtRQUVBLE1BQU0sRUFBRXpCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxrQkFDTHdLLE1BQU0sQ0FBQztZQUFDO2dCQUNQNkosU0FBU2Y7Z0JBQ1RtQixjQUFjO2dCQUNkQyxpQkFBaUI7WUFDbkI7U0FBRSxFQUNEeE0sTUFBTSxHQUNOdUMsTUFBTTtRQUVULElBQUl0SyxPQUFPLE1BQU1BO1FBQ2pCLE9BQU9MO0lBQ1Q7SUFFQSxxRkFBcUY7SUFDckYsTUFBTW1YO1FBQ0osSUFBSTtZQUNGN1csUUFBUWUsR0FBRyxDQUFDO1lBRVosNEJBQTRCO1lBQzVCLE1BQU0sRUFBRW9ILE9BQU8yTyxVQUFVLEVBQUUvVyxPQUFPZ1gsVUFBVSxFQUFFLEdBQUcsTUFBTTFYLFNBQ3BETyxJQUFJLENBQUMsV0FDTGtJLE1BQU0sQ0FBQyxLQUFLO2dCQUFFSyxPQUFPO2dCQUFTNk8sTUFBTTtZQUFLO1lBRTVDLElBQUlELFlBQVk7Z0JBQ2QvVyxRQUFRRCxLQUFLLENBQUMsOENBQThDZ1g7Z0JBQzVELE1BQU1BO1lBQ1I7WUFFQSxtREFBbUQ7WUFDbkQsTUFBTSxFQUFFNU8sT0FBTzhPLGNBQWMsRUFBRWxYLE9BQU9tWCxjQUFjLEVBQUUsR0FBRyxNQUFNN1gsU0FDNURPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLEtBQUs7Z0JBQUVLLE9BQU87Z0JBQVM2TyxNQUFNO1lBQUssR0FDekMzSyxHQUFHLENBQUMsWUFBWSxNQUFNO1lBRXpCLElBQUk2SyxnQkFBZ0I7Z0JBQ2xCbFgsUUFBUUQsS0FBSyxDQUFDLDhDQUE4Q21YO2dCQUM1RCxNQUFNQTtZQUNSO1lBRUEsa0NBQWtDO1lBQ2xDLE1BQU1DLG9CQUFvQixDQUFDTCxjQUFjLEtBQU1HLENBQUFBLGtCQUFrQjtZQUVqRSwrQkFBK0I7WUFDL0IsTUFBTUcsd0JBQXdCTixhQUFhcFEsS0FBSzJRLEtBQUssQ0FBQyxDQUFDSixrQkFBa0IsS0FBS0gsYUFBYSxPQUFPO1lBRWxHLE1BQU01VSxTQUFTO2dCQUNib1YsV0FBV0wsa0JBQWtCO2dCQUM3Qk0sY0FBY0o7Z0JBQ2RuUixPQUFPOFEsY0FBYztnQkFDckJNO1lBQ0Y7WUFFQXBYLFFBQVFlLEdBQUcsQ0FBQyxxQ0FBcUNtQjtZQUNqRCxPQUFPQTtRQUVULEVBQUUsT0FBT25DLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1EQUFtREE7WUFDakUsTUFBTUE7UUFDUjtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELE1BQU15WCxzQkFBcUJ0QixXQUFpQjtRQUMxQyxvQ0FBb0M7UUFDcEMsSUFBSUEsWUFBWW5QLElBQUksS0FBSyxTQUFTO1lBQ2hDLE1BQU0sSUFBSTVGLE1BQU07UUFDbEI7UUFFQSxJQUFJO1lBQ0ZuQixRQUFRZSxHQUFHLENBQUM7WUFFWiw0REFBNEQ7WUFDNUQsTUFBTSxFQUFFb0gsT0FBT3NQLFdBQVcsRUFBRTFYLE9BQU8yWCxXQUFXLEVBQUUsR0FBRyxNQUFNclksU0FDdERPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLEtBQUs7Z0JBQUVLLE9BQU87Z0JBQVM2TyxNQUFNO1lBQUssR0FDekMzSyxHQUFHLENBQUMsWUFBWSxNQUFNO1lBRXpCLElBQUlxTCxhQUFhO2dCQUNmMVgsUUFBUUQsS0FBSyxDQUFDLGdEQUFnRDJYO2dCQUM5RCxNQUFNQTtZQUNSO1lBRUEsMkNBQTJDO1lBQzNDLE1BQU0sRUFBRWhZLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxXQUNMa0wsTUFBTSxDQUFDO2dCQUFFdEYsVUFBVTtZQUFLLEdBQ3hCNkcsR0FBRyxDQUFDLFlBQVksTUFBTSxNQUFNLGtDQUFrQzthQUM5RHZFLE1BQU0sQ0FBQztZQUVWLElBQUkvSCxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsbUNBQW1DQTtnQkFDakQsTUFBTUE7WUFDUjtZQUVBLE1BQU00WCxhQUFhalksQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNc0MsTUFBTSxLQUFJO1lBRW5DLCtCQUErQjtZQUMvQixJQUFJO2dCQUNGLE1BQU1xSixnQkFBZ0JDLFNBQVMsQ0FBQztvQkFDOUJDLFdBQVc7b0JBQ1hDLFlBQVkwSyxZQUFZdFYsRUFBRTtvQkFDMUI2SyxhQUFhO29CQUNiQyxlQUFlO29CQUNmQyxXQUFXO29CQUNYQyxXQUFXO2dCQUNiO1lBQ0YsRUFBRSxPQUFPQyxVQUFVO2dCQUNqQjdMLFFBQVFELEtBQUssQ0FBQyxxQ0FBcUM4TDtZQUNuRCxrREFBa0Q7WUFDcEQ7WUFFQTdMLFFBQVFlLEdBQUcsQ0FBQyxpQ0FBNEMsT0FBWDRXLFlBQVc7WUFFeEQsT0FBTztnQkFDTHZSLFNBQVN1UjtnQkFDVHZXLFNBQVMseUNBQW9ELE9BQVh1VyxZQUFXO1lBQy9EO1FBRUYsRUFBRSxPQUFPNVgsT0FBWTtZQUNuQkMsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q0E7WUFDMUQsTUFBTUE7UUFDUjtJQUNGO0lBRUEseUVBQXlFO0lBQ3pFLE1BQU02WCwwQkFBeUJ2WCxJQUFVO1FBQ3ZDLElBQUk7WUFDRkwsUUFBUWUsR0FBRyxDQUFDO1lBRVosc0JBQXNCO1lBQ3RCLElBQUksQ0FBQ1YsUUFBUSxDQUFDO2dCQUFDO2dCQUFXO2dCQUFtQjtnQkFBa0I7Z0JBQVE7YUFBUSxDQUFDWixRQUFRLENBQUNZLEtBQUswRyxJQUFJLEdBQUc7Z0JBQ25HL0csUUFBUUMsSUFBSSxDQUFDO2dCQUNiLE9BQU8sRUFBRTtZQUNYO1lBRUEsNkRBQTZEO1lBQzdELElBQUlnUyxlQUFlLEVBQUU7WUFDckIsSUFBSTtnQkFDRixNQUFNLEVBQUV2UyxNQUFNbVksU0FBUyxFQUFFOVgsT0FBTzRNLFVBQVUsRUFBRSxHQUFHLE1BQU10TixTQUNsRE8sSUFBSSxDQUFDLFNBQ0xrSSxNQUFNLENBQUUsd0hBT1JjLEVBQUUsQ0FBQyxRQUFRLGFBQ1hKLEtBQUssQ0FBQyxhQUFhO29CQUFFQyxXQUFXO2dCQUFLO2dCQUV4QyxJQUFJa0UsWUFBWTtvQkFDZDNNLFFBQVFELEtBQUssQ0FBQywrQ0FBK0M0TTtvQkFDN0QsT0FBTyxFQUFFO2dCQUNYO2dCQUVBc0YsZUFBZTRGLGFBQWEsRUFBRTtnQkFDOUI3WCxRQUFRZSxHQUFHLENBQUMsMkNBQWtELE9BQXBCa1IsYUFBYWpRLE1BQU07Z0JBRTdELElBQUlpUSxhQUFhalEsTUFBTSxLQUFLLEdBQUc7b0JBQzdCaEMsUUFBUWUsR0FBRyxDQUFDO29CQUNaLE9BQU8sRUFBRTtnQkFDWDtZQUNGLEVBQUUsT0FBT2hCLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NBO2dCQUNoRCxPQUFPLEVBQUU7WUFDWDtZQUVBLCtEQUErRDtZQUMvRCxJQUFJK1gsZ0JBQWdCLEVBQUU7WUFDdEIsSUFBSTtnQkFDRixNQUFNM0YsY0FBY0YsYUFBYXpQLEdBQUcsQ0FBQzRQLENBQUFBLE1BQU9BLElBQUl4UixFQUFFO2dCQUNsRFosUUFBUWUsR0FBRyxDQUFDLDZDQUE2RW9SLE9BQTFDQSxZQUFZdlAsS0FBSyxDQUFDLEdBQUcsR0FBR2EsSUFBSSxDQUFDLE9BQU0sU0FBMEIsT0FBbkIwTyxZQUFZblEsTUFBTSxFQUFDO2dCQUU1RyxNQUFNLEVBQUV0QyxNQUFNcVksS0FBSyxFQUFFaFksT0FBT3VTLFVBQVUsRUFBRSxHQUFHLE1BQU1qVCxTQUM5Q08sSUFBSSxDQUFDLHVCQUNMa0ksTUFBTSxDQUFDLEtBQ1BjLEVBQUUsQ0FBQyxlQUFlLFdBQ2xCZ0UsRUFBRSxDQUFDLFdBQVd1RixhQUNkM0osS0FBSyxDQUFDLGNBQWM7b0JBQUVDLFdBQVc7Z0JBQU07Z0JBRTFDLElBQUk2SixZQUFZO3dCQUl3QkEscUJBQXVDQTtvQkFIN0V0UyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDdVM7b0JBRXpELGtFQUFrRTtvQkFDbEUsSUFBSUEsV0FBV3ZILElBQUksS0FBSyxnQkFBY3VILHNCQUFBQSxXQUFXbFIsT0FBTyxjQUFsQmtSLDBDQUFBQSxvQkFBb0I3UyxRQUFRLENBQUMsYUFBVTZTLHVCQUFBQSxXQUFXbFIsT0FBTyxjQUFsQmtSLDJDQUFBQSxxQkFBb0I3UyxRQUFRLENBQUMsZ0JBQWU7d0JBQ3ZITyxRQUFRQyxJQUFJLENBQUM7d0JBQ2I2WCxnQkFBZ0IsRUFBRTtvQkFDcEIsT0FBTzt3QkFDTDlYLFFBQVFELEtBQUssQ0FBQzt3QkFDZCxPQUFPLEVBQUU7b0JBQ1g7Z0JBQ0YsT0FBTztvQkFDTCtYLGdCQUFnQkMsU0FBUyxFQUFFO29CQUMzQi9YLFFBQVFlLEdBQUcsQ0FBQyxtREFBMkQsT0FBckIrVyxjQUFjOVYsTUFBTTtnQkFDeEU7WUFDRixFQUFFLE9BQU9qQyxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtnQkFDM0QrWCxnQkFBZ0IsRUFBRTtZQUNwQjtZQUVBLG1FQUFtRTtZQUNuRSxNQUFNRSxpQkFBaUIsSUFBSWxFO1lBQzNCLElBQUlnRSxpQkFBaUJBLGNBQWM5VixNQUFNLEdBQUcsR0FBRztnQkFDN0M4VixjQUFjN1QsT0FBTyxDQUFDOFAsQ0FBQUE7b0JBQ3BCLE1BQU1iLFNBQVNhLEtBQUtFLE9BQU87b0JBQzNCLElBQUksQ0FBQytELGVBQWVDLEdBQUcsQ0FBQy9FLFNBQVM7d0JBQy9COEUsZUFBZWhFLEdBQUcsQ0FBQ2QsUUFBUWE7b0JBQzdCO2dCQUNGO2dCQUNBL1QsUUFBUWUsR0FBRyxDQUFDLDBDQUFvRCxPQUFwQmlYLGVBQWVFLElBQUksRUFBQztZQUNsRSxPQUFPO2dCQUNMbFksUUFBUWUsR0FBRyxDQUFDO1lBQ2Q7WUFFQSwrREFBK0Q7WUFDL0QsTUFBTW1CLFNBQWtDK1AsYUFBYXpQLEdBQUcsQ0FBQ3FHLENBQUFBO2dCQUN2RCxNQUFNcUssU0FBU3JLLFNBQVNqSSxFQUFFO2dCQUMxQixNQUFNdVgsZUFBZUgsZUFBZTVELEdBQUcsQ0FBQ2xCO2dCQUV4QyxJQUFJaUYsY0FBYztvQkFDaEIsNENBQTRDO29CQUM1QyxPQUFPO3dCQUNMLEdBQUdBLFlBQVk7d0JBQ2Y5WCxNQUFNOzRCQUNKTyxJQUFJaUksU0FBU2pJLEVBQUU7NEJBQ2YrRSxXQUFXa0QsU0FBU2xELFNBQVM7NEJBQzdCVCxPQUFPMkQsU0FBUzNELEtBQUs7NEJBQ3JCVyxZQUFZZ0QsU0FBU2hELFVBQVU7NEJBQy9Ca0IsTUFBTThCLFNBQVM5QixJQUFJO3dCQUNyQjtvQkFDRjtnQkFDRixPQUFPO29CQUNMLHdDQUF3QztvQkFDeEMsTUFBTXFSLGNBQWMsSUFBSXpYO29CQUN4QixNQUFNMFgsZUFBZUQsWUFBWUUsUUFBUSxLQUFLO29CQUM5QyxNQUFNQyxjQUFjSCxZQUFZSSxXQUFXO29CQUMzQyxNQUFNQyxhQUFhLEdBQWtCSixPQUFmRSxhQUFZLEtBQTRDLE9BQXpDRixhQUFhSyxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQUs7b0JBQzlFLE1BQU1DLFdBQVcsSUFBSWpZLEtBQUs0WCxhQUFhRixjQUFjLEdBQUc5UyxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBRW5GLE9BQU87d0JBQ0xoQixJQUFJLFVBQVVzUzt3QkFDZGUsU0FBU2Y7d0JBQ1QyRixhQUFhO3dCQUNiQyxjQUFjTDt3QkFDZE0sWUFBWUg7d0JBQ1pJLG9CQUFvQjt3QkFDcEJDLHVCQUF1Qjt3QkFDdkJDLHVCQUF1QixNQUFNO3dCQUM3QkMsdUJBQXVCO3dCQUN2QkMsa0JBQWtCO3dCQUNsQkMsMEJBQTBCO3dCQUMxQkMsYUFBYTt3QkFDYkMsYUFBYTt3QkFDYmxaLE1BQU07NEJBQ0pPLElBQUlpSSxTQUFTakksRUFBRTs0QkFDZitFLFdBQVdrRCxTQUFTbEQsU0FBUzs0QkFDN0JULE9BQU8yRCxTQUFTM0QsS0FBSzs0QkFDckJXLFlBQVlnRCxTQUFTaEQsVUFBVTs0QkFDL0JrQixNQUFNOEIsU0FBUzlCLElBQUk7d0JBQ3JCO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQS9HLFFBQVFlLEdBQUcsQ0FBQyx1RUFBa0YsT0FBZG1CLE9BQU9GLE1BQU07WUFDN0ZoQyxRQUFRZSxHQUFHLENBQUMsc0NBQXVFLE9BQTlDbUIsT0FBT00sR0FBRyxDQUFDaVQsQ0FBQUE7b0JBQUtBO3dCQUFBQSxVQUFBQSxFQUFFcFYsSUFBSSxjQUFOb1YsOEJBQUFBLFFBQVE5UCxTQUFTO2VBQUVsQyxJQUFJLENBQUM7WUFFN0UsaUNBQWlDO1lBQ2pDLE1BQU0rVixXQUFXdFgsT0FBT0wsTUFBTSxDQUFDNFgsQ0FBQUEsSUFBS0EsRUFBRVQsa0JBQWtCLEdBQUcsR0FBR2hYLE1BQU07WUFDcEUsTUFBTTBYLGNBQWN4WCxPQUFPRixNQUFNLEdBQUd3WDtZQUNwQ3haLFFBQVFlLEdBQUcsQ0FBQyxxQ0FBb0QyWSxPQUF6QkYsVUFBUyxrQkFBNEIsT0FBWkU7WUFFaEUsT0FBT3hYO1FBRVQsRUFBRSxPQUFPbkMsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtZQUV6RCw0REFBNEQ7WUFDNURDLFFBQVFlLEdBQUcsQ0FBQztZQUNaLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTTRZLGdCQUFldFosSUFBVTtRQUM3QixJQUFJO1lBQ0ZMLFFBQVFlLEdBQUcsQ0FBQztZQUVaLGlDQUFpQztZQUNqQyxNQUFNaVYsVUFBVSxJQUFJclY7WUFDcEIsTUFBTW9WLFlBQVksSUFBSXBWO1lBQ3RCb1YsVUFBVXJELE9BQU8sQ0FBQ3NELFFBQVFyRCxPQUFPLEtBQUssR0FBRyxvQ0FBb0M7O1lBRTdFLE1BQU0sRUFBRWpULElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLDhEQUNQYSxHQUFHLENBQUMsY0FBY29OLFVBQVV4USxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFDdkRnWSxHQUFHLENBQUMsY0FBYzVELFFBQVF6USxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxhQUN4RGdMLEVBQUUsQ0FBQyxVQUFVO2dCQUFDO2dCQUFVO2dCQUFRO2FBQVcsRUFDM0NwRSxLQUFLLENBQUMsY0FBYztnQkFBRUMsV0FBVztZQUFLO1lBRXpDLElBQUkxSSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsNENBQTRDQTtnQkFDMUQsTUFBTUE7WUFDUjtZQUVBQyxRQUFRZSxHQUFHLENBQUMsYUFBK0IsT0FBbEJyQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQyxNQUFNLEtBQUksR0FBRTtZQUUzQyxnREFBZ0Q7WUFDaEQsSUFBSTZYLGVBQWVuYSxRQUFRLEVBQUU7WUFDN0IsSUFBSVcsS0FBSzBHLElBQUksS0FBSyxhQUFhO2dCQUM3QjhTLGVBQWVBLGFBQWFoWSxNQUFNLENBQUNpRixDQUFBQSxTQUNqQ0EsT0FBT3RCLFFBQVEsS0FBS25GLEtBQUtPLEVBQUUsSUFDM0JrRyxPQUFPdEIsUUFBUSxLQUFLLFFBQ3BCc0IsT0FBT3pCLFNBQVMsS0FBS2hGLEtBQUtPLEVBQUU7WUFFaEM7WUFFQSwrQkFBK0I7WUFDL0IsTUFBTWtaLFdBQVc7Z0JBQUM7Z0JBQU87Z0JBQU87Z0JBQU07Z0JBQU07Z0JBQU87Z0JBQU07YUFBTTtZQUMvRCxNQUFNQyxTQUE2RSxDQUFDO1lBRXBGLDZCQUE2QjtZQUM3QixJQUFLLElBQUkxWCxJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBSztnQkFDM0IsTUFBTXFHLE9BQU8sSUFBSS9IO2dCQUNqQitILEtBQUtnSyxPQUFPLENBQUNoSyxLQUFLaUssT0FBTyxLQUFLdFE7Z0JBQzlCLE1BQU0yWCxVQUFVRixRQUFRLENBQUNwUixLQUFLdVIsTUFBTSxHQUFHO2dCQUN2Q0YsTUFBTSxDQUFDQyxRQUFRLEdBQUc7b0JBQUU3RyxRQUFRO29CQUFHRSxNQUFNO29CQUFHRCxVQUFVO2dCQUFFO1lBQ3REO1lBRUEseUJBQXlCO1lBQ3pCeUcsYUFBYTVWLE9BQU8sQ0FBQzZDLENBQUFBO2dCQUNuQixNQUFNNEIsT0FBTyxJQUFJL0gsS0FBS21HLE9BQU8rRCxVQUFVO2dCQUN2QyxNQUFNbVAsVUFBVUYsUUFBUSxDQUFDcFIsS0FBS3VSLE1BQU0sR0FBRztnQkFFdkMsSUFBSUYsTUFBTSxDQUFDQyxRQUFRLEVBQUU7b0JBQ25CLElBQUlsVCxPQUFPbEMsTUFBTSxLQUFLLFVBQVVtVixNQUFNLENBQUNDLFFBQVEsQ0FBQzdHLE1BQU07eUJBQ2pELElBQUlyTSxPQUFPbEMsTUFBTSxLQUFLLFFBQVFtVixNQUFNLENBQUNDLFFBQVEsQ0FBQzNHLElBQUk7eUJBQ2xELElBQUl2TSxPQUFPbEMsTUFBTSxLQUFLLFlBQVltVixNQUFNLENBQUNDLFFBQVEsQ0FBQzVHLFFBQVE7Z0JBQ2pFO1lBQ0Y7WUFFQSxrRUFBa0U7WUFDbEUsTUFBTWxSLFNBQVMsRUFBRTtZQUNqQixJQUFLLElBQUlHLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUMzQixNQUFNcUcsT0FBTyxJQUFJL0g7Z0JBQ2pCK0gsS0FBS2dLLE9BQU8sQ0FBQ2hLLEtBQUtpSyxPQUFPLEtBQUt0UTtnQkFDOUIsTUFBTTJYLFVBQVVGLFFBQVEsQ0FBQ3BSLEtBQUt1UixNQUFNLEdBQUc7Z0JBQ3ZDL1gsT0FBT0ssSUFBSSxDQUFDO29CQUNWMlgsS0FBS0Y7b0JBQ0w3RyxRQUFRNEcsTUFBTSxDQUFDQyxRQUFRLENBQUM3RyxNQUFNO29CQUM5QkUsTUFBTTBHLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDM0csSUFBSTtvQkFDMUJELFVBQVUyRyxNQUFNLENBQUNDLFFBQVEsQ0FBQzVHLFFBQVE7Z0JBQ3BDO1lBQ0Y7WUFFQXBULFFBQVFlLEdBQUcsQ0FBQyxzQ0FBc0NtQjtZQUNsRCxPQUFPQTtRQUVULEVBQUUsT0FBT25DLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q0E7WUFDMUQseURBQXlEO1lBQ3pELE1BQU0rWixXQUFXO2dCQUFDO2dCQUFPO2dCQUFPO2dCQUFNO2dCQUFNO2dCQUFPO2dCQUFNO2FBQU07WUFDL0QsTUFBTTVYLFNBQVMsRUFBRTtZQUNqQixJQUFLLElBQUlHLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUMzQixNQUFNcUcsT0FBTyxJQUFJL0g7Z0JBQ2pCK0gsS0FBS2dLLE9BQU8sQ0FBQ2hLLEtBQUtpSyxPQUFPLEtBQUt0UTtnQkFDOUIsTUFBTTJYLFVBQVVGLFFBQVEsQ0FBQ3BSLEtBQUt1UixNQUFNLEdBQUc7Z0JBQ3ZDL1gsT0FBT0ssSUFBSSxDQUFDO29CQUNWMlgsS0FBS0Y7b0JBQ0w3RyxRQUFRO29CQUNSRSxNQUFNO29CQUNORCxVQUFVO2dCQUNaO1lBQ0Y7WUFDQSxPQUFPbFI7UUFDVDtJQUNGO0lBRUEsNkRBQTZEO0lBQzdELE1BQU1pWSxxQkFBb0I5WixJQUFVO1FBQ2xDLElBQUk7WUFDRkwsUUFBUWUsR0FBRyxDQUFDO1lBRVosaUNBQWlDO1lBQ2pDLE1BQU0sRUFBRXJCLE1BQU1tWSxTQUFTLEVBQUU5WCxPQUFPcWEsY0FBYyxFQUFFLEdBQUcsTUFBTS9hLFNBQ3RETyxJQUFJLENBQUMsU0FDTGtJLE1BQU0sQ0FBQyxNQUNQYyxFQUFFLENBQUMsUUFBUTtZQUVkLElBQUl3UixnQkFBZ0I7Z0JBQ2xCcGEsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ3FhO2dCQUNoRCxNQUFNQTtZQUNSO1lBRUEsTUFBTWpJLGNBQWMsQ0FBQzBGLGFBQWEsRUFBRSxFQUFFclYsR0FBRyxDQUFDNFAsQ0FBQUEsTUFBT0EsSUFBSXhSLEVBQUU7WUFDdkRaLFFBQVFlLEdBQUcsQ0FBQywyQkFBb0MsT0FBbkJvUixZQUFZblEsTUFBTSxFQUFDO1lBRWhELElBQUltUSxZQUFZblEsTUFBTSxLQUFLLEdBQUc7Z0JBQzVCLE9BQU87b0JBQUVxWSxpQkFBaUI7b0JBQUdDLHNCQUFzQjtnQkFBRTtZQUN2RDtZQUVBLDhFQUE4RTtZQUM5RSxNQUFNLEVBQUU1YSxNQUFNNmEsY0FBYyxFQUFFeGEsT0FBT3lhLGNBQWMsRUFBRSxHQUFHLE1BQU1uYixTQUMzRE8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFDLDZCQUNQYyxFQUFFLENBQUMsaUJBQWlCLG9CQUNwQmdFLEVBQUUsQ0FBQyxjQUFjdUY7WUFFcEIsSUFBSXFJLGdCQUFnQjtnQkFDbEJ4YSxRQUFRRCxLQUFLLENBQUMsd0NBQXdDeWE7Z0JBQ3RELE1BQU1BO1lBQ1I7WUFFQSxNQUFNSCxrQkFBa0JFLENBQUFBLDJCQUFBQSxxQ0FBQUEsZUFBZ0J2WSxNQUFNLEtBQUk7WUFFbEQseUNBQXlDO1lBQ3pDLE1BQU13TSxRQUFRLElBQUk3TixPQUFPNEUsV0FBVyxHQUFHM0QsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYTs7WUFDbEUsTUFBTSxFQUFFbEMsTUFBTSthLGdCQUFnQixFQUFFMWEsT0FBTzJhLGdCQUFnQixFQUFFLEdBQUcsTUFBTXJiLFNBQy9ETyxJQUFJLENBQUMsaUJBQ0xrSSxNQUFNLENBQUMsNkJBQ1BjLEVBQUUsQ0FBQyxpQkFBaUIsb0JBQ3BCZ0UsRUFBRSxDQUFDLGNBQWN1RixhQUNqQnhKLEdBQUcsQ0FBQyxhQUFhLEdBQVMsT0FBTjZGLE9BQU0sY0FDMUJnRSxFQUFFLENBQUMsYUFBYSxHQUFTLE9BQU5oRSxPQUFNO1lBRTVCLElBQUlrTSxrQkFBa0I7Z0JBQ3BCMWEsUUFBUUQsS0FBSyxDQUFDLHFEQUFxRDJhO2dCQUNuRSxNQUFNQTtZQUNSO1lBRUEsTUFBTUosdUJBQXVCRyxDQUFBQSw2QkFBQUEsdUNBQUFBLGlCQUFrQnpZLE1BQU0sS0FBSTtZQUV6RGhDLFFBQVFlLEdBQUcsQ0FBQywyQ0FBb0V1WixPQUF6QkQsaUJBQWdCLFdBQThCLE9BQXJCQztZQUVoRixPQUFPO2dCQUNMRDtnQkFDQUM7WUFDRjtRQUVGLEVBQUUsT0FBT3ZhLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtEQUFrREE7WUFDaEUsNENBQTRDO1lBQzVDLE9BQU87Z0JBQUVzYSxpQkFBaUI7Z0JBQUdDLHNCQUFzQjtZQUFFO1FBQ3ZEO0lBQ0Y7SUFFQSw0REFBNEQ7SUFDNUQsTUFBTUssMEJBQXlCdGEsSUFBVTtRQUN2QyxJQUFJO1lBQ0ZMLFFBQVFlLEdBQUcsQ0FBQztZQUVaLGlDQUFpQztZQUNqQyxNQUFNLEVBQUVyQixNQUFNbVksU0FBUyxFQUFFOVgsT0FBT3FhLGNBQWMsRUFBRSxHQUFHLE1BQU0vYSxTQUN0RE8sSUFBSSxDQUFDLFNBQ0xrSSxNQUFNLENBQUMsTUFDUGMsRUFBRSxDQUFDLFFBQVE7WUFFZCxJQUFJd1IsZ0JBQWdCO2dCQUNsQnBhLFFBQVFELEtBQUssQ0FBQyxrQ0FBa0NxYTtnQkFDaEQsTUFBTUE7WUFDUjtZQUVBLE1BQU1qSSxjQUFjLENBQUMwRixhQUFhLEVBQUUsRUFBRXJWLEdBQUcsQ0FBQzRQLENBQUFBLE1BQU9BLElBQUl4UixFQUFFO1lBQ3ZEWixRQUFRZSxHQUFHLENBQUMsMkJBQW9DLE9BQW5Cb1IsWUFBWW5RLE1BQU0sRUFBQztZQUVoRCxJQUFJbVEsWUFBWW5RLE1BQU0sS0FBSyxHQUFHO2dCQUM1Qix1Q0FBdUM7Z0JBQ3ZDLE1BQU04WCxXQUFXO29CQUFDO29CQUFPO29CQUFPO29CQUFNO29CQUFNO29CQUFPO29CQUFNO2lCQUFNO2dCQUMvRCxNQUFNNVgsU0FBUyxFQUFFO2dCQUNqQixJQUFLLElBQUlHLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFLO29CQUMzQixNQUFNcUcsT0FBTyxJQUFJL0g7b0JBQ2pCK0gsS0FBS2dLLE9BQU8sQ0FBQ2hLLEtBQUtpSyxPQUFPLEtBQUt0UTtvQkFDOUIsTUFBTTJYLFVBQVVGLFFBQVEsQ0FBQ3BSLEtBQUt1UixNQUFNLEdBQUc7b0JBQ3ZDL1gsT0FBT0ssSUFBSSxDQUFDO3dCQUNWMlgsS0FBS0Y7d0JBQ0xZLFVBQVU7d0JBQ1ZDLFdBQVc7d0JBQ1hDLFNBQVM7b0JBQ1g7Z0JBQ0Y7Z0JBQ0EsT0FBTzVZO1lBQ1Q7WUFFQSxpQ0FBaUM7WUFDakMsTUFBTThULFVBQVUsSUFBSXJWO1lBQ3BCLE1BQU1vVixZQUFZLElBQUlwVjtZQUN0Qm9WLFVBQVVyRCxPQUFPLENBQUNzRCxRQUFRckQsT0FBTyxLQUFLLEdBQUcsb0NBQW9DOztZQUU3RSxvRUFBb0U7WUFDcEUsTUFBTSxFQUFFalQsTUFBTXFiLFdBQVcsRUFBRWhiLE9BQU9pYixVQUFVLEVBQUUsR0FBRyxNQUFNM2IsU0FDcERPLElBQUksQ0FBQyxpQkFDTGtJLE1BQU0sQ0FBQyx5QkFDUGMsRUFBRSxDQUFDLGlCQUFpQixvQkFDcEJnRSxFQUFFLENBQUMsY0FBY3VGLGFBQ2pCeEosR0FBRyxDQUFDLGFBQWFvTixVQUFVeFEsV0FBVyxHQUFHM0QsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQ3REZ1ksR0FBRyxDQUFDLGFBQWE1RCxRQUFRelEsV0FBVyxHQUFHM0QsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUc7WUFFMUQsSUFBSW9aLFlBQVk7Z0JBQ2RoYixRQUFRRCxLQUFLLENBQUMsd0NBQXdDaWI7Z0JBQ3RELE1BQU1BO1lBQ1I7WUFFQSx5RUFBeUU7WUFDekUsTUFBTSxFQUFFdGIsTUFBTXViLGFBQWEsRUFBRWxiLE9BQU9tYixZQUFZLEVBQUUsR0FBRyxNQUFNN2IsU0FDeERPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLGlDQUNQOEUsRUFBRSxDQUFDLGFBQWF1RixhQUNoQnhKLEdBQUcsQ0FBQyxjQUFjb04sVUFBVXhRLFdBQVcsR0FBRzNELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUN2RGdZLEdBQUcsQ0FBQyxjQUFjNUQsUUFBUXpRLFdBQVcsR0FBRzNELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLGFBQ3hENEcsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBSztZQUV6QyxJQUFJeVMsY0FBYztnQkFDaEJsYixRQUFRRCxLQUFLLENBQUMscUNBQXFDbWI7Z0JBQ25ELE1BQU1BO1lBQ1I7WUFFQWxiLFFBQVFlLEdBQUcsQ0FBQyxhQUE2RGthLE9BQWhERixDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWEvWSxNQUFNLEtBQUksR0FBRSx5QkFBa0QsT0FBM0JpWixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVqWixNQUFNLEtBQUksR0FBRTtZQUVwRywrQkFBK0I7WUFDL0IsTUFBTThYLFdBQVc7Z0JBQUM7Z0JBQU87Z0JBQU87Z0JBQU07Z0JBQU07Z0JBQU87Z0JBQU07YUFBTTtZQUMvRCxNQUFNcUIsYUFBbUYsQ0FBQztZQUUxRiw2QkFBNkI7WUFDN0IsSUFBSyxJQUFJOVksSUFBSSxHQUFHQSxLQUFLLEdBQUdBLElBQUs7Z0JBQzNCLE1BQU1xRyxPQUFPLElBQUkvSDtnQkFDakIrSCxLQUFLZ0ssT0FBTyxDQUFDaEssS0FBS2lLLE9BQU8sS0FBS3RRO2dCQUM5QixNQUFNMlgsVUFBVUYsUUFBUSxDQUFDcFIsS0FBS3VSLE1BQU0sR0FBRztnQkFDdkNrQixVQUFVLENBQUNuQixRQUFRLEdBQUc7b0JBQUVZLFVBQVU7b0JBQUdFLFNBQVM7b0JBQUdNLE9BQU87Z0JBQUU7WUFDNUQ7WUFFTyx3Q0FBd0M7WUFDOUMsSUFBSUwsZUFBZXRSLE1BQU1DLE9BQU8sQ0FBQ3FSLGNBQWM7Z0JBQzdDQSxZQUFZOVcsT0FBTyxDQUFDLENBQUNvWDtvQkFDbkIsTUFBTTNTLE9BQU8sSUFBSS9ILEtBQUswYSxNQUFNN0osU0FBUztvQkFDckMsTUFBTXdJLFVBQVVGLFFBQVEsQ0FBQ3BSLEtBQUt1UixNQUFNLEdBQUc7b0JBQ3ZDLElBQUlrQixVQUFVLENBQUNuQixRQUFRLEVBQUU7d0JBQ3ZCbUIsVUFBVSxDQUFDbkIsUUFBUSxDQUFDWSxRQUFRO29CQUM5QjtnQkFDRjtZQUNGO1lBRUEsb0NBQW9DO1lBQ3BDLElBQUlLLGlCQUFpQnhSLE1BQU1DLE9BQU8sQ0FBQ3VSLGdCQUFnQjtnQkFDakRBLGNBQWNoWCxPQUFPLENBQUMsQ0FBQ3FYO29CQUNyQixNQUFNNVMsT0FBTyxJQUFJL0gsS0FBSzJhLE9BQU96USxVQUFVO29CQUN2QyxNQUFNbVAsVUFBVUYsUUFBUSxDQUFDcFIsS0FBS3VSLE1BQU0sR0FBRztvQkFDdkMsSUFBSWtCLFVBQVUsQ0FBQ25CLFFBQVEsRUFBRTt3QkFDdkJtQixVQUFVLENBQUNuQixRQUFRLENBQUNjLE9BQU87d0JBQzNCLElBQUlRLE9BQU8xVyxNQUFNLEtBQUssUUFBUTs0QkFDNUJ1VyxVQUFVLENBQUNuQixRQUFRLENBQUNvQixLQUFLO3dCQUMzQjtvQkFDRjtnQkFDRjtZQUNGO1lBRUQsa0VBQWtFO1lBQ2xFLE1BQU1sWixTQUFTLEVBQUU7WUFDakIsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBSztnQkFDM0IsTUFBTXFHLE9BQU8sSUFBSS9IO2dCQUNqQitILEtBQUtnSyxPQUFPLENBQUNoSyxLQUFLaUssT0FBTyxLQUFLdFE7Z0JBQzlCLE1BQU0yWCxVQUFVRixRQUFRLENBQUNwUixLQUFLdVIsTUFBTSxHQUFHO2dCQUN2QyxNQUFNc0IsVUFBVUosVUFBVSxDQUFDbkIsUUFBUTtnQkFFbkMsZ0VBQWdFO2dCQUNoRSxNQUFNYSxZQUFZVSxRQUFRVCxPQUFPLEdBQUcsSUFBSXBVLEtBQUsyUSxLQUFLLENBQUMsUUFBUytELEtBQUssR0FBR0csUUFBUVQsT0FBTyxHQUFJLE9BQU87Z0JBRTlGNVksT0FBT0ssSUFBSSxDQUFDO29CQUNWMlgsS0FBS0Y7b0JBQ0xZLFVBQVVXLFFBQVFYLFFBQVE7b0JBQzFCQyxXQUFXQTtvQkFDWEMsU0FBU1MsUUFBUVQsT0FBTztnQkFDMUI7WUFDRjtZQUVBOWEsUUFBUWUsR0FBRyxDQUFDLDZDQUE2Q21CO1lBQ3pELE9BQU9BO1FBRVQsRUFBRSxPQUFPbkMsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaURBQWlEQTtZQUMvRCx5REFBeUQ7WUFDekQsTUFBTStaLFdBQVc7Z0JBQUM7Z0JBQU87Z0JBQU87Z0JBQU07Z0JBQU07Z0JBQU87Z0JBQU07YUFBTTtZQUMvRCxNQUFNNVgsU0FBUyxFQUFFO1lBQ2pCLElBQUssSUFBSUcsSUFBSSxHQUFHQSxLQUFLLEdBQUdBLElBQUs7Z0JBQzNCLE1BQU1xRyxPQUFPLElBQUkvSDtnQkFDakIrSCxLQUFLZ0ssT0FBTyxDQUFDaEssS0FBS2lLLE9BQU8sS0FBS3RRO2dCQUM5QixNQUFNMlgsVUFBVUYsUUFBUSxDQUFDcFIsS0FBS3VSLE1BQU0sR0FBRztnQkFDdkMvWCxPQUFPSyxJQUFJLENBQUM7b0JBQ1YyWCxLQUFLRjtvQkFDTFksVUFBVTtvQkFDVkMsV0FBVztvQkFDWEMsU0FBUztnQkFDWDtZQUNGO1lBQ0EsT0FBTzVZO1FBQ1Q7SUFDRjtJQUVBLDBDQUEwQztJQUMxQyxNQUFNc1osb0JBQW1CbmIsSUFBVTtRQVNqQyxJQUFJO1lBQ0ZMLFFBQVFlLEdBQUcsQ0FBQyxrREFBa0RWLEtBQUtPLEVBQUUsRUFBRVAsS0FBSzBHLElBQUk7WUFFaEYsc0NBQXNDO1lBQ3RDLElBQUkxRyxLQUFLMEcsSUFBSSxLQUFLLGFBQWE7Z0JBQzdCL0csUUFBUUQsS0FBSyxDQUFDLDJCQUEyQk0sS0FBSzBHLElBQUk7Z0JBQ2xELE1BQU0sSUFBSTVGLE1BQU07WUFDbEI7WUFFQW5CLFFBQVFlLEdBQUcsQ0FBQztZQUVaLE1BQU1xWCxjQUFjLElBQUl6WDtZQUN4QixNQUFNMFgsZUFBZUQsWUFBWTdTLFdBQVcsR0FBRzNDLEtBQUssQ0FBQyxHQUFHLEdBQUcsVUFBVTs7WUFFckUscURBQXFEO1lBQ3JELE1BQU02WSxlQUFlLElBQUk5YSxLQUFLeVgsWUFBWUksV0FBVyxJQUFJSixZQUFZRSxRQUFRLElBQUk7WUFDakYsTUFBTW9ELGFBQWEsSUFBSS9hLEtBQUt5WCxZQUFZSSxXQUFXLElBQUlKLFlBQVlFLFFBQVEsS0FBSyxHQUFHLEdBQUcsSUFBSSxJQUFJO1lBRTlGLG1FQUFtRTtZQUNuRSxNQUFNLEVBQUU1WSxNQUFNcWIsV0FBVyxFQUFFaGIsT0FBT2liLFVBQVUsRUFBRSxHQUFHLE1BQU0zYixTQUNwRE8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFDLGlCQUNQYyxFQUFFLENBQUMsY0FBY3ZJLEtBQUtPLEVBQUUsRUFDeEJnSSxFQUFFLENBQUMsaUJBQWlCLG9CQUNwQkQsR0FBRyxDQUFDLGFBQWE4UyxhQUFhbFcsV0FBVyxJQUN6Q3FVLEdBQUcsQ0FBQyxhQUFhOEIsV0FBV25XLFdBQVc7WUFFMUMsSUFBSXlWLFlBQVk7Z0JBQ2RoYixRQUFRRCxLQUFLLENBQUMsd0NBQXdDaWI7Z0JBQ3RELE1BQU1BO1lBQ1I7WUFFQSxNQUFNVyxzQkFBc0JaLENBQUFBLHdCQUFBQSxrQ0FBQUEsWUFBYS9ZLE1BQU0sS0FBSTtZQUNuRGhDLFFBQVFlLEdBQUcsQ0FBQywyQkFBcUMsT0FBcEI0YSxxQkFBb0I7WUFFakQsaURBQWlEO1lBQ2pEM2IsUUFBUWUsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFckIsTUFBTWtjLFNBQVMsRUFBRTdiLE9BQU9xTSxZQUFZLEVBQUUsR0FBRyxNQUFNL00sU0FDcERPLElBQUksQ0FBQyxXQUNMa0ksTUFBTSxDQUFDLG1EQUNQYyxFQUFFLENBQUMsWUFBWXZJLEtBQUtPLEVBQUU7WUFFekIsSUFBSXdMLGNBQWM7Z0JBQ2hCcE0sUUFBUUQsS0FBSyxDQUFDLCtCQUErQnFNO2dCQUM3QyxNQUFNQTtZQUNSO1lBRUEsTUFBTTlDLFVBQVVzUyxhQUFhLEVBQUU7WUFDL0IsTUFBTS9GLGVBQWV2TSxRQUFRdEgsTUFBTTtZQUNuQ2hDLFFBQVFlLEdBQUcsQ0FBQyw2QkFBZ0MsT0FBYjhVLGNBQWE7WUFFNUMsOEJBQThCO1lBQzlCN1YsUUFBUWUsR0FBRyxDQUFDO1lBQ1osTUFBTThhLFlBQVksSUFBSS9IO1lBQ3RCeEssUUFBUXJGLE9BQU8sQ0FBQzZDLENBQUFBO2dCQUNkLE1BQU1sQyxTQUFTa0MsT0FBT2xDLE1BQU07Z0JBQzVCaVgsVUFBVTdILEdBQUcsQ0FBQ3BQLFFBQVEsQ0FBQ2lYLFVBQVV6SCxHQUFHLENBQUN4UCxXQUFXLEtBQUs7WUFDdkQ7WUFDQTVFLFFBQVFlLEdBQUcsQ0FBQyx3QkFBd0IrYSxPQUFPQyxXQUFXLENBQUNGO1lBRXZELDBCQUEwQjtZQUMxQixNQUFNRyxlQUF1QztnQkFDM0M3SSxRQUFRO2dCQUNSRSxNQUFNO2dCQUNORCxVQUFVO2dCQUNWTSxlQUFlO2dCQUNmQyxvQkFBb0I7Z0JBQ3BCQyxjQUFjO2dCQUNkLE1BQU07WUFDUjtZQUVBLE1BQU1xSSxjQUFjeFMsTUFBTTdKLElBQUksQ0FBQ2ljLFVBQVVLLE9BQU8sSUFBSTFaLEdBQUcsQ0FBQztvQkFBQyxDQUFDb0MsUUFBUXVELE1BQU07dUJBQU07b0JBQzVFdkQ7b0JBQ0F1RDtvQkFDQXFILE9BQU93TSxZQUFZLENBQUNwWCxPQUFPLElBQUk7Z0JBQ2pDOztZQUVBLDhDQUE4QztZQUM5QzVFLFFBQVFlLEdBQUcsQ0FBQztZQUNaLElBQUlvYixrQkFBa0IsRUFBRSxRQUFROztZQUVoQyxJQUFJO2dCQUNGLE1BQU0sRUFBRXpjLE1BQU1rVyxhQUFhLEVBQUU3VixPQUFPdVMsVUFBVSxFQUFFLEdBQUcsTUFBTWpULFNBQ3RETyxJQUFJLENBQUMsa0JBQ0xrSSxNQUFNLENBQUMscUJBQ1BjLEVBQUUsQ0FBQyxXQUFXdkksS0FBS08sRUFBRSxFQUNyQnlKLE1BQU07Z0JBRVQsSUFBSWlJLFlBQVk7b0JBQ2R0UyxRQUFRQyxJQUFJLENBQUMseURBQXlEcVM7b0JBQ3RFNkosa0JBQWtCO2dCQUNwQixPQUFPO29CQUNMLHlEQUF5RDtvQkFDekRBLGtCQUFrQnZHLGNBQWNsQixpQkFBaUIsSUFBSTtvQkFDckQxVSxRQUFRZSxHQUFHLENBQUMseUNBQStDLE9BQWhCb2IsaUJBQWdCO2dCQUM3RDtZQUNGLEVBQUUsT0FBT3BjLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxnREFBZ0RBO2dCQUM5RG9jLGtCQUFrQjtZQUNwQjtZQUVBLHNFQUFzRTtZQUN0RW5jLFFBQVFlLEdBQUcsQ0FBQztZQUNaZixRQUFRZSxHQUFHLENBQUMsNEJBQWtEMmEsT0FBaENELGFBQWFsVyxXQUFXLElBQUcsT0FBOEIsT0FBekJtVyxXQUFXblcsV0FBVztZQUNwRixNQUFNLEVBQUU3RixNQUFNMGMsVUFBVSxFQUFFcmMsT0FBT3NjLGVBQWUsRUFBRSxHQUFHLE1BQU1oZCxTQUN4RE8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFDLGFBQ1BjLEVBQUUsQ0FBQyxjQUFjdkksS0FBS08sRUFBRSxFQUN4QitILEdBQUcsQ0FBQyxhQUFhOFMsYUFBYWxXLFdBQVcsSUFDekNxVSxHQUFHLENBQUMsYUFBYThCLFdBQVduVyxXQUFXLElBQ3ZDaUQsS0FBSyxDQUFDLGFBQWE7Z0JBQUVDLFdBQVc7WUFBSztZQUV4QyxJQUFJNFQsaUJBQWlCO2dCQUNuQnJjLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNzYztnQkFDL0MsTUFBTUE7WUFDUjtZQUVBcmMsUUFBUWUsR0FBRyxDQUFDLGdCQUF3QyxPQUF4QnFiLENBQUFBLHVCQUFBQSxpQ0FBQUEsV0FBWXBhLE1BQU0sS0FBSSxHQUFFO1lBRXBELHNEQUFzRDtZQUN0RGhDLFFBQVFlLEdBQUcsQ0FBQztZQUNaLE1BQU11YixrQkFBa0IsSUFBSXhJO1lBRTVCLElBQUlzSSxjQUFjQSxXQUFXcGEsTUFBTSxHQUFHLEdBQUc7Z0JBQ3ZDb2EsV0FBV25ZLE9BQU8sQ0FBQ3NZLENBQUFBO29CQUNqQixNQUFNN1QsT0FBTyxJQUFJL0gsS0FBSzRiLFNBQVMvSyxTQUFTO29CQUN4QyxNQUFNMEksTUFBTXhSLEtBQUtuRCxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhOztvQkFDMUQsTUFBTTRhLE9BQU85VCxLQUFLK1QsUUFBUTtvQkFFMUIsSUFBSSxDQUFDSCxnQkFBZ0JyRSxHQUFHLENBQUNpQyxNQUFNO3dCQUM3Qm9DLGdCQUFnQnRJLEdBQUcsQ0FBQ2tHLEtBQUssSUFBSTFOO29CQUMvQjtvQkFDQThQLGdCQUFnQmxJLEdBQUcsQ0FBQzhGLEtBQU13QyxHQUFHLENBQUNGO2dCQUNoQztZQUNGO1lBRUEsb0NBQW9DO1lBQ3BDLE1BQU1HLHdCQUF3QmxULE1BQU03SixJQUFJLENBQUMwYyxnQkFBZ0JKLE9BQU8sSUFDN0QxWixHQUFHLENBQUM7b0JBQUMsQ0FBQzBYLEtBQUtsSyxNQUFNO3VCQUFNO29CQUN0QmtLLEtBQUssSUFBSXZaLEtBQUt1WixLQUFLMEMsa0JBQWtCLENBQUMsU0FBUzt3QkFBRUMsU0FBUzt3QkFBUzNDLEtBQUs7b0JBQVU7b0JBQ2xGbEssT0FBT0EsTUFBTWtJLElBQUk7b0JBQ2pCNEUsVUFBVSxJQUFJbmMsS0FBS3VaLEtBQUssMkJBQTJCO2dCQUNyRDtlQUNDcEwsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUUrTixRQUFRLENBQUNDLE9BQU8sS0FBSy9OLEVBQUU4TixRQUFRLENBQUNDLE9BQU8sSUFDeER2YSxHQUFHLENBQUM7b0JBQUMsRUFBRTBYLEdBQUcsRUFBRWxLLEtBQUssRUFBRTt1QkFBTTtvQkFBRWtLO29CQUFLbEs7Z0JBQU07ZUFBSSx5Q0FBeUM7O1lBRXRGLE1BQU1nTixvQkFBb0J2VCxNQUFNN0osSUFBSSxDQUFDMGMsZ0JBQWdCVyxNQUFNLElBQ3hEdE0sTUFBTSxDQUFDLENBQUNDLEtBQUtaLFFBQVVZLE1BQU1aLE1BQU1rSSxJQUFJLEVBQUU7WUFFNUMsTUFBTWdGLG1CQUFtQlosZ0JBQWdCcEUsSUFBSTtZQUU3Q2xZLFFBQVFlLEdBQUcsQ0FBQyx1Q0FBdUM7Z0JBQ2pENGE7Z0JBQ0E5RjtnQkFDQXNHO2dCQUNBYTtnQkFDQUU7WUFDRjtZQUVBLE9BQU87Z0JBQ0x2QjtnQkFDQU07Z0JBQ0FwRztnQkFDQXNHO2dCQUNBUTtnQkFDQUs7Z0JBQ0FFO1lBQ0Y7UUFFRixFQUFFLE9BQU9uZCxPQUFPO2dCQWlCVCxnQkFDQTtZQWpCTEMsUUFBUUQsS0FBSyxDQUFDLDJDQUEyQ0E7WUFFekQsbUNBQW1DO1lBQ25DLElBQUlBLFNBQVMsT0FBT0EsVUFBVSxVQUFVO2dCQUN0Q0MsUUFBUUQsS0FBSyxDQUFDLHVCQUF1QjtvQkFDbkNxQixTQUFTLE1BQWVBLE9BQU87b0JBQy9CMkosTUFBTSxNQUFlQSxJQUFJO29CQUN6QkMsU0FBUyxNQUFlQSxPQUFPO29CQUMvQkMsTUFBTSxNQUFlQSxJQUFJO29CQUN6QmtTLE9BQU8sTUFBZUEsS0FBSztnQkFDN0I7WUFDRjtZQUVBLDJFQUEyRTtZQUMzRSxJQUFJcGQsU0FBUyxPQUFPQSxVQUFVLFlBQ3pCLE9BQWVnTCxJQUFJLEtBQUssZ0JBQ3hCLHVCQUFlM0osT0FBTyxjQUF0QixvREFBd0IzQixRQUFRLENBQUMsYUFDakMsd0JBQWUyQixPQUFPLGNBQXRCLHNEQUF3QjNCLFFBQVEsQ0FBQyxjQUFZLEdBQUk7Z0JBQ3BETyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2IsT0FBTztvQkFDTDBiLHFCQUFxQjtvQkFDckJNLGFBQWEsRUFBRTtvQkFDZnBHLGNBQWM7b0JBQ2RzRyxpQkFBaUI7b0JBQ2pCUSx1QkFBdUIsRUFBRTtvQkFDekJLLG1CQUFtQjtvQkFDbkJFLGtCQUFrQjtnQkFDcEI7WUFDRjtZQUVBLE1BQU1uZDtRQUNSO0lBQ0Y7SUFFQSxvREFBb0Q7SUFDcEQsTUFBTXFkLGtCQUFpQi9jLElBQVUsRUFBRXFJLElBQVksRUFBRXNILEtBQWE7UUFDNUQsSUFBSTtZQUNGaFEsUUFBUWUsR0FBRyxDQUFDLCtCQUFrRDJILE9BQW5Cc0gsT0FBTSxlQUFrQixPQUFMdEg7WUFFOUQsc0NBQXNDO1lBQ3RDLElBQUlySSxLQUFLMEcsSUFBSSxLQUFLLGFBQWE7Z0JBQzdCLE1BQU0sSUFBSTVGLE1BQU07WUFDbEI7WUFFQSxxRkFBcUY7WUFDckZuQixRQUFRZSxHQUFHLENBQUMsMkNBQXNDLE9BQUwySCxNQUFLO1lBQ2xELE1BQU0yVSxZQUFZM1UsS0FBSzlHLEtBQUssQ0FBQyxLQUFLLHVDQUF1Qzs7WUFDekU1QixRQUFRZSxHQUFHLENBQUUsbUNBQXdCc2M7WUFFckMsTUFBTUMsT0FBT0MsU0FBU0YsU0FBUyxDQUFDLEVBQUU7WUFDbEMsTUFBTUcsUUFBUUQsU0FBU0YsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLDJDQUEyQzs7WUFDcEYsTUFBTW5ELE1BQU1xRCxTQUFTRixTQUFTLENBQUMsRUFBRTtZQUVqQ3JkLFFBQVFlLEdBQUcsQ0FBQywrQ0FBb0R5YyxPQUFmRixNQUFLLFlBQW9DcEQsT0FBMUJzRCxPQUFNLHNCQUF3QixPQUFKdEQ7WUFFMUYsTUFBTXVELFVBQVUsSUFBSTljLEtBQUsyYyxNQUFNRSxPQUFPdEQ7WUFDdEMsTUFBTXdELFlBQVlELFFBQVF4RCxNQUFNO1lBRWhDamEsUUFBUWUsR0FBRyxDQUFDLDRDQUF3RCxPQUF0QjBjLFFBQVFsWSxXQUFXO1lBQ2pFdkYsUUFBUWUsR0FBRyxDQUFDLDZDQUE0SSxPQUF6RzBjLFFBQVFiLGtCQUFrQixDQUFDLFNBQVM7Z0JBQUVDLFNBQVM7Z0JBQVFTLE1BQU07Z0JBQVdFLE9BQU87Z0JBQVF0RCxLQUFLO1lBQVU7WUFDckpsYSxRQUFRZSxHQUFHLENBQUMsNkNBQXdEMmMsT0FBckJoVixNQUFLLGtCQUE4QixPQUFkZ1YsV0FBVSxNQUFnRyxPQUE1RjtnQkFBQztnQkFBYTtnQkFBZ0I7Z0JBQVU7Z0JBQVM7Z0JBQVk7Z0JBQVU7YUFBUyxDQUFDQSxVQUFVLEVBQUM7WUFFOUssSUFBSUEsY0FBYyxLQUFLQSxjQUFjLEdBQUc7Z0JBQ3RDMWQsUUFBUUQsS0FBSyxDQUFDLG1FQUE4RSxPQUFkMmQsV0FBVSxNQUFnRyxPQUE1RjtvQkFBQztvQkFBYTtvQkFBZ0I7b0JBQVU7b0JBQVM7b0JBQVk7b0JBQVU7aUJBQVMsQ0FBQ0EsVUFBVSxFQUFDO2dCQUN4TCxNQUFNLElBQUl2YyxNQUFNO1lBQ2xCO1lBRUFuQixRQUFRZSxHQUFHLENBQUMsaUNBQTZILE9BQTVGO2dCQUFDO2dCQUFhO2dCQUFnQjtnQkFBVTtnQkFBUztnQkFBWTtnQkFBVTthQUFTLENBQUMyYyxVQUFVO1lBRXhJLDBCQUEwQjtZQUMxQixJQUFJMU4sUUFBUSxLQUFLQSxRQUFRLElBQUk7Z0JBQzNCLE1BQU0sSUFBSTdPLE1BQU07WUFDbEI7WUFFQSwyREFBMkQ7WUFDM0QsTUFBTSxFQUFFcEIsS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDckJPLElBQUksQ0FBQyxpQkFDTHNCLE1BQU0sQ0FBQztnQkFDTitTLFNBQVM1VCxLQUFLTyxFQUFFO2dCQUNoQitjLFdBQVdqVjtnQkFDWGtWLGNBQWM1TjtnQkFDZG5GLFlBQVksSUFBSWxLLE9BQU80RSxXQUFXO1lBQ3BDLEdBQUc7Z0JBQ0RrUixZQUFZO1lBQ2Q7WUFFRixJQUFJMVcsT0FBTztnQkFDVEMsUUFBUUQsS0FBSyxDQUFDLDRDQUE0Q0E7Z0JBRTFELDBEQUEwRDtnQkFDMURDLFFBQVFDLElBQUksQ0FBQztnQkFDYixNQUFNNGQsYUFBYSxpQkFBeUIsT0FBUnhkLEtBQUtPLEVBQUU7Z0JBQzNDLE1BQU1rZCxlQUFlN00sS0FBSzhNLEtBQUssQ0FBQ0MsYUFBYUMsT0FBTyxDQUFDSixlQUFlO2dCQUNwRUMsWUFBWSxDQUFDcFYsS0FBSyxHQUFHc0g7Z0JBQ3JCZ08sYUFBYUUsT0FBTyxDQUFDTCxZQUFZNU0sS0FBS0MsU0FBUyxDQUFDNE07Z0JBQ2hEOWQsUUFBUWUsR0FBRyxDQUFDLGNBQWlDMkgsT0FBbkJzSCxPQUFNLGVBQWtCLE9BQUx0SCxNQUFLO2dCQUNsRDtZQUNGO1lBRUExSSxRQUFRZSxHQUFHLENBQUMsY0FBaUMySCxPQUFuQnNILE9BQU0sZUFBa0IsT0FBTHRILE1BQUs7UUFDcEQsRUFBRSxPQUFPM0ksT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtZQUU1QyxtQ0FBbUM7WUFDbkMsSUFBSTtnQkFDRkMsUUFBUUMsSUFBSSxDQUFDO2dCQUNiLE1BQU00ZCxhQUFhLGlCQUF5QixPQUFSeGQsS0FBS08sRUFBRTtnQkFDM0MsTUFBTWtkLGVBQWU3TSxLQUFLOE0sS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUNKLGVBQWU7Z0JBQ3BFQyxZQUFZLENBQUNwVixLQUFLLEdBQUdzSDtnQkFDckJnTyxhQUFhRSxPQUFPLENBQUNMLFlBQVk1TSxLQUFLQyxTQUFTLENBQUM0TTtnQkFDaEQ5ZCxRQUFRZSxHQUFHLENBQUMsY0FBaUMySCxPQUFuQnNILE9BQU0sZUFBa0IsT0FBTHRILE1BQUs7WUFDcEQsRUFBRSxPQUFPeVYsY0FBYztnQkFDckJuZSxRQUFRRCxLQUFLLENBQUMsa0RBQWtEb2U7Z0JBQ2hFLE1BQU1wZTtZQUNSO1FBQ0Y7SUFDRjtJQUVBLE1BQU1xZSx5QkFBd0IvZCxJQUFVLEVBQUVpZCxJQUFZLEVBQUVFLEtBQWE7UUFDbkUsSUFBSTtZQUNGeGQsUUFBUWUsR0FBRyxDQUFDLGlDQUF5Q3ljLE9BQVJGLE1BQUssS0FBUyxPQUFORTtZQUVyRCxzQ0FBc0M7WUFDdEMsSUFBSW5kLEtBQUswRyxJQUFJLEtBQUssYUFBYTtnQkFDN0IsTUFBTSxJQUFJNUYsTUFBTTtZQUNsQjtZQUVBLHNFQUFzRTtZQUN0RSxNQUFNNFUsWUFBWSxHQUFXeUgsT0FBUkYsTUFBSyxLQUFxQyxPQUFsQ0UsTUFBTTlFLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBSztZQUMvRCxNQUFNM0MsVUFBVSxHQUFXd0gsT0FBUkYsTUFBSyxLQUF3QyxPQUFyQ0UsTUFBTTlFLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUFrRSxPQUEvRCxJQUFJaFksS0FBSzJjLE1BQU1FLE9BQU8sR0FBRzdLLE9BQU8sR0FBRytGLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUc7WUFFMUgzWSxRQUFRZSxHQUFHLENBQUMsK0NBQW9EaVYsT0FBZkQsV0FBVSxPQUFhLE9BQVJDO1lBRWhFLHFFQUFxRTtZQUNyRSxNQUFNLEVBQUV0VyxJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsaUJBQ0xrSSxNQUFNLENBQUMsMkJBQ1BjLEVBQUUsQ0FBQyxXQUFXdkksS0FBS08sRUFBRSxFQUNyQitILEdBQUcsQ0FBQyxhQUFhb04sV0FDakI2RCxHQUFHLENBQUMsYUFBYTVEO1lBRXBCLElBQUlqVyxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsMENBQTBDQTtnQkFDeERDLFFBQVFDLElBQUksQ0FBQztnQkFFYiwwREFBMEQ7Z0JBQzFELE1BQU00ZCxhQUFhLGlCQUF5QixPQUFSeGQsS0FBS08sRUFBRTtnQkFDM0MsTUFBTXlkLGFBQWFwTixLQUFLOE0sS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUNKLGVBQWU7Z0JBRWxFLDBDQUEwQztnQkFDMUMsTUFBTVMsV0FBbUMsQ0FBQztnQkFDMUN4QyxPQUFPSSxPQUFPLENBQUNtQyxZQUFZcGEsT0FBTyxDQUFDO3dCQUFDLENBQUN5RSxNQUFNc0gsTUFBTTtvQkFDL0MseURBQXlEO29CQUN6RCxJQUFJdEgsUUFBUXFOLGFBQWFyTixRQUFRc04sU0FBUzt3QkFDeENzSSxRQUFRLENBQUM1VixLQUFLLEdBQUdzSDtvQkFDbkI7Z0JBQ0Y7Z0JBRUFoUSxRQUFRZSxHQUFHLENBQUMsdURBQW9GLE9BQTdCK2EsT0FBT3lDLElBQUksQ0FBQ0QsVUFBVXRjLE1BQU0sRUFBQztnQkFDaEcsT0FBT3NjO1lBQ1Q7WUFFQSxvQ0FBb0M7WUFDcEMsTUFBTUEsV0FBbUMsQ0FBQztZQUMxQyxJQUFJNWUsTUFBTTtnQkFDUkEsS0FBS3VFLE9BQU8sQ0FBQ3VhLENBQUFBO29CQUNYRixRQUFRLENBQUNFLE1BQU1iLFNBQVMsQ0FBQyxHQUFHYSxNQUFNWixZQUFZO2dCQUNoRDtZQUNGO1lBRUE1ZCxRQUFRZSxHQUFHLENBQUMsc0RBQXdFLE9BQWxCckIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNc0MsTUFBTSxLQUFJLEdBQUU7WUFDcEYsT0FBT3NjO1FBQ1QsRUFBRSxPQUFPdmUsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtZQUVuRCxtQ0FBbUM7WUFDbkMsSUFBSTtnQkFDRkMsUUFBUUMsSUFBSSxDQUFDO2dCQUNiLE1BQU00ZCxhQUFhLGlCQUF5QixPQUFSeGQsS0FBS08sRUFBRTtnQkFDM0MsTUFBTXlkLGFBQWFwTixLQUFLOE0sS0FBSyxDQUFDQyxhQUFhQyxPQUFPLENBQUNKLGVBQWU7Z0JBRWxFLDBDQUEwQztnQkFDMUMsTUFBTVksZUFBZSxHQUFXakIsT0FBUkYsTUFBSyxLQUFxQyxPQUFsQ0UsTUFBTTlFLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBSztnQkFDbEUsTUFBTStGLGFBQWEsR0FBV2xCLE9BQVJGLE1BQUssS0FBd0MsT0FBckNFLE1BQU05RSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHLE1BQUssS0FBa0UsT0FBL0QsSUFBSWhZLEtBQUsyYyxNQUFNRSxPQUFPLEdBQUc3SyxPQUFPLEdBQUcrRixRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO2dCQUM3SCxNQUFNMkYsV0FBbUMsQ0FBQztnQkFFMUN4QyxPQUFPSSxPQUFPLENBQUNtQyxZQUFZcGEsT0FBTyxDQUFDO3dCQUFDLENBQUN5RSxNQUFNc0gsTUFBTTtvQkFDL0MseURBQXlEO29CQUN6RCxJQUFJdEgsUUFBUStWLGdCQUFnQi9WLFFBQVFnVyxZQUFZO3dCQUM5Q0osUUFBUSxDQUFDNVYsS0FBSyxHQUFHc0g7b0JBQ25CO2dCQUNGO2dCQUVBaFEsUUFBUWUsR0FBRyxDQUFDLGdFQUE2RixPQUE3QithLE9BQU95QyxJQUFJLENBQUNELFVBQVV0YyxNQUFNLEVBQUM7Z0JBQ3pHLE9BQU9zYztZQUNULEVBQUUsT0FBT0gsY0FBYztnQkFDckJuZSxRQUFRRCxLQUFLLENBQUMsZ0RBQWdEb2U7Z0JBQzlELE9BQU8sQ0FBQztZQUNWO1FBQ0Y7SUFDRjtJQUVBLHVEQUF1RDtJQUV2RCw0REFBNEQ7SUFDNUQsTUFBTVEsK0JBQThCckIsSUFBWSxFQUFFRSxLQUFhO1FBQzdELElBQUk7WUFDRnhkLFFBQVFlLEdBQUcsQ0FBQyx5REFBb0R5YyxPQUFSRixNQUFLLEtBQVMsT0FBTkUsT0FBTTtZQUV0RSxNQUFNLEVBQUU5ZCxJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVN1ZixHQUFHLENBQUMsb0NBQW9DO2dCQUM3RUMsYUFBYXZCO2dCQUNid0IsY0FBY3RCO1lBQ2hCO1lBRUEsSUFBSXpkLE9BQU87Z0JBQ1RDLFFBQVFELEtBQUssQ0FBQyw2Q0FBNkNBO2dCQUMzRCxNQUFNQTtZQUNSO1lBRUFDLFFBQVFlLEdBQUcsQ0FBQyx1Q0FBc0QsT0FBbEJyQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQyxNQUFNLEtBQUksR0FBRTtZQUNsRSxPQUFPdEM7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJDQUEyQ0E7WUFDekQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsb0VBQW9FO0lBQ3BFLE1BQU1nZixnQkFBZXpCLElBQVksRUFBRUUsS0FBYTtRQUM5QyxJQUFJO1lBQ0YsTUFBTSxFQUFFOWQsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLDZCQUNMa0ksTUFBTSxDQUFDLEtBQ1BjLEVBQUUsQ0FBQyxRQUFRMFUsTUFDWDFVLEVBQUUsQ0FBQyxTQUFTNFUsT0FDWmhWLEtBQUssQ0FBQyxlQUFlO2dCQUFFQyxXQUFXO1lBQU07WUFFM0MsSUFBSTFJLE9BQU8sTUFBTUE7WUFFakIsT0FBT0w7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDLE1BQU1pZjtZQUFpQmpYLFFBQUFBLGlFQUFnQjtRQUNyQyxJQUFJO1lBQ0YsTUFBTSxFQUFFckksSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTdWYsR0FBRyxDQUFDLHNCQUFzQjtnQkFDL0RLLGFBQWFsWDtZQUNmO1lBRUEsSUFBSWhJLE9BQU8sTUFBTUE7WUFFakIsT0FBT0w7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUMsTUFBTUE7UUFDUjtJQUNGO0FBQ0YsRUFBQztBQUVELDZCQUE2QjtBQUN0QixNQUFNbWYsZUFBZTtJQUMxQiwwRUFBMEU7SUFDMUUsTUFBTUM7UUFDSixJQUFJO1lBQ0YsTUFBTSxFQUFFemYsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLGFBQ0xrSSxNQUFNLENBQUUseUtBVVJVLEtBQUssQ0FBQztZQUVULElBQUl6SSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtnQkFDaEQsTUFBTUE7WUFDUjtZQUVBQyxRQUFRZSxHQUFHLENBQUMsMEJBQTBCckIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNc0MsTUFBTSxLQUFJO1lBQ3RELE9BQU90QztRQUNULEVBQUUsT0FBT0ssT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtZQUMzQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSx1RkFBdUY7SUFDdkYsTUFBTXFmO1FBQ0osTUFBTSxFQUFFMWYsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLGFBQ0xrSSxNQUFNLENBQUUsaVVBaUJSVSxLQUFLLENBQUM7UUFFVCxJQUFJekksT0FBTyxNQUFNQTtRQUVqQix1RUFBdUU7UUFDdkUsTUFBTXNmLGtCQUFrQjNmLGlCQUFBQSwyQkFBQUEsS0FBTThDLEdBQUcsQ0FBQyxDQUFDeUcsV0FBbUI7Z0JBQ3BELEdBQUdBLFFBQVE7Z0JBQ1hxVyxpQkFBaUJyVyxTQUFTcVcsZUFBZSxJQUFJN1YsTUFBTUMsT0FBTyxDQUFDVCxTQUFTcVcsZUFBZSxLQUFLclcsU0FBU3FXLGVBQWUsQ0FBQ3RkLE1BQU0sR0FBRyxJQUN0SGlILFNBQVNxVyxlQUFlLENBQUMsRUFBRSxDQUFDLGlDQUFpQzttQkFDN0RyVyxTQUFTcVcsZUFBZSxJQUFJLENBQUM3VixNQUFNQyxPQUFPLENBQUNULFNBQVNxVyxlQUFlLElBQ25FclcsU0FBU3FXLGVBQWUsQ0FBQyxnQ0FBZ0M7bUJBQ3pELEtBQUssd0JBQXdCO1lBQ25DO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLCtDQUErQztJQUMvQyxNQUFNRSw0QkFBMkJyTSxNQUFjO1FBQzdDLElBQUk7WUFDRixxREFBcUQ7WUFDckQsTUFBTSxFQUFFeFQsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQnVmLEdBQUcsQ0FBQyxpQ0FBaUM7Z0JBQUUzSyxTQUFTZjtZQUFPO1lBRTFELElBQUluVCxPQUFPO2dCQUNUQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2IsTUFBTUY7WUFDUjtZQUVBLE9BQU9MO1FBQ1QsRUFBRSxPQUFPSyxPQUFPO1lBQ2RDLFFBQVFDLElBQUksQ0FBQyw4REFBOERGO1lBRTNFLCtDQUErQztZQUMvQyxJQUFJO2dCQUNGLHNCQUFzQjtnQkFDdEIsTUFBTSxFQUFFTCxNQUFNVyxJQUFJLEVBQUVOLE9BQU8rUixTQUFTLEVBQUUsR0FBRyxNQUFNelMsU0FDNUNPLElBQUksQ0FBQyxTQUNMa0ksTUFBTSxDQUFDLHFCQUNQYyxFQUFFLENBQUMsTUFBTXNLLFFBQ1Q3SSxNQUFNO2dCQUVULElBQUl5SCxXQUFXO29CQUNiOVIsUUFBUUQsS0FBSyxDQUFDLDBDQUEwQytSO29CQUN4RCxPQUFPLElBQUksQ0FBQ3FOLGVBQWUsR0FBRyw2QkFBNkI7O2dCQUM3RDtnQkFFQSwyQkFBMkI7Z0JBQzNCLElBQUk5ZSxLQUFLMEcsSUFBSSxLQUFLLFdBQVcxRyxLQUFLMEcsSUFBSSxLQUFLLFFBQVE7b0JBQ2pELDJDQUEyQztvQkFDM0MvRyxRQUFRZSxHQUFHLENBQUM7b0JBQ1osT0FBTyxJQUFJLENBQUNvZSxlQUFlO2dCQUM3QixPQUFPO29CQUNMLDBDQUEwQztvQkFDMUMsSUFBSSxDQUFDOWUsS0FBS29GLFdBQVcsRUFBRTt3QkFDckJ6RixRQUFRQyxJQUFJLENBQUM7d0JBQ2IsT0FBTyxFQUFFO29CQUNYO29CQUVBRCxRQUFRZSxHQUFHLENBQUMsK0NBQStDVixLQUFLb0YsV0FBVztvQkFDM0UsTUFBTSxFQUFFL0YsTUFBTXVKLFFBQVEsRUFBRWxKLE9BQU95ZixhQUFhLEVBQUUsR0FBRyxNQUFNbmdCLFNBQ3BETyxJQUFJLENBQUMsYUFDTGtJLE1BQU0sQ0FBQyxLQUNQYyxFQUFFLENBQUMsTUFBTXZJLEtBQUtvRixXQUFXLEVBQ3pCNEUsTUFBTTtvQkFFVCxJQUFJbVYsZUFBZTt3QkFDakJ4ZixRQUFRRCxLQUFLLENBQUMsK0NBQStDeWY7d0JBQzdELE9BQU8sRUFBRTtvQkFDWDtvQkFFQSxPQUFPO3dCQUFDdlc7cUJBQXFCO2dCQUMvQjtZQUVGLEVBQUUsT0FBT3dXLGVBQWU7Z0JBQ3RCemYsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QjBmO2dCQUMxQyw4Q0FBOEM7Z0JBQzlDLE9BQU8sSUFBSSxDQUFDTixlQUFlO1lBQzdCO1FBQ0Y7SUFDRjtJQUVBLDRCQUE0QjtJQUM1QixNQUFNTyxpQkFBZ0I5ZSxFQUFVO1FBQzlCLE1BQU0sRUFBRWxCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxhQUNMa0ksTUFBTSxDQUFFLGlVQWlCUmMsRUFBRSxDQUFDLE1BQU1oSSxJQUNUeUosTUFBTTtRQUVULElBQUl0SyxPQUFPLE1BQU1BO1FBRWpCLHVFQUF1RTtRQUN2RSxNQUFNc2Ysa0JBQWtCO1lBQ3RCLEdBQUczZixJQUFJO1lBQ1A0ZixpQkFBaUI1ZixLQUFLNGYsZUFBZSxJQUFJN1YsTUFBTUMsT0FBTyxDQUFDaEssS0FBSzRmLGVBQWUsS0FBSzVmLEtBQUs0ZixlQUFlLENBQUN0ZCxNQUFNLEdBQUcsSUFDMUd0QyxLQUFLNGYsZUFBZSxDQUFDLEVBQUUsQ0FBQyxpQ0FBaUM7ZUFDekQ1ZixLQUFLNGYsZUFBZSxJQUFJLENBQUM3VixNQUFNQyxPQUFPLENBQUNoSyxLQUFLNGYsZUFBZSxJQUMzRDVmLEtBQUs0ZixlQUFlLENBQUMsZ0NBQWdDO2VBQ3JELEtBQUssd0JBQXdCO1FBQ25DO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLDhDQUE4QztJQUM5QyxNQUFNTSw4QkFBNkJ2YixVQUFrQixFQUFFd2IsZ0JBQStCLEVBQUUxSixXQUFpQjtRQUN2RyxJQUFJLENBQUN0UCxlQUFlUSxjQUFjLENBQUM4TyxjQUFjO1lBQy9DLE1BQU0sSUFBSS9VLE1BQU07UUFDbEI7UUFFQSxNQUFNLEVBQUV6QixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsYUFDTGtMLE1BQU0sQ0FBQztZQUNOK1Usb0JBQW9CRDtZQUNwQi9VLFlBQVksSUFBSWxLLE9BQU80RSxXQUFXO1FBQ3BDLEdBQ0NxRCxFQUFFLENBQUMsTUFBTXhFLFlBQ1QwRCxNQUFNLEdBQ051QyxNQUFNO1FBRVQsSUFBSXRLLE9BQU8sTUFBTUE7UUFDakIsT0FBT0w7SUFDVDtBQUNGLEVBQUM7QUFFRCxzQkFBc0I7QUFDZixNQUFNb2dCLFVBQVU7SUFDckIsc0JBQXNCO0lBQ3RCLE1BQU1DLFFBQU83YSxLQUFhLEVBQUU4YSxRQUFnQjtRQUMxQyxNQUFNLEVBQUV0Z0IsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTMFIsSUFBSSxDQUFDa1Asa0JBQWtCLENBQUM7WUFDN0QvYTtZQUNBOGE7UUFDRjtRQUNBLElBQUlqZ0IsT0FBTyxNQUFNQTtRQUNqQixPQUFPTDtJQUNUO0lBRUEsaUNBQWlDO0lBQ2pDLE1BQU13Z0IsUUFBT2hiLEtBQWEsRUFBRThhLFFBQWdCLEVBQUVHLFFBQWdCLEVBQUUvYixVQUFtQjtRQUNqRixNQUFNLEVBQUUxRSxJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVMwUixJQUFJLENBQUNtUCxNQUFNLENBQUM7WUFDakRoYjtZQUNBOGE7WUFDQUksU0FBUztnQkFDUDFnQixNQUFNO29CQUNKaUcsV0FBV3dhO29CQUNYMWEsYUFBYXJCO2dCQUNmO1lBQ0Y7UUFDRjtRQUNBLElBQUlyRSxPQUFPLE1BQU1BO1FBQ2pCLE9BQU9MO0lBQ1Q7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTTJnQjtRQUNKLE1BQU0sRUFBRXRnQixLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTMFIsSUFBSSxDQUFDc1AsT0FBTztRQUM3QyxJQUFJdGdCLE9BQU8sTUFBTUE7SUFDbkI7SUFFQSxpQ0FBaUM7SUFDakMsTUFBTXVnQjtRQUNKLE1BQU0sRUFBRTVnQixNQUFNLEVBQUVXLElBQUksRUFBRSxFQUFFLEdBQUcsTUFBTWhCLFNBQVMwUixJQUFJLENBQUNDLE9BQU87UUFDdEQsT0FBTzNRO0lBQ1Q7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTWtnQixnQkFBZXJOLE1BQWM7UUFDakMsTUFBTSxFQUFFeFQsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFNBQ0xrSSxNQUFNLENBQUMsS0FDUGMsRUFBRSxDQUFDLE1BQU1zSyxRQUNUN0ksTUFBTTtRQUVULElBQUl0SyxPQUFPLE1BQU1BO1FBQ2pCLE9BQU9MO0lBQ1Q7SUFFQSwwREFBMEQ7SUFDMUQsTUFBTThnQjtRQUNKLElBQUk7WUFDRnhnQixRQUFRZSxHQUFHLENBQUM7WUFFWixpQ0FBaUM7WUFDakMsTUFBTSxFQUFFckIsTUFBTSxFQUFFVyxJQUFJLEVBQUUsRUFBRSxHQUFHLE1BQU1oQixTQUFTMFIsSUFBSSxDQUFDQyxPQUFPO1lBQ3REaFIsUUFBUWUsR0FBRyxDQUFDLDJCQUEyQlYsaUJBQUFBLDJCQUFBQSxLQUFNNkUsS0FBSyxFQUFFN0UsaUJBQUFBLDJCQUFBQSxLQUFNTyxFQUFFO1lBRTVELE1BQU0sRUFBRWxCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxTQUNMa0ksTUFBTSxDQUFDLDBDQUNQVSxLQUFLLENBQUM7WUFFVHhJLFFBQVFlLEdBQUcsQ0FBQyw2Q0FBNkNyQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQyxNQUFNLEtBQUk7WUFDekVoQyxRQUFRZSxHQUFHLENBQUMsMEJBQTBCaEI7WUFFdEMsSUFBSUEsT0FBTztvQkFJd0JBLGdCQUFrQ0E7Z0JBSG5FQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtnQkFFN0MsK0JBQStCO2dCQUMvQixJQUFJQSxNQUFNZ0wsSUFBSSxLQUFLLGdCQUFjaEwsaUJBQUFBLE1BQU1xQixPQUFPLGNBQWJyQixxQ0FBQUEsZUFBZU4sUUFBUSxDQUFDLGFBQVVNLGtCQUFBQSxNQUFNcUIsT0FBTyxjQUFickIsc0NBQUFBLGdCQUFlTixRQUFRLENBQUMsZ0JBQWU7b0JBQ3hHTyxRQUFRRCxLQUFLLENBQUM7Z0JBQ2hCO2dCQUVBLE1BQU1BO1lBQ1I7WUFFQSxJQUFJTCxRQUFRQSxLQUFLc0MsTUFBTSxHQUFHLEdBQUc7Z0JBQzNCaEMsUUFBUWUsR0FBRyxDQUFDLDZCQUE2QnJCLEtBQUtrRCxLQUFLLENBQUMsR0FBRyxHQUFHSixHQUFHLENBQUNzSyxDQUFBQSxJQUFNO3dCQUNsRWxNLElBQUlrTSxFQUFFbE0sRUFBRTt3QkFDUkwsTUFBTXVNLEVBQUVuSCxTQUFTO3dCQUNqQm9CLE1BQU0rRixFQUFFL0YsSUFBSTtvQkFDZDtZQUNGLE9BQU87Z0JBQ0wvRyxRQUFRZSxHQUFHLENBQUM7WUFDZDtZQUVBLE9BQU9yQjtRQUNULEVBQUUsT0FBT0ssT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsTUFBTTBnQjtRQUNKLE1BQU0sRUFBRS9nQixNQUFNLEVBQUVnaEIsT0FBTyxFQUFFLEVBQUUsR0FBRyxNQUFNcmhCLFNBQVMwUixJQUFJLENBQUMwUCxVQUFVO1FBQzVELE9BQU9DO0lBQ1Q7SUFFQSxnQ0FBZ0M7SUFDaENDLG1CQUFrQnRULFFBQStDO1FBQy9ELE9BQU9oTyxTQUFTMFIsSUFBSSxDQUFDNFAsaUJBQWlCLENBQUN0VDtJQUN6QztJQUVBLGdDQUFnQztJQUNoQyxNQUFNdVQsb0JBQW1CMU4sTUFBYyxFQUFFMk4sUUFBNEI7UUFDbkUsTUFBTSxFQUFFbmhCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxTQUNMa0wsTUFBTSxDQUFDO1lBQUUrVjtRQUFTLEdBQ2xCalksRUFBRSxDQUFDLE1BQU1zSyxRQUNUcEwsTUFBTSxHQUNOdUMsTUFBTTtRQUVULElBQUl0SyxPQUFPLE1BQU1BO1FBQ2pCLE9BQU9MO0lBQ1Q7SUFFQSxzRUFBc0U7SUFDdEUsTUFBTW9oQjtRQUNKLElBQUk7WUFDRjlnQixRQUFRZSxHQUFHLENBQUM7WUFFWixpQ0FBaUM7WUFDakMsTUFBTSxFQUFFckIsTUFBTSxFQUFFVyxJQUFJLEVBQUUsRUFBRSxHQUFHLE1BQU1oQixTQUFTMFIsSUFBSSxDQUFDQyxPQUFPO1lBQ3REaFIsUUFBUWUsR0FBRyxDQUFDLDJCQUEyQlYsaUJBQUFBLDJCQUFBQSxLQUFNNkUsS0FBSyxFQUFFN0UsaUJBQUFBLDJCQUFBQSxLQUFNTyxFQUFFO1lBRTVELElBQUksQ0FBQ1AsTUFBTTtnQkFDVEwsUUFBUWUsR0FBRyxDQUFDO2dCQUNaLE9BQU8sRUFBRTtZQUNYO1lBRUEsTUFBTSxFQUFFckIsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLFNBQ0xrSSxNQUFNLENBQUMsMENBQ1BVLEtBQUssQ0FBQztZQUVUeEksUUFBUWUsR0FBRyxDQUFDLHVEQUF1RHJCLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXNDLE1BQU0sS0FBSTtZQUVuRixJQUFJakMsT0FBTztvQkFJd0JBLGdCQUFrQ0E7Z0JBSG5FQyxRQUFRRCxLQUFLLENBQUMseUNBQXlDQTtnQkFFdkQsb0VBQW9FO2dCQUNwRSxJQUFJQSxNQUFNZ0wsSUFBSSxLQUFLLGdCQUFjaEwsaUJBQUFBLE1BQU1xQixPQUFPLGNBQWJyQixxQ0FBQUEsZUFBZU4sUUFBUSxDQUFDLGFBQVVNLGtCQUFBQSxNQUFNcUIsT0FBTyxjQUFickIsc0NBQUFBLGdCQUFlTixRQUFRLENBQUMsZ0JBQWU7b0JBQ3hHTyxRQUFRRCxLQUFLLENBQUM7b0JBRWQsd0NBQXdDO29CQUN4QyxJQUFJO3dCQUNGLE1BQU04UixjQUFjLE1BQU0sSUFBSSxDQUFDME8sY0FBYyxDQUFDbGdCLEtBQUtPLEVBQUU7d0JBQ3JEWixRQUFRZSxHQUFHLENBQUMsdURBQXVEOFEsWUFBWWxNLFNBQVM7d0JBQ3hGLE9BQU87NEJBQUNrTTt5QkFBWTtvQkFDdEIsRUFBRSxPQUFPa1AsY0FBYzt3QkFDckIvZ0IsUUFBUUQsS0FBSyxDQUFDLDJDQUEyQ2doQjt3QkFDekQsT0FBTyxFQUFFO29CQUNYO2dCQUNGO2dCQUVBLGtDQUFrQztnQkFDbEMvZ0IsUUFBUUQsS0FBSyxDQUFDO2dCQUNkLE9BQU8sRUFBRTtZQUNYO1lBRUEsSUFBSUwsUUFBUUEsS0FBS3NDLE1BQU0sR0FBRyxHQUFHO2dCQUMzQmhDLFFBQVFlLEdBQUcsQ0FBQyxtQ0FBbUNyQixLQUFLc0MsTUFBTTtnQkFDMURoQyxRQUFRZSxHQUFHLENBQUMsNkJBQTZCckIsS0FBS2tELEtBQUssQ0FBQyxHQUFHLEdBQUdKLEdBQUcsQ0FBQ3NLLENBQUFBLElBQU07d0JBQ2xFbE0sSUFBSWtNLEVBQUVsTSxFQUFFO3dCQUNSTCxNQUFNdU0sRUFBRW5ILFNBQVM7d0JBQ2pCb0IsTUFBTStGLEVBQUUvRixJQUFJO29CQUNkO2dCQUNBLE9BQU9ySDtZQUNULE9BQU87Z0JBQ0xNLFFBQVFlLEdBQUcsQ0FBQztnQkFFWiw4Q0FBOEM7Z0JBQzlDLElBQUk7b0JBQ0YsTUFBTThRLGNBQWMsTUFBTSxJQUFJLENBQUMwTyxjQUFjLENBQUNsZ0IsS0FBS08sRUFBRTtvQkFDckRaLFFBQVFlLEdBQUcsQ0FBQyx1REFBdUQ4USxZQUFZbE0sU0FBUztvQkFDeEYsT0FBTzt3QkFBQ2tNO3FCQUFZO2dCQUN0QixFQUFFLE9BQU9rUCxjQUFjO29CQUNyQi9nQixRQUFRRCxLQUFLLENBQUMsMkNBQTJDZ2hCO29CQUN6RCxPQUFPLEVBQUU7Z0JBQ1g7WUFDRjtRQUVGLEVBQUUsT0FBT2hoQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywyQ0FBMkNBO1lBRXpELDBFQUEwRTtZQUMxRSxJQUFJO2dCQUNGLE1BQU0sRUFBRUwsTUFBTSxFQUFFVyxJQUFJLEVBQUUsRUFBRSxHQUFHLE1BQU1oQixTQUFTMFIsSUFBSSxDQUFDQyxPQUFPO2dCQUN0RCxJQUFJM1EsTUFBTTtvQkFDUixNQUFNd1IsY0FBYyxNQUFNLElBQUksQ0FBQzBPLGNBQWMsQ0FBQ2xnQixLQUFLTyxFQUFFO29CQUNyRFosUUFBUWUsR0FBRyxDQUFDLDBEQUEwRDhRLFlBQVlsTSxTQUFTO29CQUMzRixPQUFPO3dCQUFDa007cUJBQVk7Z0JBQ3RCO1lBQ0YsRUFBRSxPQUFPbVAsZUFBZTtnQkFDdEJoaEIsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QmloQjtZQUM5QztZQUVBLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7QUFDRixFQUFDO0FBRUQsbUVBQW1FO0FBQzVELE1BQU1DLHVCQUF1QixDQUFDQztJQUNuQyxJQUFJLENBQUNBLGlCQUFpQjtRQUNwQixPQUFPO1lBQUUxUixPQUFPO1lBQW1EMlIsYUFBYTtZQUFRQyxVQUFVO1FBQU07SUFDMUc7SUFFQSxNQUFNdmdCLE1BQU0sSUFBSUY7SUFDaEIsTUFBTTBnQixhQUFhLElBQUkxZ0IsS0FBS3VnQjtJQUM1QixNQUFNSSxXQUFXNWEsS0FBS0MsS0FBSyxDQUFDLENBQUM5RixJQUFJa2MsT0FBTyxLQUFLc0UsV0FBV3RFLE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUM7SUFFeEYsSUFBSXVFLFlBQVksR0FBRztRQUNqQiw2QkFBNkI7UUFDN0IsT0FBTztZQUNMOVIsT0FBTztZQUNQMlIsYUFBYSxXQUFvQixPQUFURyxVQUFTO1lBQ2pDRixVQUFVO1FBQ1o7SUFDRixPQUFPLElBQUlFLFlBQVksR0FBRztRQUN4QiwwQkFBMEI7UUFDMUIsT0FBTztZQUNMOVIsT0FBTztZQUNQMlIsYUFBYSxpQkFBMEIsT0FBVEcsVUFBUztZQUN2Q0YsVUFBVTtRQUNaO0lBQ0YsT0FBTztRQUNMLDRCQUE0QjtRQUM1QixPQUFPO1lBQ0w1UixPQUFPO1lBQ1AyUixhQUFhLFVBQW1CLE9BQVRHLFVBQVM7WUFDaENGLFVBQVU7UUFDWjtJQUNGO0FBQ0YsRUFBQztBQUVELDREQUE0RDtBQUNyRCxNQUFNRywrQkFBK0IsT0FBT2xoQjtJQUNqRCxJQUFJO1FBQ0YsTUFBTWlKLFVBQVUsTUFBTTlDLFdBQVd1RCxVQUFVLENBQUMxSjtRQUM1QyxNQUFNbWhCLGdCQUFnQmxZLFFBQVF6SCxNQUFNLENBQUMsQ0FBQ2lGLFNBQWdCQSxPQUFPbEMsTUFBTSxLQUFLO1FBRXhFLE1BQU02YyxnQkFBZ0I7WUFDcEJDLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxLQUFLO1lBQ0w1YixPQUFPd2IsY0FBY3hmLE1BQU07UUFDN0I7UUFFQXdmLGNBQWN2ZCxPQUFPLENBQUMsQ0FBQzZDO1lBQ3JCLE1BQU0sRUFBRXNhLFFBQVEsRUFBRSxHQUFHSCxxQkFBcUJuYSxPQUFPb0QsaUJBQWlCO1lBQ2xFdVgsYUFBYSxDQUFDTCxTQUFTO1FBQ3pCO1FBRUEsT0FBTztZQUNMOVgsU0FBU2tZO1lBQ1R6SixPQUFPMEo7UUFDVDtJQUNGLEVBQUUsT0FBTzFoQixPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxvQ0FBb0NBO1FBQ2xELE9BQU87WUFBRXVKLFNBQVMsRUFBRTtZQUFFeU8sT0FBTztnQkFBRTJKLE1BQU07Z0JBQUdDLFFBQVE7Z0JBQUdDLEtBQUs7Z0JBQUc1YixPQUFPO1lBQUU7UUFBRTtJQUN4RTtBQUNGLEVBQUM7QUFFRCxtRUFBbUU7QUFDbkUsMkRBQTJEO0FBRXBELE1BQU02YixlQUFlO0lBQzFCLG1FQUFtRTtJQUNuRSxNQUFNQztRQUNKLElBQUk7WUFDRjloQixRQUFRZSxHQUFHLENBQUM7WUFFWixNQUFNLEVBQUVyQixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVN1ZixHQUFHLENBQUM7WUFFM0MsSUFBSTdlLE9BQU87Z0JBQ1RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUNyRCxNQUFNQTtZQUNSO1lBRUFDLFFBQVFlLEdBQUcsQ0FBQyxpREFBaURyQixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQyxNQUFNLEtBQUksR0FBRztZQUNoRixPQUFPdEM7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7WUFDL0MsTUFBTUE7UUFDUjtJQUNGO0lBRUEsbURBQW1EO0lBQ25ELE1BQU1naUI7UUFDSixJQUFJO1lBQ0YsbURBQW1EO1lBQ25ELE1BQU0sRUFBRXJpQixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsd0JBQ0xrSSxNQUFNLENBQUMsZ0JBQ1BDLEtBQUssQ0FBQyxHQUNOc0MsTUFBTTtZQUVULElBQUl0SyxPQUFPO2dCQUNUQyxRQUFRQyxJQUFJLENBQUMsOEVBQThFRjtnQkFDM0YsbUNBQW1DO2dCQUNuQyxPQUFPO29CQUNMaWlCLFlBQVksSUFBSXJoQixPQUFPNEUsV0FBVztvQkFDbEMwYyxvQkFBb0I7b0JBQ3BCQyxTQUFTLE1BQU0sOENBQThDO2dCQUMvRDtZQUNGO1lBRUEsTUFBTUYsYUFBYSxJQUFJcmhCLEtBQUtqQixLQUFLeWlCLFlBQVk7WUFDN0MsTUFBTXRoQixNQUFNLElBQUlGO1lBQ2hCLE1BQU1zaEIscUJBQXFCdmIsS0FBS0MsS0FBSyxDQUFDLENBQUM5RixJQUFJa2MsT0FBTyxLQUFLaUYsV0FBV2pGLE9BQU8sRUFBQyxJQUFNLFFBQU8sRUFBQztZQUV4RixPQUFPO2dCQUNMaUYsWUFBWXRpQixLQUFLeWlCLFlBQVk7Z0JBQzdCRjtnQkFDQUMsU0FBU0QscUJBQXFCLEdBQUcsc0NBQXNDO1lBQ3pFO1FBQ0YsRUFBRSxPQUFPbGlCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7WUFDdkQsb0JBQW9CO1lBQ3BCLE9BQU87Z0JBQ0xpaUIsWUFBWSxJQUFJcmhCLE9BQU80RSxXQUFXO2dCQUNsQzBjLG9CQUFvQjtnQkFDcEJDLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7QUFDRixFQUFDO0FBRUQsZ0VBQWdFO0FBRXpELE1BQU1FLFVBQVU7SUFDckIscUNBQXFDO0lBQ3JDLE1BQU1DO1FBQ0osSUFBSTtZQUNGcmlCLFFBQVFlLEdBQUcsQ0FBQztZQUVaLE1BQU0sRUFBRXJCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyx1QkFDTGtJLE1BQU0sQ0FBQyxLQUNQOEUsRUFBRSxDQUFDLFFBQVE7Z0JBQUM7Z0JBQWE7Z0JBQVc7Z0JBQW1CO2dCQUFrQjthQUFPLEVBQ2hGcEUsS0FBSyxDQUFDLGtCQUFrQjtnQkFBRUMsV0FBVztZQUFNO1lBRTlDLElBQUkxSSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMseUNBQXlDQTtnQkFDdkQsTUFBTUE7WUFDUjtZQUVBQyxRQUFRZSxHQUFHLENBQUMsZ0NBQWtELE9BQWxCckIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNc0MsTUFBTSxLQUFJLEdBQUU7WUFDOUQsT0FBT3RDO1FBQ1QsRUFBRSxPQUFPSyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ25ELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDJEQUEyRDtJQUMzRCxNQUFNdWlCO1FBQ0osSUFBSTtZQUNGLE1BQU0sRUFBRTVpQixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQzNCTyxJQUFJLENBQUMsdUJBQ0xrSSxNQUFNLENBQUMsc0RBQ1BjLEVBQUUsQ0FBQyxtQkFBbUIsVUFDdEJKLEtBQUssQ0FBQyxpQkFBaUI7Z0JBQUVDLFdBQVc7WUFBTTtZQUU3QyxJQUFJMUksT0FBTyxNQUFNQTtZQUVqQixPQUFPTDtRQUNULEVBQUUsT0FBT0ssT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTXdpQjtRQUNKLElBQUk7WUFDRixNQUFNLEVBQUU3aUIsSUFBSSxFQUFFSyxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUMzQk8sSUFBSSxDQUFDLHVCQUNMa0ksTUFBTSxDQUFDLCtEQUNQOEUsRUFBRSxDQUFDLFFBQVE7Z0JBQUM7Z0JBQWE7Z0JBQVc7Z0JBQW1CO2dCQUFrQjthQUFPO1lBRW5GLElBQUk3TSxPQUFPLE1BQU1BO1lBRWpCLGlCQUFpQjtZQUNqQixNQUFNeWlCLGFBQWE5aUIsS0FBS3NDLE1BQU07WUFDOUIsTUFBTXlnQixXQUFXL2lCLEtBQUtpUixNQUFNLENBQUMsQ0FBQ0MsS0FBS3ZRLE9BQVN1USxNQUFNdlEsS0FBS3FpQixjQUFjLEVBQUUsS0FBS0Y7WUFDNUUsTUFBTUcsWUFBWWpqQixLQUFLaVIsTUFBTSxDQUFDLENBQUNDLEtBQUt2USxPQUFTdVEsTUFBTXZRLEtBQUt1aUIsYUFBYSxFQUFFLEtBQUtKO1lBRTVFLE9BQU87Z0JBQ0xBO2dCQUNBSyxvQkFBb0JuYyxLQUFLMlEsS0FBSyxDQUFDb0w7Z0JBQy9CSyxxQkFBcUJwYyxLQUFLMlEsS0FBSyxDQUFDc0w7Z0JBQ2hDSSxzQkFBc0JyakIsS0FBS2lSLE1BQU0sQ0FBQyxDQUFDQyxLQUFLdlEsT0FBU3VRLE1BQU12USxLQUFLcWlCLGNBQWMsRUFBRTtnQkFDNUVNLHVCQUF1QnRqQixLQUFLaVIsTUFBTSxDQUFDLENBQUNDLEtBQUt2USxPQUFTdVEsTUFBTXZRLEtBQUt1aUIsYUFBYSxFQUFFO1lBQzlFO1FBQ0YsRUFBRSxPQUFPN2lCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsTUFBTUE7UUFDUjtJQUNGO0FBQ0YsRUFBQztBQUVELGdDQUFnQztBQUN6QixNQUFNa2pCLGlCQUFpQjtJQUM1Qix3Q0FBd0M7SUFDeEMsTUFBTUM7UUFDSixJQUFJO1lBQ0ZsakIsUUFBUWUsR0FBRyxDQUFDO1lBQ1osTUFBTW9pQixhQUFhLEVBQUU7WUFFckIsaUVBQWlFO1lBQ2pFLE1BQU1DLGdCQUFnQixPQUFPQztnQkFDM0IsSUFBSTtvQkFDRixNQUFNLEVBQUVsYixLQUFLLEVBQUVwSSxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUM1Qk8sSUFBSSxDQUFDeWpCLFdBQ0x2YixNQUFNLENBQUMsS0FBSzt3QkFBRUssT0FBTzt3QkFBUzZPLE1BQU07b0JBQUs7b0JBRTVDLElBQUlqWCxPQUFPO3dCQUNUQyxRQUFRQyxJQUFJLENBQUMsd0NBQWtELE9BQVZvakIsV0FBVSxNQUFJdGpCLE1BQU1xQixPQUFPO3dCQUNoRixPQUFPO29CQUNUO29CQUVBLE9BQU87d0JBQ0xraUIsWUFBWUQ7d0JBQ1pFLGNBQWNwYixTQUFTO3dCQUN2QnFiLFlBQVk7d0JBQ1pyQixjQUFjLElBQUl4aEIsT0FBTzRFLFdBQVc7b0JBQ3RDO2dCQUNGLEVBQUUsT0FBTzBILEtBQUs7b0JBQ1pqTixRQUFRQyxJQUFJLENBQUMsa0JBQTRCLE9BQVZvakIsV0FBVSxNQUFJcFc7b0JBQzdDLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLGtDQUFrQztZQUNsQyxNQUFNd1csU0FBUztnQkFBQztnQkFBVztnQkFBUztnQkFBaUI7YUFBd0I7WUFFN0UsS0FBSyxNQUFNSixhQUFhSSxPQUFRO2dCQUM5QixNQUFNMUwsUUFBUSxNQUFNcUwsY0FBY0M7Z0JBQ2xDLElBQUl0TCxPQUFPO29CQUNUb0wsV0FBVzVnQixJQUFJLENBQUN3VjtnQkFDbEI7WUFDRjtZQUVBLDRFQUE0RTtZQUM1RSxJQUFJb0wsV0FBV25oQixNQUFNLEtBQUssR0FBRztnQkFDM0JoQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2JrakIsV0FBVzVnQixJQUFJLENBQUM7b0JBQ2QrZ0IsWUFBWTtvQkFDWkMsY0FBYztvQkFDZEMsWUFBWTtvQkFDWnJCLGNBQWMsSUFBSXhoQixPQUFPNEUsV0FBVztnQkFDdEM7WUFDRjtZQUVBdkYsUUFBUWUsR0FBRyxDQUFDLHdCQUEwQyxPQUFsQm9pQixXQUFXbmhCLE1BQU0sRUFBQztZQUN0RCxPQUFPbWhCO1FBQ1QsRUFBRSxPQUFPcGpCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7WUFFNUMsZ0VBQWdFO1lBQ2hFLE9BQU87Z0JBQUM7b0JBQ051akIsWUFBWTtvQkFDWkMsY0FBYztvQkFDZEMsWUFBWTtvQkFDWnJCLGNBQWMsSUFBSXhoQixPQUFPNEUsV0FBVztnQkFDdEM7YUFBRTtRQUNKO0lBQ0Y7SUFFQSxpREFBaUQ7SUFDakQsTUFBTW1lO1FBQ0osSUFBSTtZQUNGMWpCLFFBQVFlLEdBQUcsQ0FBQztZQUVaLE1BQU0sRUFBRXJCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FBU3VmLEdBQUcsQ0FBQztZQUUzQyxJQUFJN2UsT0FBTyxNQUFNQTtZQUVqQkMsUUFBUWUsR0FBRyxDQUFDLHdCQUF3QnJCO1lBQ3BDLE9BQU9BO1FBQ1QsRUFBRSxPQUFPSyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixNQUFNNGpCO1FBQ0osSUFBSTtZQUNGM2pCLFFBQVFlLEdBQUcsQ0FBQztZQUVaLE1BQU0sRUFBRXJCLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FBU3VmLEdBQUcsQ0FBQztZQUUzQyxJQUFJN2UsT0FBTyxNQUFNQTtZQUVqQkMsUUFBUWUsR0FBRyxDQUFDLG9CQUF5QixPQUFMckIsTUFBSztZQUNyQyxPQUFPQTtRQUNULEVBQUUsT0FBT0ssT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsTUFBTTZqQjtRQUNKLElBQUk7WUFDRjVqQixRQUFRZSxHQUFHLENBQUM7WUFFWixNQUFNLEVBQUVyQixJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVN1ZixHQUFHLENBQUM7WUFFM0MsSUFBSTdlLE9BQU8sTUFBTUE7WUFFakJDLFFBQVFlLEdBQUcsQ0FBQyxrQ0FBa0NyQjtZQUM5QyxPQUFPQTtRQUNULEVBQUUsT0FBT0ssT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxNQUFNQTtRQUNSO0lBQ0Y7QUFDRixFQUFDO0FBcURNLE1BQU04akIsV0FBVztJQUN0Qjs7Ozs7Ozs7R0FRQyxHQUNELE1BQU1DLFVBQVN6akIsSUFBVTtZQUFFd0IsU0FBQUEsaUVBQXNCLENBQUM7UUFDaEQsSUFBSTtZQUNGN0IsUUFBUWUsR0FBRyxDQUFDLHNDQUFzQztnQkFBRVYsTUFBTUEsS0FBSzBHLElBQUk7Z0JBQUVsRjtZQUFPO1lBRTVFLElBQUlxRyxRQUFRN0ksU0FDVE8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFFLGdZQW1CUmMsRUFBRSxDQUFDLGlCQUFpQixvQkFDcEJKLEtBQUssQ0FBQyxhQUFhO2dCQUFFQyxXQUFXO1lBQU0sR0FDdENWLEtBQUssQ0FBQ2xHLE9BQU9rRyxLQUFLLElBQUk7WUFFekIsMkNBQTJDO1lBQzNDLElBQUkxSCxLQUFLMEcsSUFBSSxLQUFLLGFBQWE7Z0JBQzdCLHlDQUF5QztnQkFDekNtQixRQUFRQSxNQUFNVSxFQUFFLENBQUMsY0FBY3ZJLEtBQUtPLEVBQUU7WUFDeEMsT0FBTyxJQUFJO2dCQUFDO2dCQUFrQjtnQkFBVzthQUFrQixDQUFDbkIsUUFBUSxDQUFDWSxLQUFLMEcsSUFBSSxHQUFHO2dCQUMvRSxrREFBa0Q7Z0JBQ2xELElBQUlsRixPQUFPdUMsVUFBVSxFQUFFO29CQUNyQix1REFBdUQ7b0JBQ3ZEOEQsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLHVCQUF1Qi9HLE9BQU91QyxVQUFVO2dCQUMzRCxPQUFPLElBQUkvRCxLQUFLb0YsV0FBVyxFQUFFO29CQUMzQixpRUFBaUU7b0JBQ2pFeUMsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLHVCQUF1QnZJLEtBQUtvRixXQUFXO2dCQUMxRDtZQUNGLE9BQU8sSUFBSTtnQkFBQztnQkFBUTthQUFRLENBQUNoRyxRQUFRLENBQUNZLEtBQUswRyxJQUFJLEdBQUc7Z0JBQ2hELHFFQUFxRTtnQkFDckUsSUFBSWxGLE9BQU91QyxVQUFVLEVBQUU7b0JBQ3JCOEQsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLHVCQUF1Qi9HLE9BQU91QyxVQUFVO2dCQUMzRDtZQUNGO1lBRUEsMkJBQTJCO1lBQzNCLElBQUl2QyxPQUFPa1UsU0FBUyxFQUFFO2dCQUNwQjdOLFFBQVFBLE1BQU1TLEdBQUcsQ0FBQyxhQUFhOUcsT0FBT2tVLFNBQVM7WUFDakQ7WUFDQSxJQUFJbFUsT0FBT21VLE9BQU8sRUFBRTtnQkFDbEI5TixRQUFRQSxNQUFNMFIsR0FBRyxDQUFDLGFBQWEvWCxPQUFPbVUsT0FBTztZQUMvQztZQUVBLE1BQU0sRUFBRXRXLE1BQU1xa0IsUUFBUSxFQUFFaGtCLEtBQUssRUFBRSxHQUFHLE1BQU1tSTtZQUV4QyxJQUFJbkksT0FBTztnQkFDVEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7Z0JBQzdDLE1BQU1BO1lBQ1I7WUFFQSxJQUFJLENBQUNna0IsWUFBWUEsU0FBUy9oQixNQUFNLEtBQUssR0FBRztnQkFDdENoQyxRQUFRZSxHQUFHLENBQUM7Z0JBQ1osT0FBTyxFQUFFO1lBQ1g7WUFFQSxtREFBbUQ7WUFDbkQsTUFBTWlqQixZQUFZO21CQUFJLElBQUl4WCxJQUFJdVgsU0FBU3ZoQixHQUFHLENBQUN6QixDQUFBQSxNQUFPQSxJQUFJeUssVUFBVTthQUFHO1lBQ25FLE1BQU0sRUFBRTlMLE1BQU11a0IsT0FBTyxFQUFFbGtCLE9BQU9ta0IsWUFBWSxFQUFFLEdBQUcsTUFBTTdrQixTQUNsRE8sSUFBSSxDQUFDLFNBQ0xrSSxNQUFNLENBQUMsbUNBQ1A4RSxFQUFFLENBQUMsTUFBTW9YO1lBRVosSUFBSUUsY0FBYztnQkFDaEJsa0IsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ21rQjtZQUNqRCx3Q0FBd0M7WUFDMUM7WUFFQSwyQkFBMkI7WUFDM0IsTUFBTUMsYUFBYSxDQUFDRixXQUFXLEVBQUUsRUFBRXRULE1BQU0sQ0FBQyxDQUFDWSxLQUFLNlM7Z0JBQzlDN1MsR0FBRyxDQUFDNlMsT0FBT3hqQixFQUFFLENBQUMsR0FBR3dqQjtnQkFDakIsT0FBTzdTO1lBQ1QsR0FBRyxDQUFDO1lBRUcsd0NBQXdDO1lBQzlDLE1BQU04UyxjQUE0Qk4sU0FBU3ZoQixHQUFHLENBQUN6QixDQUFBQTtnQkFDN0MsTUFBTStGLFNBQVMyQyxNQUFNQyxPQUFPLENBQUMzSSxJQUFJdUksT0FBTyxJQUFJdkksSUFBSXVJLE9BQU8sQ0FBQyxFQUFFLEdBQUd2SSxJQUFJdUksT0FBTztnQkFDeEUsTUFBTThhLFNBQVNELFVBQVUsQ0FBQ3BqQixJQUFJeUssVUFBVSxDQUFDO2dCQUN6QyxNQUFNdkMsV0FBV1EsTUFBTUMsT0FBTyxDQUFDNUMsbUJBQUFBLDZCQUFBQSxPQUFRbUMsUUFBUSxJQUFJbkMsT0FBT21DLFFBQVEsQ0FBQyxFQUFFLEdBQUduQyxtQkFBQUEsNkJBQUFBLE9BQVFtQyxRQUFRO2dCQUV4RixPQUFPO29CQUNMckksSUFBSUcsSUFBSUgsRUFBRTtvQkFDVjJLLFdBQVd4SyxJQUFJd0ssU0FBUztvQkFDeEIrWSxhQUFheGQsU0FBUyxHQUF3QkEsT0FBckJBLE9BQU9qQyxVQUFVLEVBQUMsS0FBb0IsT0FBakJpQyxPQUFPaEMsU0FBUyxFQUFHL0MsSUFBSSxLQUFLO29CQUMxRXdpQixnQkFBZ0J6ZCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVEvQixZQUFZLEtBQUk7b0JBQ3hDeWYsY0FBYzFkLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUTdCLEtBQUssS0FBSTtvQkFDL0J3ZixXQUFXMWpCLElBQUl5SyxVQUFVO29CQUN6QmtaLGFBQWFOLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUXplLFNBQVMsS0FBSTtvQkFDbENnZixhQUFhUCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFyZCxJQUFJLEtBQUk7b0JBQzdCNmQsZUFBZVIsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRdmUsVUFBVSxLQUFJO29CQUNyQ2dmLGdCQUFnQjlqQixJQUFJeVEsU0FBUztvQkFDN0IvTCxhQUFhcUIsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRckIsV0FBVyxLQUFJO29CQUNwQ3FmLGVBQWU3YixDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVUxSSxJQUFJLEtBQUk7b0JBQ2pDd2tCLGVBQWU5YixDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVU4QixJQUFJLEtBQUk7Z0JBQ25DO1lBQ0Y7WUFFRC9LLFFBQVFlLEdBQUcsQ0FBQyxhQUFnQyxPQUFuQnNqQixZQUFZcmlCLE1BQU0sRUFBQztZQUM1QyxPQUFPcWlCO1FBRVQsRUFBRSxPQUFPdGtCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsTUFBTUE7UUFDUjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU1pbEIsZUFBYzNrQixJQUFVO1lBQUV3QixTQUFBQSxpRUFBc0IsQ0FBQztRQU9yRCxJQUFJO1lBQ0Y3QixRQUFRZSxHQUFHLENBQUM7WUFFWixNQUFNRixNQUFNLElBQUlGO1lBQ2hCLE1BQU02TixRQUFRM04sSUFBSTBFLFdBQVcsR0FBRzNELEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM3QyxNQUFNcWpCLFlBQVksSUFBSXRrQixLQUFLRSxJQUFJNlIsT0FBTyxDQUFDN1IsSUFBSThSLE9BQU8sS0FBSzlSLElBQUlvWixNQUFNLEtBQUsxVSxXQUFXLEdBQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDakcsTUFBTTZXLGFBQWEsSUFBSTlYLEtBQUtFLElBQUkyWCxXQUFXLElBQUkzWCxJQUFJeVgsUUFBUSxJQUFJLEdBQUcvUyxXQUFXO1lBRTdFLHVEQUF1RDtZQUN2RCxNQUFNMmYsV0FBVyxNQUFNckIsU0FBU0MsUUFBUSxDQUFDempCLE1BQU07Z0JBQUUsR0FBR3dCLE1BQU07Z0JBQUVrRyxPQUFPO1lBQUs7WUFFeEUsbUJBQW1CO1lBQ25CLE1BQU1vZCxhQUFhRCxTQUFTbGpCLE1BQU07WUFDbEMsTUFBTW9qQixhQUFhRixTQUFTcmpCLE1BQU0sQ0FBQ3dqQixDQUFBQSxPQUFRQSxLQUFLUixjQUFjLENBQUNybEIsVUFBVSxDQUFDZ1AsUUFBUXhNLE1BQU07WUFDeEYsTUFBTXNqQixnQkFBZ0JKLFNBQVNyakIsTUFBTSxDQUFDd2pCLENBQUFBLE9BQVFBLEtBQUtSLGNBQWMsSUFBSUksV0FBV2pqQixNQUFNO1lBQ3RGLE1BQU11akIsaUJBQWlCTCxTQUFTcmpCLE1BQU0sQ0FBQ3dqQixDQUFBQSxPQUFRQSxLQUFLUixjQUFjLElBQUlwTSxZQUFZelcsTUFBTTtZQUV4RixnQkFBZ0I7WUFDaEIsTUFBTXdqQixlQUFlTixTQUFTdlUsTUFBTSxDQUFDLENBQUNZLEtBQUs4VDtnQkFDekMsTUFBTUksTUFBTUosS0FBS1osU0FBUztnQkFDMUIsSUFBSSxDQUFDbFQsR0FBRyxDQUFDa1UsSUFBSSxFQUFFO29CQUNibFUsR0FBRyxDQUFDa1UsSUFBSSxHQUFHO3dCQUNUbGxCLE1BQU04a0IsS0FBS1gsV0FBVzt3QkFDdEIzZCxNQUFNc2UsS0FBS1YsV0FBVzt3QkFDdEJlLFFBQVFMLEtBQUtULGFBQWE7d0JBQzFCemMsT0FBTztvQkFDVDtnQkFDRjtnQkFDQW9KLEdBQUcsQ0FBQ2tVLElBQUksQ0FBQ3RkLEtBQUs7Z0JBQ2QsT0FBT29KO1lBQ1QsR0FBRyxDQUFDO1lBRUosTUFBTW9VLGFBQWE3SixPQUFPbUIsTUFBTSxDQUFDdUksY0FDOUIxVyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRTdHLEtBQUssR0FBRzRHLEVBQUU1RyxLQUFLLEVBQ2hDdkYsS0FBSyxDQUFDLEdBQUc7WUFFWixPQUFPO2dCQUNMdWlCO2dCQUNBQztnQkFDQUU7Z0JBQ0FDO2dCQUNBSTtZQUNGO1FBRUYsRUFBRSxPQUFPNWxCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7WUFDdkQsT0FBTztnQkFDTG9sQixZQUFZO2dCQUNaQyxZQUFZO2dCQUNaRSxlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCSSxZQUFZLEVBQUU7WUFDaEI7UUFDRjtJQUNGO0FBQ0YsRUFBQztBQUVELDRDQUE0QztBQUNyQyxNQUFNQyxtQkFBbUI7SUFDOUIsd0NBQXdDO0lBQ3hDLE1BQU1DLGtCQUFpQnhsQixJQUFVLEVBQUUrZixPQUlsQztRQUNDLElBQUk7WUFDRixJQUFJbFksUUFBUTdJLFNBQ1RPLElBQUksQ0FBQyxpQkFDTGtJLE1BQU0sQ0FBRSwwV0FtQlJjLEVBQUUsQ0FBQyxXQUFXdkksS0FBS08sRUFBRSxFQUNyQjRILEtBQUssQ0FBQyxjQUFjO2dCQUFFQyxXQUFXO1lBQU07WUFFMUMsK0JBQStCO1lBQy9CLElBQUkyWCxvQkFBQUEsOEJBQUFBLFFBQVMwRixVQUFVLEVBQUU7Z0JBQ3ZCNWQsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLFFBQVE7WUFDM0I7WUFFQSxtQkFBbUI7WUFDbkIsSUFBSXdYLG9CQUFBQSw4QkFBQUEsUUFBUzdRLElBQUksRUFBRTtnQkFDakJySCxRQUFRQSxNQUFNVSxFQUFFLENBQUMsUUFBUXdYLFFBQVE3USxJQUFJO1lBQ3ZDO1lBRUEsUUFBUTtZQUNSLElBQUk2USxvQkFBQUEsOEJBQUFBLFFBQVNyWSxLQUFLLEVBQUU7Z0JBQ2xCRyxRQUFRQSxNQUFNSCxLQUFLLENBQUNxWSxRQUFRclksS0FBSztZQUNuQztZQUVBLE1BQU0sRUFBRXJJLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTW1JO1lBRTlCLElBQUluSSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtnQkFDaEQsTUFBTUE7WUFDUjtZQUVBLE9BQU8sQ0FBQ0wsUUFBUSxFQUFFLEVBQUU4QyxHQUFHLENBQUN1akIsQ0FBQUEsZUFBaUI7b0JBQ3ZDLEdBQUdBLFlBQVk7b0JBQ2Ysa0NBQWtDO29CQUNsQ2pmLFFBQVFpZixhQUFhamYsTUFBTSxJQUFJMkMsTUFBTUMsT0FBTyxDQUFDcWMsYUFBYWpmLE1BQU0sS0FBS2lmLGFBQWFqZixNQUFNLENBQUM5RSxNQUFNLEdBQUcsSUFDOUYrakIsYUFBYWpmLE1BQU0sQ0FBQyxFQUFFLEdBQ3RCaWYsYUFBYWpmLE1BQU0sSUFBSSxDQUFDMkMsTUFBTUMsT0FBTyxDQUFDcWMsYUFBYWpmLE1BQU0sSUFDekRpZixhQUFhamYsTUFBTSxHQUNuQnRDO2dCQUNOO1FBRUYsRUFBRSxPQUFPekUsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSw4Q0FBOEM7SUFDOUMsTUFBTWltQixnQkFBZTNsQixJQUFVO1FBQzdCLElBQUk7WUFDRixNQUFNLEVBQUU4SCxLQUFLLEVBQUVwSSxLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUM1Qk8sSUFBSSxDQUFDLGlCQUNMa0ksTUFBTSxDQUFDLEtBQUs7Z0JBQUVLLE9BQU87Z0JBQVM2TyxNQUFNO1lBQUssR0FDekNwTyxFQUFFLENBQUMsV0FBV3ZJLEtBQUtPLEVBQUUsRUFDckJnSSxFQUFFLENBQUMsUUFBUTtZQUVkLElBQUk3SSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsOENBQThDQTtnQkFDNUQsTUFBTUE7WUFDUjtZQUVBLE9BQU9vSSxTQUFTO1FBQ2xCLEVBQUUsT0FBT3BJLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsT0FBTztRQUNUO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsTUFBTWttQixZQUFXQyxjQUFzQjtRQUNyQyxJQUFJO1lBQ0YsTUFBTSxFQUFFbm1CLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVN1ZixHQUFHLENBQUMsNkJBQTZCO2dCQUNoRXVILGlCQUFpQkQ7WUFDbkI7WUFFQSxJQUFJbm1CLE9BQU87Z0JBQ1RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUNyRCxNQUFNQTtZQUNSO1FBRUYsRUFBRSxPQUFPQSxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLGtEQUFrRDtJQUNsRCxNQUFNcW1CLGVBQWMvbEIsSUFBVTtRQUM1QixJQUFJO1lBQ0YsTUFBTSxFQUFFWCxJQUFJLEVBQUVLLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQVN1ZixHQUFHLENBQUM7WUFFM0MsSUFBSTdlLE9BQU87Z0JBQ1RDLFFBQVFELEtBQUssQ0FBQyxrREFBa0RBO2dCQUNoRSxNQUFNQTtZQUNSO1lBRUEsT0FBT0wsUUFBUTtRQUNqQixFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7WUFDekMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1zbUIsb0JBQW1CTixZQUFxRDtRQUM1RSxJQUFJO1lBQ0YsTUFBTSxFQUFFcm1CLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxpQkFDTHdLLE1BQU0sQ0FBQztnQkFBQzJiO2FBQWEsRUFDckJqZSxNQUFNLEdBQ051QyxNQUFNO1lBRVQsSUFBSXRLLE9BQU87Z0JBQ1RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBbUNBO2dCQUNqRCxNQUFNQTtZQUNSO1lBRUEsT0FBT0w7UUFDVCxFQUFFLE9BQU9LLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU11bUIsb0JBQW1CSixjQUFzQjtRQUM3QyxJQUFJO1lBQ0YsTUFBTSxFQUFFbm1CLEtBQUssRUFBRSxHQUFHLE1BQU1WLFNBQ3JCTyxJQUFJLENBQUMsaUJBQ0xtTSxNQUFNLEdBQ05uRCxFQUFFLENBQUMsTUFBTXNkO1lBRVosSUFBSW5tQixPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtnQkFDaEQsTUFBTUE7WUFDUjtRQUVGLEVBQUUsT0FBT0EsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSw4QkFBOEI7SUFDOUIsTUFBTXdtQjtRQUNKLElBQUk7WUFDRixNQUFNLEVBQUV4bUIsS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FBU3VmLEdBQUcsQ0FBQztZQUVyQyxJQUFJN2UsT0FBTztnQkFDVEMsUUFBUUQsS0FBSyxDQUFDLDJDQUEyQ0E7Z0JBQ3pELE1BQU1BO1lBQ1I7UUFFRixFQUFFLE9BQU9BLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsaURBQWlEO0lBQ2pELE1BQU15bUIsbUJBQWtCbm1CLElBQVU7UUFDaEMsSUFBSTtZQUNGLE1BQU1tTyxRQUFRLElBQUk3TixPQUFPNEUsV0FBVyxHQUFHM0QsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBRXBELE1BQU0sRUFBRWxDLElBQUksRUFBRUssS0FBSyxFQUFFLEdBQUcsTUFBTVYsU0FDM0JPLElBQUksQ0FBQyxpQkFDTGtJLE1BQU0sQ0FBRSwwV0FtQlJjLEVBQUUsQ0FBQyxXQUFXdkksS0FBS08sRUFBRSxFQUNyQmdJLEVBQUUsQ0FBQyxRQUFRLFlBQ1hELEdBQUcsQ0FBQyxjQUFjLEdBQVMsT0FBTjZGLE9BQU0sbUJBQzNCZ0UsRUFBRSxDQUFDLGNBQWMsR0FBUyxPQUFOaEUsT0FBTSxtQkFDMUJoRyxLQUFLLENBQUMsY0FBYztnQkFBRUMsV0FBVztZQUFLO1lBRXpDLElBQUkxSSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsK0NBQStDQTtnQkFDN0QsTUFBTUE7WUFDUjtZQUVBLE9BQU8sQ0FBQ0wsUUFBUSxFQUFFLEVBQUU4QyxHQUFHLENBQUN1akIsQ0FBQUEsZUFBaUI7b0JBQ3ZDLEdBQUdBLFlBQVk7b0JBQ2ZqZixRQUFRaWYsYUFBYWpmLE1BQU0sSUFBSTJDLE1BQU1DLE9BQU8sQ0FBQ3FjLGFBQWFqZixNQUFNLEtBQUtpZixhQUFhamYsTUFBTSxDQUFDOUUsTUFBTSxHQUFHLElBQzlGK2pCLGFBQWFqZixNQUFNLENBQUMsRUFBRSxHQUN0QmlmLGFBQWFqZixNQUFNLElBQUksQ0FBQzJDLE1BQU1DLE9BQU8sQ0FBQ3FjLGFBQWFqZixNQUFNLElBQ3pEaWYsYUFBYWpmLE1BQU0sR0FDbkJ0QztnQkFDTjtRQUVGLEVBQUUsT0FBT3pFLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLDBEQUEwRDtJQUMxRCxNQUFNMG1CO1FBQ0osSUFBSTtZQUNGLE1BQU0sRUFBRTFtQixLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTdWYsR0FBRyxDQUFDO1lBRXJDLElBQUk3ZSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsZ0RBQWdEQTtnQkFDOUQsTUFBTUE7WUFDUjtRQUVGLEVBQUUsT0FBT0EsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNMm1CO1FBQ0osSUFBSTtZQUNGLE1BQU0sRUFBRTNtQixLQUFLLEVBQUUsR0FBRyxNQUFNVixTQUFTdWYsR0FBRyxDQUFDO1lBRXJDLElBQUk3ZSxPQUFPO2dCQUNUQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtnQkFDM0QsTUFBTUE7WUFDUjtRQUVGLEVBQUUsT0FBT0EsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSx5Q0FBeUM7SUFDekM0bUIsMEJBQXlCelQsTUFBYyxFQUFFN0YsUUFBOEM7UUFDckYsT0FBT2hPLFNBQ0ppTyxPQUFPLENBQUMsaUJBQXdCLE9BQVA0RixTQUN6QjNGLEVBQUUsQ0FBQyxvQkFDRjtZQUNFQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsT0FBTztZQUNQN0wsUUFBUSxjQUFxQixPQUFQcVI7UUFDeEIsR0FDQSxDQUFDcEY7WUFDQ1QsU0FBU1MsUUFBUUcsR0FBRztRQUN0QixHQUVETixTQUFTO0lBQ2Q7QUFDRixFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGtrYWNwXFxEZXNrdG9wXFxTcGVjdHJlc0dyb3VwQ1JNXFxkYXNoYm9hcmRcXGxpYlxcc3VwYWJhc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xyXG5cclxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgJ2h0dHBzOi8vcGtodWdnZGtjZ2xpY2doZ3hpeXAuc3VwYWJhc2UuY28nXHJcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIHx8ICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcGMzTWlPaUp6ZFhCaFltRnpaU0lzSW5KbFppSTZJbkJyYUhWbloyUnJZMmRzYVdObmFHZDRhWGx3SWl3aWNtOXNaU0k2SW1GdWIyNGlMQ0pwWVhRaU9qRTNORGs1TVRFd056RXNJbVY0Y0NJNk1qQTJOVFE0TnpBM01YMC5MYld0Yi1tb2RSRGx2bmtHRjVJc3dSSGUxbEpwZDR6Q01na1EzX0UwUVFrJ1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXHJcblxyXG4vLyBGdW5rY2phIHBvbW9jbmljemEgZG8gZ2VuZXJvd2FuaWEgcG9wcmF3bnljaCBVUkwtaSBhdmF0YXLDs3cgeiBTdXBhYmFzZSBTdG9yYWdlXHJcbmV4cG9ydCBjb25zdCBnZXRBdmF0YXJVcmwgPSAoYXZhdGFyVXJsPzogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gIGlmICghYXZhdGFyVXJsKSByZXR1cm4gbnVsbFxyXG4gIFxyXG4gIC8vIEplxZtsaSB0byBqdcW8IHBlxYJueSBVUkwgKHphY3p5bmEgc2nEmSBvZCBodHRwKSwgendyw7PEhyBiZXogem1pYW5cclxuICBpZiAoYXZhdGFyVXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xyXG4gICAgcmV0dXJuIGF2YXRhclVybFxyXG4gIH1cclxuICBcclxuICAvLyBKZcWbbGkgdG8gxZtjaWXFvGthIHcgYnVja2V0J3UgKHphd2llcmEgZm9sZGVyKSwgd3lnZW5lcnVqIHB1YmxpY3pueSBVUkxcclxuICBpZiAoYXZhdGFyVXJsLmluY2x1ZGVzKCcvJykpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAgIC5mcm9tKCdhdmF0YXJzJylcclxuICAgICAgICAuZ2V0UHVibGljVXJsKGF2YXRhclVybClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBkYXRhLnB1YmxpY1VybFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQsWCxIVkIGdlbmVyb3dhbmlhIFVSTCBhdmF0YXJhOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBGYWxsYmFjayAtIHByYXdkb3BvZG9ibmllIG5pZXBvcHJhd255IGZvcm1hdFxyXG4gIGNvbnNvbGUud2FybignTmllcm96cG96bmFueSBmb3JtYXQgYXZhdGFyX3VybDonLCBhdmF0YXJVcmwpXHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuLy8gU3RvcmFnZSBBUEkgZGxhIHBsaWvDs3cgQ1NWXHJcbmV4cG9ydCBjb25zdCBzdG9yYWdlQXBpID0ge1xyXG4gIC8vIFVwbG9hZCBwbGlrdSBDU1YgZG8gYnVja2V0XHJcbiAgYXN5bmMgdXBsb2FkQ1NWKGZpbGU6IEZpbGUsIHVzZXI6IFVzZXIpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gT2N6eXN6Y3plbmllIG5hend5IHBsaWt1IHogcHJvYmxlbWF0eWN6bnljaCB6bmFrw7N3XHJcbiAgICAgIGNvbnN0IGNsZWFuRmlsZU5hbWUgPSBmaWxlLm5hbWVcclxuICAgICAgICAucmVwbGFjZSgvW15hLXpBLVowLTkuLV0vZywgJ18nKSAvLyBaYXN0xIVwIHdzenlzdGtpZSB6bmFraSBzcGVjamFsbmUgcG9ka3JlxZtsZW5pYW1pXHJcbiAgICAgICAgLnJlcGxhY2UoL197Mix9L2csICdfJykgLy8gWmFtaWXFhCB3aWVsb2tyb3RuZSBwb2RrcmXFm2xlbmlhIG5hIHBvamVkeW5jemVcclxuICAgICAgICAucmVwbGFjZSgvXl8rfF8rJC9nLCAnJykgLy8gVXN1xYQgcG9ka3JlxZtsZW5pYSB6IHBvY3rEhXRrdSBpIGtvxYRjYVxyXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpIC8vIE1hxYJlIGxpdGVyeSBkbGEgY29uc2lzdGVuY3lcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7dXNlci5pZH1fJHtEYXRlLm5vdygpfV8ke2NsZWFuRmlsZU5hbWV9YFxyXG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGBjc3YtaW1wb3J0cy8ke2ZpbGVOYW1lfWBcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OBIFVwbG9hZGluZyBDU1Y6ICR7ZmlsZVBhdGh9YClcclxuICAgICAgY29uc29sZS5sb2coYPCfk4EgT3JpZ2luYWwgZmlsZW5hbWU6ICR7ZmlsZS5uYW1lfWApXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OBIENsZWFuZWQgZmlsZW5hbWU6ICR7Y2xlYW5GaWxlTmFtZX1gKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAgIC5mcm9tKCdjc3YtZmlsZXMnKVxyXG4gICAgICAgIC51cGxvYWQoZmlsZVBhdGgsIGZpbGUsIHtcclxuICAgICAgICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxyXG4gICAgICAgICAgdXBzZXJ0OiBmYWxzZVxyXG4gICAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3RvcmFnZSB1cGxvYWQgZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCxYLEhWQgdXBsb2FkdTogJHtlcnJvci5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmlsZSB1cGxvYWRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YS5wYXRoKVxyXG4gICAgICByZXR1cm4gZGF0YS5wYXRoXHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFVwbG9hZCBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBQb2JpZXJ6IHB1YmxpY3pueSBVUkwgcGxpa3VcclxuICBnZXRQdWJsaWNVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHsgZGF0YSB9ID0gc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnY3N2LWZpbGVzJylcclxuICAgICAgLmdldFB1YmxpY1VybChwYXRoKVxyXG4gICAgXHJcbiAgICByZXR1cm4gZGF0YS5wdWJsaWNVcmxcclxuICB9LFxyXG4gIFxyXG4gIC8vIFVzdcWEIHBsaWsgeiBidWNrZXRcclxuICBhc3luYyBkZWxldGVGaWxlKHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Uuc3RvcmFnZVxyXG4gICAgICAuZnJvbSgnY3N2LWZpbGVzJylcclxuICAgICAgLnJlbW92ZShbcGF0aF0pXHJcbiAgICBcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmlsZSBkZWxldGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCxYLEhWQgdXN1d2FuaWEgcGxpa3U6ICR7ZXJyb3IubWVzc2FnZX1gKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ1NWIEltcG9ydCBBUElcclxuZXhwb3J0IGNvbnN0IGNzdkltcG9ydEFwaSA9IHtcclxuICAvLyBQYXJzdWogQ1NWIGkgendyw7PEhyBkYW5lXHJcbiAgcGFyc2VDU1YoY3N2VGV4dDogc3RyaW5nKTogeyBoZWFkZXJzOiBzdHJpbmdbXSwgcm93czogc3RyaW5nW11bXSB9IHtcclxuICAgIGNvbnN0IGxpbmVzID0gY3N2VGV4dC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKVxyXG4gICAgXHJcbiAgICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsaWsgQ1NWIGplc3QgcHVzdHkgbHViIHphd2llcmEgdHlsa28gbmFnxYLDs3draScpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFBhcnNvd2FuaWUgeiBvYnPFgnVnxIUgY3VkenlzxYJvd8Ozd1xyXG4gICAgY29uc3QgcGFyc2VDU1ZMaW5lID0gKGxpbmU6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXHJcbiAgICAgIGxldCBjdXJyZW50ID0gJydcclxuICAgICAgbGV0IGluUXVvdGVzID0gZmFsc2VcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2ldXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcclxuICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzXHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSlcclxuICAgICAgICAgIGN1cnJlbnQgPSAnJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdXJyZW50ICs9IGNoYXJcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxyXG4gICAgICByZXR1cm4gcmVzdWx0Lm1hcChjZWxsID0+IGNlbGwucmVwbGFjZSgvXlwifFwiJC9nLCAnJykpIC8vIFVzdcWEIGN1ZHp5c8WCb3d5XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUNTVkxpbmUobGluZXNbMF0pXHJcbiAgICBjb25zdCByb3dzID0gbGluZXMuc2xpY2UoMSkubWFwKHBhcnNlQ1NWTGluZSlcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgaGVhZGVycywgcm93cyB9XHJcbiAgfSxcclxuICBcclxuICAvLyBNYXB1aiBuYWfFgsOzd2tpIENTViBuYSBwb2xhIGJhenkgZGFueWNoXHJcbiAgbWFwSGVhZGVycyhoZWFkZXJzOiBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xyXG4gICAgY29uc3QgbWFwcGluZzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcbiAgICBcclxuICAgIGNvbnN0IGZpZWxkTWFwcGluZ3MgPSBbXHJcbiAgICAgIHsgZmllbGRzOiBbJ2ZpcnN0X25hbWUnLCAnaW1pxJknLCAnbmFtZScsICdmaXJzdE5hbWUnXSwgZGJGaWVsZDogJ2ZpcnN0X25hbWUnIH0sXHJcbiAgICAgIHsgZmllbGRzOiBbJ2xhc3RfbmFtZScsICduYXp3aXNrbycsICdzdXJuYW1lJywgJ2xhc3ROYW1lJ10sIGRiRmllbGQ6ICdsYXN0X25hbWUnIH0sXHJcbiAgICAgIHsgZmllbGRzOiBbJ2NvbXBhbnlfbmFtZScsICdmaXJtYScsICdjb21wYW55JywgJ2NvbXBhbnlOYW1lJywgJ25hendhJ10sIGRiRmllbGQ6ICdjb21wYW55X25hbWUnIH0sXHJcbiAgICAgIHsgZmllbGRzOiBbJ25pcCcsICd0YXhfaWQnLCAndGF4SWQnXSwgZGJGaWVsZDogJ25pcCcgfSxcclxuICAgICAgeyBmaWVsZHM6IFsncGhvbmUnLCAndGVsZWZvbicsICd0ZWxlcGhvbmUnXSwgZGJGaWVsZDogJ3Bob25lJyB9LFxyXG4gICAgICB7IGZpZWxkczogWydlbWFpbCcsICdlLW1haWwnLCAnbWFpbCddLCBkYkZpZWxkOiAnZW1haWwnIH0sXHJcbiAgICAgIHsgZmllbGRzOiBbJ3dlYnNpdGUnLCAnd3d3JywgJ3N0cm9uYScsICd1cmwnXSwgZGJGaWVsZDogJ3dlYnNpdGUnIH0sXHJcbiAgICAgIHsgZmllbGRzOiBbJ25vdGVzJywgJ25vdGF0a2EnLCAnbm90ZScsICdjb21tZW50J10sIGRiRmllbGQ6ICdub3RlcycgfSxcclxuICAgICAgeyBmaWVsZHM6IFsnc3RhdHVzJ10sIGRiRmllbGQ6ICdzdGF0dXMnIH1cclxuICAgIF1cclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBmaWVsZE1hcHBpbmcgb2YgZmllbGRNYXBwaW5ncykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCkudHJpbSgpXHJcbiAgICAgICAgaWYgKGZpZWxkTWFwcGluZy5maWVsZHMuc29tZShmaWVsZCA9PiBoZWFkZXIuaW5jbHVkZXMoZmllbGQpKSkge1xyXG4gICAgICAgICAgbWFwcGluZ1tmaWVsZE1hcHBpbmcuZGJGaWVsZF0gPSBpXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbWFwcGluZ1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gV2FsaWR1aiB3eW1hZ2FuZSBwb2xhXHJcbiAgdmFsaWRhdGVSZXF1aXJlZEZpZWxkcyhtYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTogdm9pZCB7XHJcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFsnY29tcGFueV9uYW1lJ11cclxuICAgIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gIShmaWVsZCBpbiBtYXBwaW5nKSlcclxuICAgIFxyXG4gICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJyYWsgd3ltYWdhbnljaCBrb2x1bW46ICR7bWlzc2luZ0ZpZWxkcy5qb2luKCcsICcpfS4gV3ltYWdhbmU6IEZpcm1hL05hendhYClcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIC8vIFNwcmF3ZMW6IGRvc3TEmXBuZSBrb2x1bW55IGkgcG9rYcW8IGluZm9ybWFjamVcclxuICBhbmFseXplQ29sdW1ucyhtYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBoZWFkZXJzOiBzdHJpbmdbXSk6IHsgZm91bmQ6IHN0cmluZ1tdLCBtaXNzaW5nOiBzdHJpbmdbXSwgb3B0aW9uYWw6IHN0cmluZ1tdIH0ge1xyXG4gICAgY29uc3QgYWxsUG9zc2libGVGaWVsZHMgPSBbXHJcbiAgICAgIHsgZmllbGQ6ICdmaXJzdF9uYW1lJywgZGlzcGxheU5hbWU6ICdJbWnEmScsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgICB7IGZpZWxkOiAnbGFzdF9uYW1lJywgZGlzcGxheU5hbWU6ICdOYXp3aXNrbycsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgICB7IGZpZWxkOiAnY29tcGFueV9uYW1lJywgZGlzcGxheU5hbWU6ICdGaXJtYS9OYXp3YScsIHJlcXVpcmVkOiB0cnVlIH0sXHJcbiAgICAgIHsgZmllbGQ6ICdwaG9uZScsIGRpc3BsYXlOYW1lOiAnVGVsZWZvbicsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgICB7IGZpZWxkOiAnZW1haWwnLCBkaXNwbGF5TmFtZTogJ0VtYWlsJywgcmVxdWlyZWQ6IGZhbHNlIH0sXHJcbiAgICAgIHsgZmllbGQ6ICduaXAnLCBkaXNwbGF5TmFtZTogJ05JUCcsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgICB7IGZpZWxkOiAnd2Vic2l0ZScsIGRpc3BsYXlOYW1lOiAnU3Ryb25hIFdXVycsIHJlcXVpcmVkOiBmYWxzZSB9LFxyXG4gICAgICB7IGZpZWxkOiAnbm90ZXMnLCBkaXNwbGF5TmFtZTogJ05vdGF0a2knLCByZXF1aXJlZDogZmFsc2UgfSxcclxuICAgICAgeyBmaWVsZDogJ3N0YXR1cycsIGRpc3BsYXlOYW1lOiAnU3RhdHVzJywgcmVxdWlyZWQ6IGZhbHNlIH1cclxuICAgIF1cclxuICAgIFxyXG4gICAgY29uc3QgZm91bmQ6IHN0cmluZ1tdID0gW11cclxuICAgIGNvbnN0IG1pc3Npbmc6IHN0cmluZ1tdID0gW11cclxuICAgIGNvbnN0IG9wdGlvbmFsOiBzdHJpbmdbXSA9IFtdXHJcbiAgICBcclxuICAgIGFsbFBvc3NpYmxlRmllbGRzLmZvckVhY2goKHsgZmllbGQsIGRpc3BsYXlOYW1lLCByZXF1aXJlZCB9KSA9PiB7XHJcbiAgICAgIGlmIChmaWVsZCBpbiBtYXBwaW5nKSB7XHJcbiAgICAgICAgZm91bmQucHVzaChkaXNwbGF5TmFtZSlcclxuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlZCkge1xyXG4gICAgICAgIG1pc3NpbmcucHVzaChkaXNwbGF5TmFtZSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcHRpb25hbC5wdXNoKGRpc3BsYXlOYW1lKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4geyBmb3VuZCwgbWlzc2luZywgb3B0aW9uYWwgfVxyXG4gIH0sXHJcbiAgXHJcbiAgLy8gUHJ6ZWtzenRhxYLEhyB3aWVyc3ogQ1NWIG5hIG9iaWVrdCBrbGllbnRhXHJcbiAgcm93VG9DbGllbnQocm93OiBzdHJpbmdbXSwgbWFwcGluZzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgdXNlcjogVXNlciwgbG9jYXRpb25JZD86IHN0cmluZyk6IE9taXQ8Q2xpZW50LCAnaWQnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnPiB7XHJcbiAgICBjb25zdCBnZXRGaWVsZCA9IChmaWVsZDogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IHN0cmluZyA9ICdicmFrIGluZm9ybWFjamknKTogc3RyaW5nID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSBtYXBwaW5nW2ZpZWxkXVxyXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IChyb3dbaW5kZXhdIHx8ICcnKS50cmltKClcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFdhbGlkYWNqYSBzdGF0dXN1XHJcbiAgICBjb25zdCByYXdTdGF0dXMgPSBnZXRGaWVsZCgnc3RhdHVzJywgJ2NhbnZhcycpLnRvTG93ZXJDYXNlKClcclxuICAgIGNvbnN0IHZhbGlkU3RhdHVzZXMgPSBbJ2NhbnZhcycsICdicmFrX2tvbnRha3R1JywgJ25pZV96YWludGVyZXNvd2FueScsICd6ZGVuZXJ3b3dhbnknLCAnYW50eXNhbGUnLCAnc2FsZScsICckJCddIGFzIGNvbnN0XHJcbiAgICBjb25zdCBzdGF0dXMgPSB2YWxpZFN0YXR1c2VzLmluY2x1ZGVzKHJhd1N0YXR1cyBhcyBhbnkpID8gcmF3U3RhdHVzIGFzIENsaWVudFsnc3RhdHVzJ10gOiAnY2FudmFzJ1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmaXJzdF9uYW1lOiBnZXRGaWVsZCgnZmlyc3RfbmFtZScpLCAvLyBPcGNqb25hbG5lIC0gbW/FvGUgYnnEhyBcImJyYWsgaW5mb3JtYWNqaVwiXHJcbiAgICAgIGxhc3RfbmFtZTogZ2V0RmllbGQoJ2xhc3RfbmFtZScpLCAvLyBPcGNqb25hbG5lIC0gbW/FvGUgYnnEhyBcImJyYWsgaW5mb3JtYWNqaVwiXHJcbiAgICAgIGNvbXBhbnlfbmFtZTogZ2V0RmllbGQoJ2NvbXBhbnlfbmFtZScsICcnKSwgLy8gV3ltYWdhbmUgLSBuaWUgbW/FvGUgYnnEhyBcImJyYWsgaW5mb3JtYWNqaVwiXHJcbiAgICAgIG5pcDogZ2V0RmllbGQoJ25pcCcpLFxyXG4gICAgICBwaG9uZTogZ2V0RmllbGQoJ3Bob25lJyksXHJcbiAgICAgIGVtYWlsOiBnZXRGaWVsZCgnZW1haWwnKSxcclxuICAgICAgd2Vic2l0ZTogZ2V0RmllbGQoJ3dlYnNpdGUnKSxcclxuICAgICAgbm90ZXM6IGdldEZpZWxkKCdub3RlcycpLFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIGVkaXRlZF9ieTogdXNlci5pZCxcclxuICAgICAgZWRpdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIG93bmVyX2lkOiB1c2VyLmlkLFxyXG4gICAgICBsb2NhdGlvbl9pZDogbG9jYXRpb25JZCB8fCB1c2VyLmxvY2F0aW9uX2lkLCAvLyBVxbx5aiB3eWJyYW5laiBsb2thbGl6YWNqaSBsdWIgbG9rYWxpemFjamkgdcW8eXRrb3duaWthXHJcbiAgICAgIGxhc3RfZWRpdGVkX2J5X25hbWU6IHVzZXIuZnVsbF9uYW1lLCAvLyBaYXBpc3ogZGFuZSBpbXBvcnRlcmFcclxuICAgICAgbGFzdF9lZGl0ZWRfYnlfYXZhdGFyX3VybDogdXNlci5hdmF0YXJfdXJsXHJcbiAgICB9XHJcbiAgfSxcclxuICBcclxuICAvLyBJbXBvcnQgcGXFgm5lZ28gQ1NWIGRvIGJhenkgZGFueWNoXHJcbiAgYXN5bmMgaW1wb3J0Q1NWKGZpbGU6IEZpbGUsIHVzZXI6IFVzZXIsIGxvY2F0aW9uSWQ/OiBzdHJpbmcsIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IHsgY3VycmVudDogbnVtYmVyLCB0b3RhbDogbnVtYmVyLCBzdGF0dXM6IHN0cmluZyB9KSA9PiB2b2lkKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IG51bWJlciwgZXJyb3JzOiBhbnlbXSB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBvblByb2dyZXNzPy4oeyBjdXJyZW50OiAwLCB0b3RhbDogMTAwLCBzdGF0dXM6ICdVcGxvYWRpbmcgcGxpa3UuLi4nIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyAxLiBVcGxvYWQgcGxpa3UgZG8gU3RvcmFnZVxyXG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGF3YWl0IHN0b3JhZ2VBcGkudXBsb2FkQ1NWKGZpbGUsIHVzZXIpXHJcbiAgICAgIFxyXG4gICAgICBvblByb2dyZXNzPy4oeyBjdXJyZW50OiAyMCwgdG90YWw6IDEwMCwgc3RhdHVzOiAnUGFyc293YW5pZSBDU1YuLi4nIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyAyLiBDenl0YW5pZSBpIHBhcnNvd2FuaWUgQ1NWXHJcbiAgICAgIGNvbnN0IGNzdlRleHQgPSBhd2FpdCBmaWxlLnRleHQoKVxyXG4gICAgICBjb25zdCB7IGhlYWRlcnMsIHJvd3MgfSA9IGNzdkltcG9ydEFwaS5wYXJzZUNTVihjc3ZUZXh0KVxyXG4gICAgICBcclxuICAgICAgb25Qcm9ncmVzcz8uKHsgY3VycmVudDogNDAsIHRvdGFsOiAxMDAsIHN0YXR1czogJ01hcG93YW5pZSBrb2x1bW4uLi4nIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyAzLiBNYXBvd2FuaWUgbmFnxYLDs3drw7N3XHJcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBjc3ZJbXBvcnRBcGkubWFwSGVhZGVycyhoZWFkZXJzKVxyXG4gICAgICBjc3ZJbXBvcnRBcGkudmFsaWRhdGVSZXF1aXJlZEZpZWxkcyhtYXBwaW5nKVxyXG4gICAgICBcclxuICAgICAgLy8gNC4gQW5hbGl6YSBkb3N0xJlwbnljaCBrb2x1bW5cclxuICAgICAgY29uc3QgY29sdW1uQW5hbHlzaXMgPSBjc3ZJbXBvcnRBcGkuYW5hbHl6ZUNvbHVtbnMobWFwcGluZywgaGVhZGVycylcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIENTViBIZWFkZXJzOicsIGhlYWRlcnMpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEZpZWxkIG1hcHBpbmc6JywgbWFwcGluZylcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUm93cyB0byBpbXBvcnQ6Jywgcm93cy5sZW5ndGgpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgWm5hbGV6aW9uZSBrb2x1bW55OicsIGNvbHVtbkFuYWx5c2lzLmZvdW5kKVxyXG4gICAgICBjb25zb2xlLmxvZygn4p2MIEJyYWt1asSFY2Ugd3ltYWdhbmU6JywgY29sdW1uQW5hbHlzaXMubWlzc2luZylcclxuICAgICAgY29uc29sZS5sb2coJ+KaqiBPcGNqb25hbG5lIChixJlkxIUgXCJicmFrIGluZm9ybWFjamlcIik6JywgY29sdW1uQW5hbHlzaXMub3B0aW9uYWwpXHJcbiAgICAgIFxyXG4gICAgICBvblByb2dyZXNzPy4oeyBjdXJyZW50OiA1MCwgdG90YWw6IDEwMCwgc3RhdHVzOiBgSW1wb3J0b3dhbmllICR7cm93cy5sZW5ndGh9IGtsaWVudMOzdy4uLmAgfSlcclxuICAgICAgXHJcbiAgICAgIC8vIDQuIEltcG9ydCB3aWVyc3p5IGRvIGJhenlcclxuICAgICAgY29uc3QgcmVzdWx0cyA9IHsgc3VjY2VzczogMCwgZXJyb3JzOiBbXSBhcyBhbnlbXSB9XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qgcm93ID0gcm93c1tpXVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTcHJhd2TFuiBjenkgd2llcnN6IG5pZSBqZXN0IHB1c3R5XHJcbiAgICAgICAgICBpZiAocm93LmV2ZXJ5KGNlbGwgPT4gY2VsbC50cmltKCkgPT09ICcnKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBjbGllbnREYXRhID0gY3N2SW1wb3J0QXBpLnJvd1RvQ2xpZW50KHJvdywgbWFwcGluZywgdXNlciwgbG9jYXRpb25JZClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gV2FsaWRhY2phIHBvZHN0YXdvd3ljaCBkYW55Y2hcclxuICAgICAgICAgIGlmICghY2xpZW50RGF0YS5jb21wYW55X25hbWUgfHwgY2xpZW50RGF0YS5jb21wYW55X25hbWUudHJpbSgpID09PSAnJykge1xyXG4gICAgICAgICAgICByZXN1bHRzLmVycm9ycy5wdXNoKHtcclxuICAgICAgICAgICAgICByb3c6IGkgKyAyLCAvLyArMiBibyBsaWN6eW15IG9kIDEgaSBwb21pamFteSBuYWfFgsOzd2VrXHJcbiAgICAgICAgICAgICAgZXJyb3I6ICdCcmFrIHd5bWFnYW55Y2ggZGFueWNoOiBmaXJtYS9uYXp3YScsXHJcbiAgICAgICAgICAgICAgZGF0YTogcm93XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIERvZGFqIGtsaWVudGEgZG8gYmF6eVxyXG4gICAgICAgICAgYXdhaXQgY2xpZW50c0FwaS5jcmVhdGVDbGllbnQoY2xpZW50RGF0YSwgdXNlcilcclxuICAgICAgICAgIHJlc3VsdHMuc3VjY2VzcysrXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFrdHVhbGl6dWogcHJvZ3Jlc3NcclxuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gNTAgKyBNYXRoLmZsb29yKChpIC8gcm93cy5sZW5ndGgpICogNDApXHJcbiAgICAgICAgICBvblByb2dyZXNzPy4oeyBjdXJyZW50OiBwcm9ncmVzcywgdG90YWw6IDEwMCwgc3RhdHVzOiBgWmFpbXBvcnRvd2FubyAke3Jlc3VsdHMuc3VjY2Vzc30vJHtyb3dzLmxlbmd0aH0ga2xpZW50w7N3YCB9KVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBCxYLEhWQgaW1wb3J0dSB3aWVyc3phICR7aSArIDJ9OmAsIGVycm9yKVxyXG4gICAgICAgICAgcmVzdWx0cy5lcnJvcnMucHVzaCh7XHJcbiAgICAgICAgICAgIHJvdzogaSArIDIsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdOaWV6bmFueSBixYLEhWQnLFxyXG4gICAgICAgICAgICBkYXRhOiByb3dzW2ldXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgb25Qcm9ncmVzcz8uKHsgY3VycmVudDogOTUsIHRvdGFsOiAxMDAsIHN0YXR1czogJ0ZpbmFsaXpvd2FuaWUuLi4nIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyA1LiBPcGNqb25hbG5pZSB1c3XFhCBwbGlrIHogU3RvcmFnZSAobHViIHphY2hvd2FqIGRsYSBoaXN0b3JpaSlcclxuICAgICAgLy8gYXdhaXQgc3RvcmFnZUFwaS5kZWxldGVGaWxlKGZpbGVQYXRoKVxyXG4gICAgICBcclxuICAgICAgb25Qcm9ncmVzcz8uKHsgY3VycmVudDogMTAwLCB0b3RhbDogMTAwLCBzdGF0dXM6ICdaYWtvxYRjem9ubyEnIH0pXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEltcG9ydCB6YWtvxYRjem9ueTogJHtyZXN1bHRzLnN1Y2Nlc3N9IHN1a2NlcywgJHtyZXN1bHRzLmVycm9ycy5sZW5ndGh9IGLFgsSZZMOzd2ApXHJcbiAgICAgIHJldHVybiByZXN1bHRzXHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIENTViBJbXBvcnQgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gVHlweSBkbGEgYmF6eSBkYW55Y2ggemdvZG5pZSB6IEVUQVBFTSA1IGkgNiB6IFJFQURNRSArIFN0cnVrdHVyYURCLnR4dFxyXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudCB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIGZpcnN0X25hbWU6IHN0cmluZ1xyXG4gIGxhc3RfbmFtZTogc3RyaW5nXHJcbiAgY29tcGFueV9uYW1lOiBzdHJpbmdcclxuICBuaXA6IHN0cmluZ1xyXG4gIHBob25lOiBzdHJpbmdcclxuICBlbWFpbDogc3RyaW5nXHJcbiAgbm90ZXM6IHN0cmluZ1xyXG4gIHdlYnNpdGU6IHN0cmluZ1xyXG4gIHN0YXR1czogJ2NhbnZhcycgfCAnYnJha19rb250YWt0dScgfCAnbmllX3phaW50ZXJlc293YW55JyB8ICd6ZGVuZXJ3b3dhbnknIHwgJ2FudHlzYWxlJyB8ICdzYWxlJyB8ICckJCcgfCAnbm93eSdcclxuICBlZGl0ZWRfYnk6IHN0cmluZ1xyXG4gIGVkaXRlZF9hdDogc3RyaW5nXHJcbiAgb3duZXJfaWQ/OiBzdHJpbmcgLy8gRG9kYW5lIGRsYSBzeXN0ZW11IHVwcmF3bmllxYRcclxuICBsb2NhdGlvbl9pZD86IHN0cmluZyAvLyBEb2RhbmUgZGxhIHN5c3RlbXUgbG9rYWxpemFjamlcclxuICBjcmVhdGVkX2F0OiBzdHJpbmdcclxuICB1cGRhdGVkX2F0OiBzdHJpbmdcclxuICBzdGF0dXNfY2hhbmdlZF9hdD86IHN0cmluZyAvLyBDemFzIG9zdGF0bmllaiB6bWlhbnkgc3RhdHVzdVxyXG4gIGxhc3RfcGhvbmVfY2xpY2s/OiBzdHJpbmcgLy8gQ3phcyBvc3RhdG5pZWdvIGtsaWtuacSZY2lhIHcgdGVsZWZvblxyXG4gIGxhc3RfZWRpdGVkX2J5X25hbWU/OiBzdHJpbmcgLy8gUGXFgm5lIGltacSZIGkgbmF6d2lza28gb3N0YXRuaWVnbyBlZHl0b3JhXHJcbiAgbGFzdF9lZGl0ZWRfYnlfYXZhdGFyX3VybD86IHN0cmluZyAvLyBBdmF0YXIgVVJMIG9zdGF0bmllZ28gZWR5dG9yYVxyXG4gIG93bmVyPzoge1xyXG4gICAgaWQ6IHN0cmluZ1xyXG4gICAgZnVsbF9uYW1lOiBzdHJpbmdcclxuICAgIGVtYWlsOiBzdHJpbmdcclxuICAgIGF2YXRhcl91cmw/OiBzdHJpbmdcclxuICB9IC8vIEluZm9ybWFjamUgbyB3xYJhxZtjaWNpZWx1IGtsaWVudGFcclxuICBsb2NhdGlvbj86IExvY2F0aW9uIC8vIEluZm9ybWFjamUgbyBsb2thbGl6YWNqaSBrbGllbnRhXHJcbiAgcmVtaW5kZXI/OiB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuXHJcbiAgICBkYXRlOiBzdHJpbmdcclxuICAgIHRpbWU6IHN0cmluZ1xyXG4gICAgbm90ZTogc3RyaW5nXHJcbiAgfSAvLyBQcnp5cG9tbmllbmllIGRsYSBrbGllbnRhXHJcbn1cclxuXHJcbi8vIPCfmoAgTk9XWTogSW50ZXJmYWNlIGRsYSBwYWdpbm93YW55Y2ggd3luaWvDs3dcclxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0ZWRDbGllbnRzUmVzdWx0IHtcclxuICBjbGllbnRzOiBDbGllbnRbXVxyXG4gIHRvdGFsOiBudW1iZXJcclxuICBwYWdlOiBudW1iZXJcclxuICBwYWdlU2l6ZTogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlMb2cge1xyXG4gIGlkOiBzdHJpbmdcclxuICBjbGllbnRfaWQ6IHN0cmluZ1xyXG4gIGNoYW5nZWRfYnk6IHN0cmluZ1xyXG4gIGNoYW5nZV90eXBlOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZSdcclxuICBmaWVsZF9jaGFuZ2VkOiBzdHJpbmdcclxuICBvbGRfdmFsdWU/OiBzdHJpbmdcclxuICBuZXdfdmFsdWU/OiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG4vLyBJbnRlcmZlanMgZGxhIGxva2FsaXphY2ppL2tyYWrDs3dcclxuZXhwb3J0IGludGVyZmFjZSBMb2NhdGlvbiB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIG5hbWU6IHN0cmluZ1xyXG4gIGNvZGU6IHN0cmluZyAvLyAnUEwnLCAnU0snXHJcbiAgY3VycmVuY3k6IHN0cmluZyAvLyAnUExOJywgJ0VVUidcclxuICB0aW1lem9uZTogc3RyaW5nIC8vICdFdXJvcGUvV2Fyc2F3JywgJ0V1cm9wZS9CcmF0aXNsYXZhJ1xyXG4gIHJlZ2lvbj86IHN0cmluZ1xyXG4gIHByb2plY3RfbWFuYWdlcl9pZD86IHN0cmluZ1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xyXG4gIHByb2plY3RfbWFuYWdlcj86IHtcclxuICAgIGlkOiBzdHJpbmdcclxuICAgIGZ1bGxfbmFtZTogc3RyaW5nXHJcbiAgICBlbWFpbDogc3RyaW5nXHJcbiAgICBhdmF0YXJfdXJsPzogc3RyaW5nXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xyXG4gIGlkOiBzdHJpbmdcclxuICBlbWFpbDogc3RyaW5nXHJcbiAgZnVsbF9uYW1lOiBzdHJpbmdcclxuICByb2xlOiAnYWRtaW4nIHwgJ21hbmFnZXInIHwgJ3ByYWNvd25paycgfCAnc3plZicgfCAncHJvamVjdF9tYW5hZ2VyJyB8ICdqdW5pb3JfbWFuYWdlcidcclxuICBwaG9uZT86IHN0cmluZyBcclxuICBiaW8/OiBzdHJpbmcgXHJcbiAgYXZhdGFyX3VybD86IHN0cmluZyBcclxuICBsYW5ndWFnZT86ICdwbCcgfCAnZW4nIHwgJ3NrJ1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZ1xyXG4gIC8vIE5vd2UgcG9sYSBoaWVyYXJjaGljem5lIHogbWlncmFjamlcclxuICBsb2NhdGlvbl9pZD86IHN0cmluZ1xyXG4gIG1hbmFnZXJfaWQ/OiBzdHJpbmdcclxuICByb2xlX2hpZXJhcmNoeV9sZXZlbD86IG51bWJlclxyXG4gIHRlcnJpdG9yeT86IHN0cmluZ1xyXG4gIHN0YXJ0X2RhdGU/OiBzdHJpbmdcclxuICBpc19hY3RpdmU/OiBib29sZWFuXHJcbiAgLy8gUm96c3plcnpvbmUgaW5mb3JtYWNqZSBkbGEgSk9JTlxyXG4gIGxvY2F0aW9uPzogTG9jYXRpb25cclxuICBtYW5hZ2VyPzoge1xyXG4gICAgaWQ6IHN0cmluZ1xyXG4gICAgZnVsbF9uYW1lOiBzdHJpbmdcclxuICAgIGVtYWlsOiBzdHJpbmdcclxuICAgIGF2YXRhcl91cmw/OiBzdHJpbmdcclxuICB9XHJcbn1cclxuXHJcbi8vIEludGVyZmFjZSBkbGEgcG93aWFkb21pZcWEXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdXNlcl9pZDogc3RyaW5nXHJcbiAgY2xpZW50X2lkPzogc3RyaW5nXHJcbiAgdHlwZTogJ3JlbWluZGVyJyB8ICdhbnR5c2FsZV93YXJuaW5nJyB8ICdzeXN0ZW0nIHwgJ21hbnVhbCdcclxuICB0aXRsZTogc3RyaW5nXHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgcmVhZDogYm9vbGVhblxyXG4gIHVyZ2VudDogYm9vbGVhblxyXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nXHJcbiAgZXhwaXJlc19hdD86IHN0cmluZ1xyXG4gIC8vIFJvenN6ZXJ6b25lIGRhbmUgeiBKT0lOXHJcbiAgY2xpZW50Pzoge1xyXG4gICAgaWQ6IHN0cmluZ1xyXG4gICAgZmlyc3RfbmFtZTogc3RyaW5nXHJcbiAgICBsYXN0X25hbWU6IHN0cmluZ1xyXG4gICAgY29tcGFueV9uYW1lOiBzdHJpbmdcclxuICB9XHJcbn1cclxuXHJcbi8vIEludGVyZmVqcyBkbGEgaGlzdG9yaWkgem1pYW4geiBkb2RhdGtvd3ltaSBpbmZvcm1hY2phbWlcclxuZXhwb3J0IGludGVyZmFjZSBDbGllbnRIaXN0b3J5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgY2xpZW50X2lkOiBzdHJpbmdcclxuICBjaGFuZ2VkX2J5OiBzdHJpbmdcclxuICBjaGFuZ2VfdHlwZTogJ2NyZWF0ZScgfCAndXBkYXRlJyB8ICdkZWxldGUnXHJcbiAgZmllbGRfY2hhbmdlZDogc3RyaW5nXHJcbiAgb2xkX3ZhbHVlPzogc3RyaW5nXHJcbiAgbmV3X3ZhbHVlPzogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxuICBlZGl0b3JfbmFtZT86IHN0cmluZyAvLyBEb2RhbmUgZGxhIFVJXHJcbiAgZWRpdG9yX3JvbGU/OiBzdHJpbmcgLy8gRG9kYW5lIGRsYSBVSVxyXG4gIGVkaXRvcl9hdmF0YXI/OiBzdHJpbmcgLy8gRG9kYW5lIGRsYSBVSSAtIGF2YXRhciBlZHl0b3JhXHJcbn1cclxuXHJcbi8vIEZ1bmtjamUgc3ByYXdkemFuaWEgdXByYXduaWXFhCB6IGhpZXJhcmNoacSFIGkgbG9rYWxpemFjasSFXHJcbmV4cG9ydCBjb25zdCBwZXJtaXNzaW9uc0FwaSA9IHtcclxuICAvLyBTcHJhd2TFuiBjenkgdcW8eXRrb3duaWsgbW/FvGUgd2lkemllxIcga2xpZW50YSAoemdvZG5pZSB6IFJMUylcclxuICBjYW5WaWV3OiAoY2xpZW50OiBDbGllbnQsIHVzZXI6IFVzZXIpOiBib29sZWFuID0+IHtcclxuICAgIC8vIFN6ZWYgaSBhZG1pbiB3aWR6xIUgd3N6eXN0a29cclxuICAgIGlmIChbJ3N6ZWYnLCAnYWRtaW4nXS5pbmNsdWRlcyh1c2VyLnJvbGUpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNwcmF3ZMW6IGN6eSBrbGllbnQgamVzdCB3IHRlaiBzYW1laiBsb2thbGl6YWNqaSBjbyB1xbx5dGtvd25pa1xyXG4gICAgY29uc3Qgc2FtZUxvY2F0aW9uID0gY2xpZW50LmxvY2F0aW9uX2lkID09PSB1c2VyLmxvY2F0aW9uX2lkXHJcbiAgICBpZiAoIXNhbWVMb2NhdGlvbikge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIFxyXG4gICAgc3dpdGNoICh1c2VyLnJvbGUpIHtcclxuICAgICAgY2FzZSAncHJhY293bmlrJzpcclxuICAgICAgICAvLyBQcmFjb3duaWsgd2lkemkgdHlsa28gc3dvaWNoIGtsaWVudMOzdyB3IHN3b2plaiBsb2thbGl6YWNqaVxyXG4gICAgICAgIHJldHVybiBjbGllbnQub3duZXJfaWQgPT09IHVzZXIuaWQgfHwgXHJcbiAgICAgICAgICAgICAgIGNsaWVudC5vd25lcl9pZCA9PT0gbnVsbCB8fCBcclxuICAgICAgICAgICAgICAgY2xpZW50LmVkaXRlZF9ieSA9PT0gdXNlci5pZFxyXG4gICAgICBjYXNlICdqdW5pb3JfbWFuYWdlcic6XHJcbiAgICAgIGNhc2UgJ21hbmFnZXInOlxyXG4gICAgICBjYXNlICdwcm9qZWN0X21hbmFnZXInOlxyXG4gICAgICAgIC8vIE1lbmVkxbxlcm93aWUgd2lkesSFIHdzenlzdGtpY2gga2xpZW50w7N3IHcgc3dvamVqIGxva2FsaXphY2ppXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBTcHJhd2TFuiBjenkgdcW8eXRrb3duaWsgbW/FvGUgZWR5dG93YcSHIGtsaWVudGFcclxuICBjYW5FZGl0OiAoY2xpZW50OiBDbGllbnQsIHVzZXI6IFVzZXIpOiBib29sZWFuID0+IHtcclxuICAgIC8vIFRha2llIHNhbWUgcmVndcWCeSBqYWsgY2FuVmlld1xyXG4gICAgcmV0dXJuIHBlcm1pc3Npb25zQXBpLmNhblZpZXcoY2xpZW50LCB1c2VyKVxyXG4gIH0sXHJcblxyXG4gIC8vIFNwcmF3ZMW6IGN6eSB1xbx5dGtvd25payBtb8W8ZSB1c3VuxIXEhyBrbGllbnRhXHJcbiAgY2FuRGVsZXRlOiAoY2xpZW50OiBDbGllbnQsIHVzZXI6IFVzZXIpOiBib29sZWFuID0+IHtcclxuICAgIC8vIFN6ZWYgaSBhZG1pbiBtb2fEhSB1c3V3YcSHIHdzenlzdGtvXHJcbiAgICBpZiAoWydzemVmJywgJ2FkbWluJ10uaW5jbHVkZXModXNlci5yb2xlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNZW5lZMW8ZXJvd2llIG1vZ8SFIHVzdXdhxIcgdyBzd29qZWogbG9rYWxpemFjamlcclxuICAgIGlmIChbJ21hbmFnZXInLCAncHJvamVjdF9tYW5hZ2VyJywgJ2p1bmlvcl9tYW5hZ2VyJ10uaW5jbHVkZXModXNlci5yb2xlKSkge1xyXG4gICAgICByZXR1cm4gY2xpZW50LmxvY2F0aW9uX2lkID09PSB1c2VyLmxvY2F0aW9uX2lkXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFByYWNvd25pY3kgbmllIG1vZ8SFIHVzdXdhxIdcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0sXHJcblxyXG4gIC8vIFNwcmF3ZMW6IGN6eSB1xbx5dGtvd25payBtb8W8ZSBwcnp5cGlzeXdhxIcga2xpZW50w7N3XHJcbiAgY2FuQXNzaWduQ2xpZW50czogKHVzZXI6IFVzZXIpOiBib29sZWFuID0+IHtcclxuICAgIHJldHVybiBbJ21hbmFnZXInLCAncHJvamVjdF9tYW5hZ2VyJywgJ2p1bmlvcl9tYW5hZ2VyJywgJ3N6ZWYnLCAnYWRtaW4nXS5pbmNsdWRlcyh1c2VyLnJvbGUpXHJcbiAgfSxcclxuXHJcbiAgLy8gU3ByYXdkxbogY3p5IHXFvHl0a293bmlrIG1vxbxlIHptaWVuaWHEhyByb2xlIGlubnljaCB1xbx5dGtvd25pa8Ozd1xyXG4gIGNhbkNoYW5nZVJvbGVzOiAodXNlcjogVXNlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgcmV0dXJuIFsnc3plZicsICdhZG1pbiddLmluY2x1ZGVzKHVzZXIucm9sZSlcclxuICB9LFxyXG5cclxuICAvLyBTcHJhd2TFuiBjenkgdcW8eXRrb3duaWsgbW/FvGUgZG9zdMSZcCBkbyB6YWF3YW5zb3dhbnljaCByYXBvcnTDs3dcclxuICBjYW5BY2Nlc3NBZHZhbmNlZFJlcG9ydHM6ICh1c2VyOiBVc2VyKTogYm9vbGVhbiA9PiB7XHJcbiAgICByZXR1cm4gWydtYW5hZ2VyJywgJ3Byb2plY3RfbWFuYWdlcicsICdqdW5pb3JfbWFuYWdlcicsICdzemVmJywgJ2FkbWluJ10uaW5jbHVkZXModXNlci5yb2xlKVxyXG4gIH0sXHJcblxyXG4gIC8vIFNwcmF3ZMW6IGN6eSB1xbx5dGtvd25payBtb8W8ZSB3aWR6aWXEhyB3c3p5c3RraWUgbG9rYWxpemFjamVcclxuICBjYW5WaWV3QWxsTG9jYXRpb25zOiAodXNlcjogVXNlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgcmV0dXJuIFsnc3plZicsICdhZG1pbiddLmluY2x1ZGVzKHVzZXIucm9sZSlcclxuICB9LFxyXG5cclxuICAvLyBTcHJhd2TFuiBjenkgdcW8eXRrb3duaWsgbW/FvGUgZmlsdHJvd2HEhyBwbyBsb2thbGl6YWNqYWNoXHJcbiAgY2FuRmlsdGVyQnlMb2NhdGlvbjogKHVzZXI6IFVzZXIpOiBib29sZWFuID0+IHtcclxuICAgIHJldHVybiBbJ3Byb2plY3RfbWFuYWdlcicsICdqdW5pb3JfbWFuYWdlcicsICdzemVmJywgJ2FkbWluJ10uaW5jbHVkZXModXNlci5yb2xlKVxyXG4gIH0sXHJcblxyXG4gIC8vIFNwcmF3ZMW6IHBvemlvbSBoaWVyYXJjaGlpIC0gY3p5IHVzZXIxIG1vxbxlIHphcnrEhWR6YcSHIHVzZXIyXHJcbiAgY2FuTWFuYWdlVXNlcjogKHVzZXIxOiBVc2VyLCB1c2VyMjogVXNlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgLy8gQWRtaW4gbW/FvGUgemFyesSFZHphxIcgd3N6eXN0a2ltaVxyXG4gICAgaWYgKHVzZXIxLnJvbGUgPT09ICdhZG1pbicpIHJldHVybiB0cnVlXHJcbiAgICBcclxuICAgIC8vIFN6ZWYgbW/FvGUgemFyesSFZHphxIcgd3N6eXN0a2ltaSBvcHLDs2N6IGFkbWluw7N3XHJcbiAgICBpZiAodXNlcjEucm9sZSA9PT0gJ3N6ZWYnICYmIHVzZXIyLnJvbGUgIT09ICdhZG1pbicpIHJldHVybiB0cnVlXHJcbiAgICBcclxuICAgIC8vIElubmkgbW9nxIUgemFyesSFZHphxIcgdHlsa28gcG9kd8WCYWRueW1pIHcgdGVqIHNhbWVqIGxva2FsaXphY2ppXHJcbiAgICBjb25zdCBzYW1lTG9jYXRpb24gPSB1c2VyMS5sb2NhdGlvbl9pZCA9PT0gdXNlcjIubG9jYXRpb25faWRcclxuICAgIGNvbnN0IGhpZ2hlckluSGllcmFyY2h5ID0gKHVzZXIxLnJvbGVfaGllcmFyY2h5X2xldmVsIHx8IDk5KSA8ICh1c2VyMi5yb2xlX2hpZXJhcmNoeV9sZXZlbCB8fCA5OSlcclxuICAgIFxyXG4gICAgcmV0dXJuIHNhbWVMb2NhdGlvbiAmJiBoaWdoZXJJbkhpZXJhcmNoeVxyXG4gIH1cclxufVxyXG5cclxuLy8gSW50ZXJmZWpzIGRsYSBzbG90dSBjemFzb3dlZ28gdyBwbGFuaWUgZG5pYVxyXG5leHBvcnQgaW50ZXJmYWNlIERhaWx5U2NoZWR1bGVTbG90IHtcclxuICB0aW1lOiBzdHJpbmdcclxuICB0eXBlOiBzdHJpbmdcclxuICBjb2xvcjogc3RyaW5nXHJcbiAgc3RhcnRUaW1lOiBzdHJpbmdcclxuICBlbmRUaW1lOiBzdHJpbmdcclxuICBzdGF0dXNlczogc3RyaW5nW11cclxuICBjbGllbnRzOiBDbGllbnRXaXRoUmVtaW5kZXJbXVxyXG59XHJcblxyXG4vLyBJbnRlcmZlanMgZGxhIGtsaWVudGEgeiBwcnp5cG9tbmllbmlhbVxyXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudFdpdGhSZW1pbmRlciBleHRlbmRzIENsaWVudCB7XHJcbiAgcmVtaW5kZXI/OiB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuXHJcbiAgICBkYXRlOiBzdHJpbmdcclxuICAgIHRpbWU6IHN0cmluZ1xyXG4gICAgbm90ZTogc3RyaW5nXHJcbiAgfVxyXG59XHJcblxyXG4vLyBGdW5rY2plIEFQSSBkbGEga2xpZW50w7N3IHogc3lzdGVtZW0gdXByYXduaWXFhFxyXG5leHBvcnQgY29uc3QgY2xpZW50c0FwaSA9IHtcclxuICAvLyBGdW5rY2phIHRlc3Rvd2EgLSBwb2RzdGF3b3dlIHphcHl0YW5pZSBkbyBrbGllbnTDs3dcclxuICBhc3luYyB0ZXN0QmFzaWNRdWVyeSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFRlc3Rvd2UgemFweXRhbmllIGRvIHRhYmVsaSBjbGllbnRzLi4uJylcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmxpbWl0KDUpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnV3luaWsgdGVzdHUgLSBkYXRhOicsIGRhdGEpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdXeW5payB0ZXN0dSAtIGVycm9yOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQsWCxIVkIHRlc3Rvd2VnbyB6YXB5dGFuaWE6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IGtsaWVudMOzdyB6IGZpbHRyYW1pIHVwcmF3bmllxYRcclxuICAvLyDwn5qAIE5PV0U6IEZ1bmtjamEgeiBwYWdpbmFjasSFIHp3cmFjYWrEhWNhIG9iaWVrdCB6IG1ldGFkYW55bWlcclxuICBhc3luYyBnZXRDbGllbnRzUGFnaW5hdGVkKHVzZXI6IFVzZXIsIGZpbHRlcnM/OiB7IFxyXG4gICAgZGF0ZT86IHN0cmluZ1xyXG4gICAgc3RhdHVzPzogc3RyaW5nXHJcbiAgICBlbXBsb3llZT86IHN0cmluZyBcclxuICAgIHBhZ2U/OiBudW1iZXJcclxuICAgIHBhZ2VTaXplPzogbnVtYmVyXHJcbiAgICBzZWFyY2g/OiBzdHJpbmdcclxuICAgIGxvY2F0aW9uPzogc3RyaW5nXHJcbiAgICBzb3J0Qnk/OiBzdHJpbmdcclxuICAgIHNvcnREaXJlY3Rpb24/OiAnYXNjJyB8ICdkZXNjJ1xyXG4gIH0pOiBQcm9taXNlPFBhZ2luYXRlZENsaWVudHNSZXN1bHQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJvenBvY3p5bmFtIHBvYmllcmFuaWUga2xpZW50w7N3IGRsYSB1xbx5dGtvd25pa2E6JywgdXNlci5pZCwgdXNlci5yb2xlKVxyXG4gICAgICBcclxuICAgICAgLy8gVcW8eWogSk9JTiBhYnkgcG9icmHEhyBrbGllbnTDs3cgeiBkYW55bWkgd8WCYcWbY2ljaWVsaSBpIGxva2FsaXphY2ppIHcgamVkbnltIHphcHl0YW5pdVxyXG4gICAgICAvLyDwn5qAIE9QVFlNQUxJWkFDSkE6IFd5YmllcnogdHlsa28gbmllemLEmWRuZSBwb2xhICsgbG9rYWxpemFjamEgKyByZW1pbmRlclxyXG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgZmlyc3RfbmFtZSxcclxuICAgICAgICAgIGxhc3RfbmFtZSxcclxuICAgICAgICAgIGNvbXBhbnlfbmFtZSxcclxuICAgICAgICAgIG5pcCxcclxuICAgICAgICAgIHBob25lLFxyXG4gICAgICAgICAgZW1haWwsXHJcbiAgICAgICAgICB3ZWJzaXRlLFxyXG4gICAgICAgICAgc3RhdHVzLFxyXG4gICAgICAgICAgbm90ZXMsXHJcbiAgICAgICAgICByZW1pbmRlcixcclxuICAgICAgICAgIG93bmVyX2lkLFxyXG4gICAgICAgICAgbG9jYXRpb25faWQsXHJcbiAgICAgICAgICBlZGl0ZWRfYnksXHJcbiAgICAgICAgICBlZGl0ZWRfYXQsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgICAgdXBkYXRlZF9hdCxcclxuICAgICAgICAgIHN0YXR1c19jaGFuZ2VkX2F0LFxyXG4gICAgICAgICAgbGFzdF9waG9uZV9jbGljayxcclxuICAgICAgICAgIGxhc3RfZWRpdGVkX2J5X25hbWUsXHJcbiAgICAgICAgICBsYXN0X2VkaXRlZF9ieV9hdmF0YXJfdXJsLFxyXG4gICAgICAgICAgb3duZXI6dXNlcnMhb3duZXJfaWQgKFxyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgZnVsbF9uYW1lLFxyXG4gICAgICAgICAgICBlbWFpbCxcclxuICAgICAgICAgICAgYXZhdGFyX3VybFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIGxvY2F0aW9uOmxvY2F0aW9ucyFsb2NhdGlvbl9pZCAoXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBjb2RlLFxyXG4gICAgICAgICAgICBjdXJyZW5jeSxcclxuICAgICAgICAgICAgdGltZXpvbmVcclxuICAgICAgICAgIClcclxuICAgICAgICBgLCB7IGNvdW50OiAnZXhhY3QnIH0pXHJcblxyXG4gICAgICAvLyDwn5qAIFNPUlRPV0FOSUU6IE9ic8WCdWdhIGR5bmFtaWN6bmVnbyBzb3J0b3dhbmlhXHJcbiAgICAgIGNvbnN0IHNvcnRGaWVsZCA9IGZpbHRlcnM/LnNvcnRCeSB8fCAndXBkYXRlZF9hdCdcclxuICAgICAgY29uc3QgaXNBc2NlbmRpbmcgPSBmaWx0ZXJzPy5zb3J0RGlyZWN0aW9uID09PSAnYXNjJ1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKHNvcnRGaWVsZCwgeyBhc2NlbmRpbmc6IGlzQXNjZW5kaW5nIH0pXHJcblxyXG4gICAgICAvLyBEb2RhdGtvd2UgZmlsdHJ5XHJcbiAgICAgIGlmIChmaWx0ZXJzPy5kYXRlKSB7XHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5ndGUoJ3VwZGF0ZWRfYXQnLCBmaWx0ZXJzLmRhdGUpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChmaWx0ZXJzPy5zdGF0dXMpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdzdGF0dXMnLCBmaWx0ZXJzLnN0YXR1cylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGZpbHRlcnM/LmVtcGxveWVlKSB7XHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnZWRpdGVkX2J5JywgZmlsdGVycy5lbXBsb3llZSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g8J+agCBOT1dFOiBGaWx0ciB3eXN6dWtpd2FuaWFcclxuICAgICAgaWYgKGZpbHRlcnM/LnNlYXJjaCkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5vcihgZmlyc3RfbmFtZS5pbGlrZS4lJHtzZWFyY2hUZXJtfSUsbGFzdF9uYW1lLmlsaWtlLiUke3NlYXJjaFRlcm19JSxjb21wYW55X25hbWUuaWxpa2UuJSR7c2VhcmNoVGVybX0lLHBob25lLmlsaWtlLiUke3NlYXJjaFRlcm19JSxlbWFpbC5pbGlrZS4lJHtzZWFyY2hUZXJtfSVgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyDwn5qAIE5PV0U6IEZpbHRyIGxva2FsaXphY2ppXHJcbiAgICAgIGlmIChmaWx0ZXJzPy5sb2NhdGlvbikge1xyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2xvY2F0aW9uX2lkJywgZmlsdGVycy5sb2NhdGlvbilcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8g8J+agCBOT1dFOiBQYWdpbmFjamFcclxuICAgICAgaWYgKGZpbHRlcnM/LnBhZ2UgJiYgZmlsdGVycz8ucGFnZVNpemUpIHtcclxuICAgICAgICBjb25zdCBmcm9tID0gKGZpbHRlcnMucGFnZSAtIDEpICogZmlsdGVycy5wYWdlU2l6ZVxyXG4gICAgICAgIGNvbnN0IHRvID0gZnJvbSArIGZpbHRlcnMucGFnZVNpemUgLSAxXHJcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5yYW5nZShmcm9tLCB0bylcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+ThCBQYWdpbmFjamE6IHN0cm9uYSAke2ZpbHRlcnMucGFnZX0sIHJvem1pYXIgJHtmaWx0ZXJzLnBhZ2VTaXplfSwgemFrcmVzOiAke2Zyb219LSR7dG99YClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CflIQgV3lrb251asSZIHphcHl0YW5pZSB6IEpPSU4gaSBsaWN6ZW5pZW0uLi4nKVxyXG4gICAgICBjb25zdCB7IGRhdGE6IGNsaWVudHMsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgcXVlcnlcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgemFweXRhbmlhIGNsaWVudHM6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgXHJcbiAgICAgIGlmICghY2xpZW50cyB8fCBjbGllbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gQnJhayBrbGllbnTDs3cgdyBiYXppZSBkYW55Y2gnKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjbGllbnRzOiBbXSxcclxuICAgICAgICAgIHRvdGFsOiAwLFxyXG4gICAgICAgICAgcGFnZTogZmlsdGVycz8ucGFnZSB8fCAxLFxyXG4gICAgICAgICAgcGFnZVNpemU6IGZpbHRlcnM/LnBhZ2VTaXplIHx8IDBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFByemVrc3p0YcWCxIcgZGFuZSAtIFN1cGFiYXNlIEpPSU4gendyYWNhIG93bmVyIGkgbG9jYXRpb24gamFrbyB0YWJsaWNlLCBhbGUgcG90cnplYnVqZW15IHBvamVkeW5jenljaCBvYmlla3TDs3dcclxuICAgICAgY29uc3QgdHJhbnNmb3JtZWRDbGllbnRzID0gY2xpZW50cy5tYXAoKGNsaWVudDogYW55KSA9PiAoe1xyXG4gICAgICAgIC4uLmNsaWVudCxcclxuICAgICAgICBvd25lcjogY2xpZW50Lm93bmVyICYmIEFycmF5LmlzQXJyYXkoY2xpZW50Lm93bmVyKSAmJiBjbGllbnQub3duZXIubGVuZ3RoID4gMCBcclxuICAgICAgICAgID8gY2xpZW50Lm93bmVyWzBdIC8vIFdlxbogcGllcndzenkgZWxlbWVudCB6IHRhYmxpY3lcclxuICAgICAgICAgIDogY2xpZW50Lm93bmVyICYmICFBcnJheS5pc0FycmF5KGNsaWVudC5vd25lcilcclxuICAgICAgICAgID8gY2xpZW50Lm93bmVyIC8vIEp1xbwgamVzdCBwb2plZHluY3p5bSBvYmlla3RlbVxyXG4gICAgICAgICAgOiBudWxsLCAvLyBCcmFrIHfFgmHFm2NpY2llbGFcclxuICAgICAgICBsb2NhdGlvbjogY2xpZW50LmxvY2F0aW9uICYmIEFycmF5LmlzQXJyYXkoY2xpZW50LmxvY2F0aW9uKSAmJiBjbGllbnQubG9jYXRpb24ubGVuZ3RoID4gMCBcclxuICAgICAgICAgID8gY2xpZW50LmxvY2F0aW9uWzBdIC8vIFdlxbogcGllcndzenkgZWxlbWVudCB6IHRhYmxpY3lcclxuICAgICAgICAgIDogY2xpZW50LmxvY2F0aW9uICYmICFBcnJheS5pc0FycmF5KGNsaWVudC5sb2NhdGlvbilcclxuICAgICAgICAgID8gY2xpZW50LmxvY2F0aW9uIC8vIEp1xbwgamVzdCBwb2plZHluY3p5bSBvYmlla3RlbVxyXG4gICAgICAgICAgOiBudWxsIC8vIEJyYWsgbG9rYWxpemFjamlcclxuICAgICAgfSkpXHJcbiAgICAgIFxyXG4gICAgICAvLyBERUJVRzogU3ByYXdkxbogZGFuZSB3xYJhxZtjaWNpZWxpXHJcbiAgICAgIGNvbnN0IGNsaWVudHNXaXRoT3duZXJzID0gdHJhbnNmb3JtZWRDbGllbnRzLmZpbHRlcigoY2xpZW50OiBDbGllbnQpID0+IGNsaWVudC5vd25lcilcclxuICAgICAgY29uc3QgY2xpZW50c1dpdGhvdXRPd25lcnMgPSB0cmFuc2Zvcm1lZENsaWVudHMuZmlsdGVyKChjbGllbnQ6IENsaWVudCkgPT4gIWNsaWVudC5vd25lcilcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBLbGllbmNpIHogd8WCYcWbY2ljaWVsYW1pOicsIGNsaWVudHNXaXRoT3duZXJzLmxlbmd0aClcclxuICAgICAgY29uc29sZS5sb2coJ+KdjCBLbGllbmNpIGJleiB3xYJhxZtjaWNpZWxpOicsIGNsaWVudHNXaXRob3V0T3duZXJzLmxlbmd0aClcclxuICAgICAgXHJcbiAgICAgIGlmIChjbGllbnRzV2l0aE93bmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CfkaQgUHJ6eWvFgmFkIGtsaWVudGEgeiB3xYJhxZtjaWNpZWxlbTonLCB7XHJcbiAgICAgICAgICBjbGllbnQ6IGAke2NsaWVudHNXaXRoT3duZXJzWzBdLmZpcnN0X25hbWV9ICR7Y2xpZW50c1dpdGhPd25lcnNbMF0ubGFzdF9uYW1lfWAsXHJcbiAgICAgICAgICBvd25lcl9pZDogY2xpZW50c1dpdGhPd25lcnNbMF0ub3duZXJfaWQsXHJcbiAgICAgICAgICBvd25lcl9uYW1lOiBjbGllbnRzV2l0aE93bmVyc1swXS5vd25lcj8uZnVsbF9uYW1lLFxyXG4gICAgICAgICAgb3duZXJfZW1haWw6IGNsaWVudHNXaXRoT3duZXJzWzBdLm93bmVyPy5lbWFpbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIPCfmoAgTk9XRTogWndyw7PEhyBkYW5lIHogaW5mb3JtYWNqxIUgbyBwYWdpbmFjamlcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjbGllbnRzOiB0cmFuc2Zvcm1lZENsaWVudHMgYXMgQ2xpZW50W10sXHJcbiAgICAgICAgdG90YWw6IGNvdW50IHx8IHRyYW5zZm9ybWVkQ2xpZW50cy5sZW5ndGgsXHJcbiAgICAgICAgcGFnZTogZmlsdGVycz8ucGFnZSB8fCAxLFxyXG4gICAgICAgIHBhZ2VTaXplOiBmaWx0ZXJzPy5wYWdlU2l6ZSB8fCB0cmFuc2Zvcm1lZENsaWVudHMubGVuZ3RoXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBnZXRDbGllbnRzUGFnaW5hdGVkOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gIC8vIPCflIQgS09NUEFUWUJJTE5PxZrEhjogU3RhcmEgZnVua2NqYSB6d3JhY2FqxIVjYSB0eWxrbyB0YWJsaWPEmSBrbGllbnTDs3dcclxuICBhc3luYyBnZXRDbGllbnRzKHVzZXI6IFVzZXIsIGZpbHRlcnM/OiB7IFxyXG4gICAgZGF0ZT86IHN0cmluZ1xyXG4gICAgc3RhdHVzPzogc3RyaW5nXHJcbiAgICBlbXBsb3llZT86IHN0cmluZyBcclxuICAgIHNlYXJjaD86IHN0cmluZ1xyXG4gICAgbG9jYXRpb24/OiBzdHJpbmdcclxuICAgIHNvcnRCeT86IHN0cmluZ1xyXG4gICAgc29ydERpcmVjdGlvbj86ICdhc2MnIHwgJ2Rlc2MnXHJcbiAgfSk6IFByb21pc2U8Q2xpZW50W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50c1BhZ2luYXRlZCh1c2VyLCBmaWx0ZXJzKVxyXG4gICAgICByZXR1cm4gcmVzdWx0LmNsaWVudHNcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBnZXRDbGllbnRzOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIERvZGFqIG5vd2VnbyBrbGllbnRhIHogYXV0b21hdHljem55bSBwcnp5cGlzYW5pZW0gd8WCYcWbY2ljaWVsYVxyXG4gIGFzeW5jIGNyZWF0ZUNsaWVudChjbGllbnQ6IE9taXQ8Q2xpZW50LCAnaWQnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnPiwgdXNlcjogVXNlcikge1xyXG4gICAgLy8gWkFCRVpQSUVDWkVOSUU6IFVwZXduaWogc2nEmSDFvGUgc3RhdHVzIG5pZSBqZXN0IHB1c3R5XHJcbiAgICBjb25zdCBzYWZlU3RhdHVzID0gY2xpZW50LnN0YXR1cyB8fCAnY2FudmFzJ1xyXG4gICAgXHJcbiAgICBjb25zdCBjbGllbnRUb0NyZWF0ZSA9IHtcclxuICAgICAgLi4uY2xpZW50LFxyXG4gICAgICBzdGF0dXM6IHNhZmVTdGF0dXMsIC8vIFXFvHlqIGJlenBpZWN6bmVnbyBzdGF0dXN1XHJcbiAgICAgIG93bmVyX2lkOiB1c2VyLmlkLCAvLyBBdXRvbWF0eWN6bmllIHByenlwaXN6IHfFgmHFm2NpY2llbGFcclxuICAgICAgbG9jYXRpb25faWQ6IGNsaWVudC5sb2NhdGlvbl9pZCB8fCB1c2VyLmxvY2F0aW9uX2lkLCAvLyBVxbx5aiBsb2thbGl6YWNqaSBrbGllbnRhIGx1YiB1xbx5dGtvd25pa2FcclxuICAgICAgZWRpdGVkX2J5OiB1c2VyLmlkLFxyXG4gICAgICBsYXN0X2VkaXRlZF9ieV9uYW1lOiB1c2VyLmZ1bGxfbmFtZSwgLy8gWmFwaXN6IGRhbmUgdHfDs3JjeVxyXG4gICAgICBsYXN0X2VkaXRlZF9ieV9hdmF0YXJfdXJsOiB1c2VyLmF2YXRhcl91cmwsXHJcbiAgICAgIC8vIEplxZtsaSBzdGF0dXMgdG8gXCJjYW52YXNcIiwgdXN0YXcgc3RhdHVzX2NoYW5nZWRfYXRcclxuICAgICAgLi4uKHNhZmVTdGF0dXMgPT09ICdjYW52YXMnICYmIHsgc3RhdHVzX2NoYW5nZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KSxcclxuICAgICAgLy8gS29ud2VydHVqIHVuZGVmaW5lZCByZW1pbmRlciBuYSBudWxsIGRsYSBiYXp5IGRhbnljaFxyXG4gICAgICByZW1pbmRlcjogY2xpZW50LnJlbWluZGVyIHx8IG51bGxcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+TiiBUd29yemVuaWUga2xpZW50YSB6IGRhbnltaTonLCBjbGllbnRUb0NyZWF0ZSlcclxuICAgIFxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NsaWVudHMnKVxyXG4gICAgICAuaW5zZXJ0KFtjbGllbnRUb0NyZWF0ZV0pXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKClcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgY3JlYXRlQ2xpZW50OicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZGF0YSBhcyBDbGllbnRcclxuICB9LFxyXG5cclxuICAvLyBaYWt0dWFsaXp1aiBrbGllbnRhIHogc3ByYXdkemVuaWVtIHVwcmF3bmllxYRcclxuICBhc3luYyB1cGRhdGVDbGllbnQoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxDbGllbnQ+LCB1c2VyOiBVc2VyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCB1cGRhdGVDbGllbnQgU1RBUlQ6JywgeyBpZCwgdXBkYXRlcywgdXNlcjogdXNlci5lbWFpbCB9KVxyXG4gICAgICBcclxuICAgICAgLy8gUG9iaWVyeiBha3R1YWxueSBzdGFuIGtsaWVudGEgYWJ5IHNwcmF3ZHppxIcgY3p5IHN0YXR1cyBzacSZIHptaWVuaWFcclxuICAgICAgY29uc3QgeyBkYXRhOiBjdXJyZW50Q2xpZW50LCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgLnNlbGVjdCgnc3RhdHVzLCBvd25lcl9pZCcpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGZldGNoRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgYWt0dWFsbmVnbyBrbGllbnRhOicsIGZldGNoRXJyb3IpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOaWUgbW/FvG5hIHBvYnJhxIcgYWt0dWFsbmVnbyBzdGFudSBrbGllbnRhOiAke2ZldGNoRXJyb3IubWVzc2FnZX1gKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEFrdHVhbG55IHN0YW4ga2xpZW50YTonLCBjdXJyZW50Q2xpZW50KVxyXG4gICAgICBcclxuICAgICAgLy8gTk9XQSBMT0dJS0E6IEthxbxkYSBvc29iYSBrdMOzcmEgZWR5dHVqZSBrbGllbnRhIHpvc3RhamUgamVnbyB3xYJhxZtjaWNpZWxlbVxyXG4gICAgICBsZXQgdXBkYXRlZERhdGEgPSB7IC4uLnVwZGF0ZXMgfVxyXG4gICAgICBcclxuICAgICAgLy8gWkFCRVpQSUVDWkVOSUU6IEplxZtsaSBzdGF0dXMgamVzdCB3IGFrdHVhbGl6YWNqaSwgdXBld25paiBzacSZIMW8ZSBuaWUgamVzdCBwdXN0eVxyXG4gICAgICBpZiAoJ3N0YXR1cycgaW4gdXBkYXRlZERhdGEgJiYgIXVwZGF0ZWREYXRhLnN0YXR1cykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gVVdBR0E6IFB1c3R5IHN0YXR1cyB3IGFrdHVhbGl6YWNqaSAtIHVzdGF3aWFtIGRvbXnFm2xueSBcImNhbnZhc1wiJylcclxuICAgICAgICB1cGRhdGVkRGF0YS5zdGF0dXMgPSAnY2FudmFzJ1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTcHJhd2TFuiBjenkgc3RhdHVzIHNpxJkgem1pZW5pYVxyXG4gICAgICBjb25zdCBzdGF0dXNDaGFuZ2VkID0gdXBkYXRlZERhdGEuc3RhdHVzICYmIHVwZGF0ZWREYXRhLnN0YXR1cyAhPT0gY3VycmVudENsaWVudC5zdGF0dXNcclxuICAgICAgaWYgKHN0YXR1c0NoYW5nZWQpIHtcclxuICAgICAgICB1cGRhdGVkRGF0YS5zdGF0dXNfY2hhbmdlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFN0YXR1cyB6bWllbmlvbnkgeiBcIiR7Y3VycmVudENsaWVudC5zdGF0dXN9XCIgbmEgXCIke3VwZGF0ZXMuc3RhdHVzfVwiIC0gdXN0YXdpYW0gc3RhdHVzX2NoYW5nZWRfYXRgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFBvd2lhZG9taWVuaWUgbyB6bWlhbmllIG5hIGNhbnZhc1xyXG4gICAgICAgIGlmICh1cGRhdGVzLnN0YXR1cyA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SUIFBPV0lBRE9NSUVOSUU6IEtsaWVudCBwcnplc3plZMWCIG5hIHN0YXR1cyBDQU5WQVMgLSBzdGFydCB0cmFja2luZ3UgY3phc3UhJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFphd3N6ZSBwcnp5cGlzeiBlZHl0dWrEhWNlZ28gamFrbyB3xYJhxZtjaWNpZWxhXHJcbiAgICAgIHVwZGF0ZWREYXRhLm93bmVyX2lkID0gdXNlci5pZFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBQcnp5cGlzdWrEmSBrbGllbnRhICR7aWR9IGRvIHXFvHl0a293bmlrYSAke3VzZXIuaWR9ICgke3VzZXIuZW1haWx9KSBqYWtvIHfFgmHFm2NpY2llbGFgKVxyXG4gICAgICBcclxuICAgICAgLy8gWmFwaXN6IGluZm9ybWFjamUgbyBlZHl0b3J6ZSAoc3pjemVnw7NsbmllIHdhxbxuZSBkbGEgcHJhY293bmlrw7N3KVxyXG4gICAgICB1cGRhdGVkRGF0YS5sYXN0X2VkaXRlZF9ieV9uYW1lID0gdXNlci5mdWxsX25hbWVcclxuICAgICAgdXBkYXRlZERhdGEubGFzdF9lZGl0ZWRfYnlfYXZhdGFyX3VybCA9IHVzZXIuYXZhdGFyX3VybFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+RpCBaYXBpc3VqxJkgZGFuZSBlZHl0b3JhOiAke3VzZXIuZnVsbF9uYW1lfSAocm9sYTogJHt1c2VyLnJvbGV9KWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBKZcWbbGkgdG8gcHJhY293bmlrIGkgem1pZW5pYSBzdGF0dXMgLSBkb2RhdGtvd3kgbG9nXHJcbiAgICAgIGlmICh1c2VyLnJvbGUgPT09ICdwcmFjb3duaWsnICYmIHN0YXR1c0NoYW5nZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+RtyBQcmFjb3duaWsgJHt1c2VyLmVtYWlsfSB6bWllbmlhIHN0YXR1cyB6IFwiJHtjdXJyZW50Q2xpZW50LnN0YXR1c31cIiBuYSBcIiR7dXBkYXRlcy5zdGF0dXN9XCJgKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBEYW5lIGRvIGFrdHVhbGl6YWNqaTonLCB1cGRhdGVkRGF0YSlcclxuICAgICAgXHJcbiAgICAgIC8vIFByenlnb3R1aiBmaW5hbG5lIGRhbmUgZG8gVVBEQVRFXHJcbiAgICAgIGNvbnN0IGZpbmFsRGF0YSA9IHtcclxuICAgICAgICAuLi51cGRhdGVkRGF0YSxcclxuICAgICAgICBlZGl0ZWRfYnk6IHVzZXIuaWQsXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIC8vIEtvbndlcnR1aiB1bmRlZmluZWQgcmVtaW5kZXIgbmEgbnVsbCBkbGEgYmF6eSBkYW55Y2hcclxuICAgICAgICAuLi4odXBkYXRlZERhdGEucmVtaW5kZXIgIT09IHVuZGVmaW5lZCAmJiB7IHJlbWluZGVyOiB1cGRhdGVkRGF0YS5yZW1pbmRlciB8fCBudWxsIH0pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIEZpbmFsbmUgZGFuZSBkbyBVUERBVEU6JywgZmluYWxEYXRhKVxyXG4gICAgICBcclxuICAgICAgLy8gQmV6cG/Fm3JlZG5pYSBha3R1YWxpemFjamFcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgLnVwZGF0ZShmaW5hbERhdGEpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBVUERBVEUgY2xpZW50czonLCBlcnJvcilcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgS29kIGLFgsSZZHU6JywgZXJyb3IuY29kZSlcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU3pjemVnw7PFgnk6JywgZXJyb3IuZGV0YWlscylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgSGludDonLCBlcnJvci5oaW50KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQsWCxIVkIGFrdHVhbGl6YWNqaTogJHtlcnJvci5tZXNzYWdlfSAoa29kOiAke2Vycm9yLmNvZGV9KWApXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgdXBkYXRlQ2xpZW50IFNVQ0NFU1M6JywgZGF0YSlcclxuICAgICAgcmV0dXJuIGRhdGEgYXMgQ2xpZW50XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIHVwZGF0ZUNsaWVudCBGQUlMRUQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gQWt0dWFsaXp1aiBjemFzIG9zdGF0bmllZ28ga2xpa25pxJljaWEgdGVsZWZvbnVcclxuICBhc3luYyB1cGRhdGVMYXN0UGhvbmVDbGljayhjbGllbnRJZDogc3RyaW5nLCB1c2VyOiBVc2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TniBBa3R1YWxpenVqxJkgY3phcyBvc3RhdG5pZWdvIGtsaWtuacSZY2lhIHRlbGVmb251OicsIGNsaWVudElkKVxyXG4gICAgXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgIGxhc3RfcGhvbmVfY2xpY2s6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSlcclxuICAgICAgLmVxKCdpZCcsIGNsaWVudElkKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpXHJcbiAgICBcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHVwZGF0ZUxhc3RQaG9uZUNsaWNrOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG5cclxuICAgIC8vIFphbG9ndWogdyBhY3Rpdml0eV9sb2dzXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBhY3Rpdml0eUxvZ3NBcGkuY3JlYXRlTG9nKHtcclxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxyXG4gICAgICAgIGNoYW5nZWRfYnk6IHVzZXIuaWQsXHJcbiAgICAgICAgY2hhbmdlX3R5cGU6ICd1cGRhdGUnLFxyXG4gICAgICAgIGZpZWxkX2NoYW5nZWQ6ICdsYXN0X3Bob25lX2NsaWNrJyxcclxuICAgICAgICBvbGRfdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICBuZXdfdmFsdWU6IGRhdGEubGFzdF9waG9uZV9jbGlja1xyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAobG9nRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBsb2dvd2FuaWEgYWN0aXZpdHlfbG9ncyAodXBkYXRlTGFzdFBob25lQ2xpY2spOicsIGxvZ0Vycm9yKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZGF0YSBhcyBDbGllbnRcclxuICB9LFxyXG5cclxuICAvLyBVc3XFhCBrbGllbnRhIHogc3ByYXdkemVuaWVtIHVwcmF3bmllxYRcclxuICBhc3luYyBkZWxldGVDbGllbnQoaWQ6IHN0cmluZywgdXNlcjogVXNlcikge1xyXG4gICAgLy8gQmV6cG/Fm3JlZG5pZSB1c3VuacSZY2llIGJleiBzcHJhd2R6YW5pYSB1cHJhd25pZcWEXHJcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgIC5kZWxldGUoKVxyXG4gICAgICAuZXEoJ2lkJywgaWQpXHJcbiAgICBcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICB9LFxyXG5cclxuICAvLyBQcnp5cGlzeiBrbGllbnRhIGRvIGlubmVnbyB1xbx5dGtvd25pa2EgKHR5bGtvIG1hbmFnZXIrKVxyXG4gIGFzeW5jIGFzc2lnbkNsaWVudChjbGllbnRJZDogc3RyaW5nLCBuZXdPd25lcklkOiBzdHJpbmcsIHVzZXI6IFVzZXIpIHtcclxuICAgIGlmICghcGVybWlzc2lvbnNBcGkuY2FuQXNzaWduQ2xpZW50cyh1c2VyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JyYWsgdXByYXduaWXFhCBkbyBwcnp5cGlzeXdhbmlhIGtsaWVudMOzdycpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NsaWVudHMnKVxyXG4gICAgICAudXBkYXRlKHtcclxuICAgICAgICBvd25lcl9pZDogbmV3T3duZXJJZCxcclxuICAgICAgICBlZGl0ZWRfYnk6IHVzZXIuaWQsXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5lcSgnaWQnLCBjbGllbnRJZClcclxuICAgICAgLnNlbGVjdCgpXHJcbiAgICAgIC5zaW5nbGUoKVxyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICByZXR1cm4gZGF0YSBhcyBDbGllbnRcclxuICB9LFxyXG5cclxuICAvLyBGdW5rY2phIGRvIGN6eXN6Y3plbmlhIG5pZWlzdG5pZWrEhWN5Y2ggb3duZXJfaWRcclxuICBhc3luYyBjbGVhbnVwSW52YWxpZE93bmVySWRzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfp7kgUm96cG9jenluYW0gY3p5c3pjemVuaWUgbmllaXN0bmllasSFY3ljaCBvd25lcl9pZC4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQb2JpZXJ6IHdzenlzdGtpY2gga2xpZW50w7N3IHogb3duZXJfaWRcclxuICAgICAgY29uc3QgeyBkYXRhOiBhbGxDbGllbnRzLCBlcnJvcjogY2xpZW50c0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCwgb3duZXJfaWQsIGZpcnN0X25hbWUsIGxhc3RfbmFtZScpXHJcbiAgICAgICAgLm5vdCgnb3duZXJfaWQnLCAnaXMnLCBudWxsKVxyXG4gICAgICBcclxuICAgICAgaWYgKGNsaWVudHNFcnJvcikgdGhyb3cgY2xpZW50c0Vycm9yXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBabmFsZXppb25vIGtsaWVudMOzdyB6IG93bmVyX2lkOicsIGFsbENsaWVudHM/Lmxlbmd0aCB8fCAwKVxyXG4gICAgICBcclxuICAgICAgaWYgKCFhbGxDbGllbnRzIHx8IGFsbENsaWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgY2xlYW5lZDogMCwgZXJyb3JzOiBbXSB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFBvYmllcnogd3N6eXN0a2llIHVuaWthbG5lIG93bmVyX2lkXHJcbiAgICAgIGNvbnN0IG93bmVySWRzID0gWy4uLm5ldyBTZXQoYWxsQ2xpZW50cy5tYXAoYyA9PiBjLm93bmVyX2lkKSldXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFNwcmF3ZHphbSBvd25lcl9pZDonLCBvd25lcklkcylcclxuICAgICAgXHJcbiAgICAgIC8vIFNwcmF3ZMW6IGt0w7NyZSB1xbx5dGtvd25pY3kgaXN0bmllasSFXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VycywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCcpXHJcbiAgICAgICAgLmluKCdpZCcsIG93bmVySWRzKVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJzRXJyb3IpIHRocm93IHVzZXJzRXJyb3JcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nVXNlcklkcyA9IChleGlzdGluZ1VzZXJzIHx8IFtdKS5tYXAodSA9PiB1LmlkKVxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIElzdG5pZWrEhWN5IHXFvHl0a293bmljeTonLCBleGlzdGluZ1VzZXJJZHMpXHJcbiAgICAgIFxyXG4gICAgICAvLyBabmFqZMW6IGtsaWVudMOzdyB6IG5pZWlzdG5pZWrEhWN5bWkgb3duZXJfaWRcclxuICAgICAgY29uc3QgY2xpZW50c1RvQ2xlYW4gPSBhbGxDbGllbnRzLmZpbHRlcihjbGllbnQgPT4gXHJcbiAgICAgICAgY2xpZW50Lm93bmVyX2lkICYmICFleGlzdGluZ1VzZXJJZHMuaW5jbHVkZXMoY2xpZW50Lm93bmVyX2lkKVxyXG4gICAgICApXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn8J+nuSBLbGllbmNpIGRvIHd5Y3p5c3pjemVuaWE6JywgY2xpZW50c1RvQ2xlYW4ubGVuZ3RoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGNsaWVudHNUb0NsZWFuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQnJhayBrbGllbnTDs3cgZG8gd3ljenlzemN6ZW5pYScpXHJcbiAgICAgICAgcmV0dXJuIHsgY2xlYW5lZDogMCwgZXJyb3JzOiBbXSB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFd5Y3p5xZvEhyBvd25lcl9pZCBkbGEgcHJvYmxlbWF0eWN6bnljaCBrbGllbnTDs3dcclxuICAgICAgY29uc3QgY2xlYW51cFJlc3VsdHM6IHN0cmluZ1tdID0gW11cclxuICAgICAgY29uc3QgZXJyb3JzOiBhbnlbXSA9IFtdXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiBjbGllbnRzVG9DbGVhbikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+nuSBDenlzemN6xJkgb3duZXJfaWQgZGxhICR7Y2xpZW50LmZpcnN0X25hbWV9ICR7Y2xpZW50Lmxhc3RfbmFtZX0gKCR7Y2xpZW50Lm93bmVyX2lkfSlgKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgICAgIC51cGRhdGUoeyBvd25lcl9pZDogbnVsbCB9KVxyXG4gICAgICAgICAgICAuZXEoJ2lkJywgY2xpZW50LmlkKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIELFgsSFZCBjenlzemN6ZW5pYSAke2NsaWVudC5pZH06YCwgZXJyb3IpXHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgY2xpZW50OiBjbGllbnQuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbGVhbnVwUmVzdWx0cy5wdXNoKGNsaWVudC5pZClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBXeWrEhXRlayBwb2RjemFzIGN6eXN6Y3plbmlhICR7Y2xpZW50LmlkfTpgLCBlcnIpXHJcbiAgICAgICAgICBlcnJvcnMucHVzaCh7IGNsaWVudDogY2xpZW50LmlkLCBlcnJvcjogU3RyaW5nKGVycikgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgV3ljenlzemN6b25vICR7Y2xlYW51cFJlc3VsdHMubGVuZ3RofSBrbGllbnTDs3dgKVxyXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgQsWCxJlkeSBwcnp5ICR7ZXJyb3JzLmxlbmd0aH0ga2xpZW50YWNoOmAsIGVycm9ycylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgY2xlYW5lZDogY2xlYW51cFJlc3VsdHMubGVuZ3RoLCBcclxuICAgICAgICBlcnJvcnMsXHJcbiAgICAgICAgY2xlYW5lZENsaWVudHM6IGNsaWVudHNUb0NsZWFuLmZpbHRlcihjID0+IGNsZWFudXBSZXN1bHRzLmluY2x1ZGVzKGMuaWQpKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IGNsZWFudXBJbnZhbGlkT3duZXJJZHM6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcblxyXG5cclxuICAvLyBTdWJza3J5cGNqYSBuYSB6bWlhbnkgdyBjemFzaWUgcnplY3p5d2lzdHltXHJcbiAgc3Vic2NyaWJlVG9DaGFuZ2VzKGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkKSB7XHJcbiAgICByZXR1cm4gc3VwYWJhc2VcclxuICAgICAgLmNoYW5uZWwoJ2NsaWVudHNfY2hhbmdlcycpXHJcbiAgICAgIC5vbigncG9zdGdyZXNfY2hhbmdlcycsIFxyXG4gICAgICAgIHsgZXZlbnQ6ICcqJywgc2NoZW1hOiAncHVibGljJywgdGFibGU6ICdjbGllbnRzJyB9LCBcclxuICAgICAgICBjYWxsYmFja1xyXG4gICAgICApXHJcbiAgICAgIC5zdWJzY3JpYmUoKVxyXG4gIH0sXHJcblxyXG4gIC8vIFN1YnNrcnlwY2phIG5hIHptaWFueSBvd25lcl9pZCBkbGEgcmVhbC10aW1lIGFrdHVhbGl6YWNqaVxyXG4gIHN1YnNjcmliZVRvT3duZXJDaGFuZ2VzKGNhbGxiYWNrOiAocGF5bG9hZDogYW55KSA9PiB2b2lkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTcHJhd2TFuiBjenkgY2FsbGJhY2sgamVzdCBmdW5rY2rEhVxyXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIENhbGxiYWNrIG5pZSBqZXN0IGZ1bmtjasSFIHcgc3Vic2NyaWJlVG9Pd25lckNoYW5nZXMnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgbXVzaSBiecSHIGZ1bmtjasSFJylcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk6EgVHdvcnrEmSBrYW5hxYIgU3VwYWJhc2UgZGxhIG93bmVyIGNoYW5nZXMuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gTmFqcGllcncgc3ByYXdkxbogY3p5IHJlYWwtdGltZSBqZXN0IHfFgsSFY3pvbnkgaSBkb3N0xJlwbnlcclxuICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgY2xpZW50c19vd25lcl9jaGFuZ2VzXyR7RGF0ZS5ub3coKX1gXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OhIE5hendhIGthbmHFgnU6JywgY2hhbm5lbE5hbWUpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjaGFubmVsID0gc3VwYWJhc2VcclxuICAgICAgICAuY2hhbm5lbChjaGFubmVsTmFtZSlcclxuICAgICAgICAub24oJ3Bvc3RncmVzX2NoYW5nZXMnLCBcclxuICAgICAgICAgIHsgXHJcbiAgICAgICAgICAgIGV2ZW50OiAnVVBEQVRFJywgXHJcbiAgICAgICAgICAgIHNjaGVtYTogJ3B1YmxpYycsIFxyXG4gICAgICAgICAgICB0YWJsZTogJ2NsaWVudHMnLFxyXG4gICAgICAgICAgICBmaWx0ZXI6ICdvd25lcl9pZD1uZXEubnVsbCcgLy8gVHlsa28gZ2R5IG93bmVyX2lkIHNpxJkgem1pZW5pYVxyXG4gICAgICAgICAgfSwgXHJcbiAgICAgICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFJlYWwtdGltZSBwYXlsb2FkIG90cnp5bWFueTonLCB7XHJcbiAgICAgICAgICAgICAgICBldmVudFR5cGU6IHBheWxvYWQuZXZlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgdGFibGU6IHBheWxvYWQudGFibGUsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBwYXlsb2FkLm5ldyA/IHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IHBheWxvYWQubmV3LmlkLFxyXG4gICAgICAgICAgICAgICAgICBvd25lcl9pZDogcGF5bG9hZC5uZXcub3duZXJfaWQsXHJcbiAgICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IHBheWxvYWQubmV3LmZpcnN0X25hbWUsXHJcbiAgICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogcGF5bG9hZC5uZXcubGFzdF9uYW1lXHJcbiAgICAgICAgICAgICAgICB9IDogJ2JyYWsgZGFueWNoJ1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socGF5bG9hZClcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIENhbGxiYWNrIG5pZSBqZXN0IGZ1bmtjasSFIHBvZGN6YXMgd3l3b8WCYW5pYScpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChjYWxsYmFja0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IGNhbGxiYWNrOicsIGNhbGxiYWNrRXJyb3IpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApXHJcbiAgICAgICAgLnN1YnNjcmliZSgoc3RhdHVzLCBlcnIpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFN1YnNrcnlwY2phIG93bmVyX2NoYW5nZXMgc3RhdHVzOicsIHN0YXR1cylcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ1NVQlNDUklCRUQnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3Vic2tyeXBjamEgb3duZXJfY2hhbmdlcyBha3R5d25hJylcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnQ0xPU0VEJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBTdWJza3J5cGNqYSBvd25lcl9jaGFuZ2VzIHphbWtuacSZdGEgLSBwcmF3ZG9wb2RvYm5pZSBwcm9ibGVtIHogYXV0b3J5emFjasSFIHJlYWwtdGltZScpXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign8J+SoSBSZWFsLXRpbWUgbW/FvGUgYnnEhyB3ecWCxIVjem9ueSB3IHVzdGF3aWVuaWFjaCBTdXBhYmFzZSBsdWIgYnJha3VqZSB1cHJhd25pZcWEJylcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnQ0hBTk5FTF9FUlJPUicpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBrYW5hxYJ1IHJlYWwtdGltZTonLCBlcnIpXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ/CfkqEgU3ByYXdkxbogdXN0YXdpZW5pYSByZWFsLXRpbWUgdyBTdXBhYmFzZSBEYXNoYm9hcmQnKVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdUSU1FRF9PVVQnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign4o+wIFRpbWVvdXQgc3Vic2tyeXBjamkgLSBwcm9ibGVteSB6IHBvxYLEhWN6ZW5pZW0gV2ViU29ja2V0JylcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFN0YXR1cyBzdWJza3J5cGNqaTonLCBzdGF0dXMpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIC8vIFNwcmF3ZMW6IHN0YW4ga2FuYcWCdSBwbyBrcsOzdGtpbSBjemFzaWVcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBLYW5hxYIgcmVhbC10aW1lIHpvc3RhxYIgemFta25pxJl0eSAtIHByYXdkb3BvZG9ibmllIFJMUyBibG9rdWplIHJlYWwtdGltZSBsdWIgZmVhdHVyZSBqZXN0IHd5xYLEhWN6b255JylcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDIwMDApXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEthbmHFgiBvd25lciBjaGFuZ2VzIHV0d29yem9ueScpXHJcbiAgICAgIHJldHVybiBjaGFubmVsXHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IHN1YnNjcmliZVRvT3duZXJDaGFuZ2VzOicsIGVycm9yKVxyXG4gICAgICBjb25zb2xlLndhcm4oJ/CfkqEgUmVhbC10aW1lIG5pZSBixJlkemllIGR6aWHFgmHEhyAtIGFwbGlrYWNqYSBixJlkemllIHXFvHl3YcSHIG9rcmVzb3dlZ28gb2TFm3dpZcW8YW5pYScpXHJcbiAgICAgIFxyXG4gICAgICAvLyBad3LDs8SHIG1vY2sgb2JqZWN0IGFieSBuaWUgcG93b2Rvd2HEhyBixYLEmWTDs3dcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfp7kgTW9jayB1bnN1YnNjcmliZSBkbGEgYsWCxJlkbmVnbyBrYW5hxYJ1JylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IGtsaWVudMOzdyB6IHByenlwb21uaWVuaWFtaSBuYSBrb25rcmV0bnkgZHppZcWEXHJcbiAgYXN5bmMgZ2V0Q2xpZW50c1dpdGhSZW1pbmRlcnModXNlcjogVXNlciwgdGFyZ2V0RGF0ZT86IHN0cmluZyk6IFByb21pc2U8Q2xpZW50V2l0aFJlbWluZGVyW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHRvZGF5ID0gdGFyZ2V0RGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSAvLyBmb3JtYXQgWVlZWS1NTS1ERFxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCfk4UgUG9iaWVyYW5pZSBrbGllbnTDs3cgeiBwcnp5cG9tbmllbmlhbWkgbmE6ICR7dG9kYXl9YClcclxuXHJcbiAgICAgIC8vIFBvYmllcnogd3N6eXN0a2ljaCBrbGllbnTDs3cgdcW8eXRrb3duaWthIChiZXogcGFnaW5hY2ppKVxyXG4gICAgICBjb25zdCBhbGxDbGllbnRzID0gYXdhaXQgdGhpcy5nZXRDbGllbnRzKHVzZXIpXHJcblxyXG4gICAgICAvLyBGaWx0cnVqIHR5bGtvIHR5Y2ggeiBwcnp5cG9tbmllbmlhbWkgbmEgZHppxZtcclxuICAgICAgY29uc3QgY2xpZW50c1dpdGhUb2RheVJlbWluZGVycyA9IGFsbENsaWVudHMuZmlsdGVyKChjbGllbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgIC8vIFNwcmF3ZMW6IGN6eSBrbGllbnQgbWEgYWt0eXduZSBwcnp5cG9tbmllbmllXHJcbiAgICAgICAgY29uc3QgcmVtaW5kZXIgPSBjbGllbnQucmVtaW5kZXIgfHwge1xyXG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICBkYXRlOiAnJyxcclxuICAgICAgICAgIHRpbWU6ICcnLFxyXG4gICAgICAgICAgbm90ZTogJydcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZW1pbmRlci5lbmFibGVkICYmIHJlbWluZGVyLmRhdGUgPT09IHRvZGF5XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBTb3J0dWogd2VkxYJ1ZyBnb2R6aW55IHByenlwb21uaWVuaWFcclxuICAgICAgY29uc3Qgc29ydGVkQ2xpZW50cyA9IGNsaWVudHNXaXRoVG9kYXlSZW1pbmRlcnMuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zdCB0aW1lQSA9IGEucmVtaW5kZXI/LnRpbWUgfHwgJzAwOjAwJ1xyXG4gICAgICAgIGNvbnN0IHRpbWVCID0gYi5yZW1pbmRlcj8udGltZSB8fCAnMDA6MDAnXHJcbiAgICAgICAgcmV0dXJuIHRpbWVBLmxvY2FsZUNvbXBhcmUodGltZUIpXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFpuYWxlemlvbm8gJHtzb3J0ZWRDbGllbnRzLmxlbmd0aH0ga2xpZW50w7N3IHogcHJ6eXBvbW5pZW5pYW1pIG5hICR7dG9kYXl9YClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzb3J0ZWRDbGllbnRzXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEga2xpZW50w7N3IHogcHJ6eXBvbW5pZW5pYW1pOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFBvYmllcnogcHJ6eXBvbW5pZW5pYSBwb2dydXBvd2FuZSB3ZWTFgnVnIHNsb3TDs3cgY3phc293eWNoIGRsYSBkYXNoYm9hcmR1XHJcbiAgYXN5bmMgZ2V0RGFpbHlTY2hlZHVsZVdpdGhDbGllbnRzKHVzZXI6IFVzZXIsIHRhcmdldERhdGU/OiBzdHJpbmcpOiBQcm9taXNlPERhaWx5U2NoZWR1bGVTbG90W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsaWVudHNXaXRoUmVtaW5kZXJzID0gYXdhaXQgdGhpcy5nZXRDbGllbnRzV2l0aFJlbWluZGVycyh1c2VyLCB0YXJnZXREYXRlKVxyXG4gICAgICBcclxuICAgICAgLy8gRGVmaW5pY2phIHNsb3TDs3cgY3phc293eWNoICh6Z29kbmllIHogb2JlY27EhSBzdHJ1a3R1csSFIGRhc2hib2FyZHUpXHJcbiAgICAgIGNvbnN0IHRpbWVTbG90cyA9IFtcclxuICAgICAgICB7IFxyXG4gICAgICAgICAgdGltZTogJzg6MDAgLSAxMDowMCcsIFxyXG4gICAgICAgICAgdHlwZTogJ2NhbnZhcycsIFxyXG4gICAgICAgICAgY29sb3I6ICcjMDZiNmQ0JyxcclxuICAgICAgICAgIHN0YXJ0VGltZTogJzA4OjAwJyxcclxuICAgICAgICAgIGVuZFRpbWU6ICcxMDowMCcsXHJcbiAgICAgICAgICBzdGF0dXNlczogWydjYW52YXMnXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBcclxuICAgICAgICAgIHRpbWU6ICcxMDoxMCAtIDEyOjAwJywgXHJcbiAgICAgICAgICB0eXBlOiAnc2FsZXMnLCBcclxuICAgICAgICAgIGNvbG9yOiAnIzEwYjk4MScsXHJcbiAgICAgICAgICBzdGFydFRpbWU6ICcxMDoxMCcsXHJcbiAgICAgICAgICBlbmRUaW1lOiAnMTI6MDAnLFxyXG4gICAgICAgICAgc3RhdHVzZXM6IFsnc2FsZSddXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IFxyXG4gICAgICAgICAgdGltZTogJzEyOjMwIC0gMTU6MDAnLCBcclxuICAgICAgICAgIHR5cGU6ICdhbnR5c2FsZXMnLCBcclxuICAgICAgICAgIGNvbG9yOiAnI2Y1OWUwYicsXHJcbiAgICAgICAgICBzdGFydFRpbWU6ICcxMjozMCcsXHJcbiAgICAgICAgICBlbmRUaW1lOiAnMTU6MDAnLFxyXG4gICAgICAgICAgc3RhdHVzZXM6IFsnYW50eXNhbGUnXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBcclxuICAgICAgICAgIHRpbWU6ICcxNToxMCAtIDE2OjMwJywgXHJcbiAgICAgICAgICB0eXBlOiAnY2FudmFzICsgc2FsZXMnLCBcclxuICAgICAgICAgIGNvbG9yOiAnIzhiNWNmNicsXHJcbiAgICAgICAgICBzdGFydFRpbWU6ICcxNToxMCcsXHJcbiAgICAgICAgICBlbmRUaW1lOiAnMTY6MzAnLFxyXG4gICAgICAgICAgc3RhdHVzZXM6IFsnY2FudmFzJywgJ3NhbGUnXVxyXG4gICAgICAgIH0sXHJcbiAgICAgIF1cclxuXHJcbiAgICAgIC8vIFByenlwaXN6IGtsaWVudMOzdyBkbyBvZHBvd2llZG5pY2ggc2xvdMOzdyBuYSBwb2RzdGF3aWUgVFlMS08gY3phc3UgcHJ6eXBvbW5pZW5pYVxyXG4gICAgICBjb25zdCBzbG90c1dpdGhDbGllbnRzID0gdGltZVNsb3RzLm1hcChzbG90ID0+IHtcclxuICAgICAgICBjb25zdCBzbG90Q2xpZW50cyA9IGNsaWVudHNXaXRoUmVtaW5kZXJzLmZpbHRlcihjbGllbnQgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcmVtaW5kZXJUaW1lID0gY2xpZW50LnJlbWluZGVyPy50aW1lIHx8ICcwMDowMCdcclxuICAgICAgICAgIGNvbnN0IFtob3VycywgbWludXRlc10gPSByZW1pbmRlclRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgY29uc3QgcmVtaW5kZXJNaW51dGVzID0gaG91cnMgKiA2MCArIG1pbnV0ZXNcclxuXHJcbiAgICAgICAgICBjb25zdCBbc3RhcnRIb3Vycywgc3RhcnRNaW5zXSA9IHNsb3Quc3RhcnRUaW1lLnNwbGl0KCc6JykubWFwKE51bWJlcilcclxuICAgICAgICAgIGNvbnN0IFtlbmRIb3VycywgZW5kTWluc10gPSBzbG90LmVuZFRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgY29uc3Qgc3RhcnRNaW51dGVzID0gc3RhcnRIb3VycyAqIDYwICsgc3RhcnRNaW5zXHJcbiAgICAgICAgICBjb25zdCBlbmRNaW51dGVzID0gZW5kSG91cnMgKiA2MCArIGVuZE1pbnNcclxuXHJcbiAgICAgICAgICAvLyBTcHJhd2TFuiBjenkgZ29kemluYSBwcnp5cG9tbmllbmlhIG1pZcWbY2kgc2nEmSB3IHNsb2NpZSBjemFzb3d5bVxyXG4gICAgICAgICAgY29uc3QgdGltZUluU2xvdCA9IHJlbWluZGVyTWludXRlcyA+PSBzdGFydE1pbnV0ZXMgJiYgcmVtaW5kZXJNaW51dGVzIDw9IGVuZE1pbnV0ZXNcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCflZAgS2xpZW50ICR7Y2xpZW50LmZpcnN0X25hbWV9ICR7Y2xpZW50Lmxhc3RfbmFtZX06IGN6YXMgJHtyZW1pbmRlclRpbWV9ICgke3JlbWluZGVyTWludXRlc31taW4pIHZzIHNsb3QgJHtzbG90LnRpbWV9ICgke3N0YXJ0TWludXRlc30tJHtlbmRNaW51dGVzfW1pbikgPSAke3RpbWVJblNsb3QgPyAnUEFTVUpFJyA6ICdOSUUgUEFTVUpFJ31gKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gdGltZUluU2xvdFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFNsb3QgJHtzbG90LnRpbWV9OiAke3Nsb3RDbGllbnRzLmxlbmd0aH0ga2xpZW50w7N3YClcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4uc2xvdCxcclxuICAgICAgICAgIGNsaWVudHM6IHNsb3RDbGllbnRzXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYPCfk4ogUGxhbiBkbmlhIHogJHtzbG90c1dpdGhDbGllbnRzLnJlZHVjZSgoc3VtLCBzbG90KSA9PiBzdW0gKyBzbG90LmNsaWVudHMubGVuZ3RoLCAwKX0ga2xpZW50YW1pYClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzbG90c1dpdGhDbGllbnRzXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHR3b3J6ZW5pYSBwbGFudSBkbmlhOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRnVua2NqZSBBUEkgZGxhIGxvZ8OzdyBha3R5d25vxZtjaVxyXG5leHBvcnQgY29uc3QgYWN0aXZpdHlMb2dzQXBpID0ge1xyXG4gIC8vIFBvYmllcnogbG9naSBha3R5d25vxZtjaVxyXG4gIGFzeW5jIGdldExvZ3MoY2xpZW50SWQ/OiBzdHJpbmcpIHtcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdhY3Rpdml0eV9sb2dzJylcclxuICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgKixcclxuICAgICAgICBjbGllbnRzKGZpcnN0X25hbWUsIGxhc3RfbmFtZSlcclxuICAgICAgYClcclxuICAgICAgLm9yZGVyKCd0aW1lc3RhbXAnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuICAgICAgLmxpbWl0KDUwKVxyXG5cclxuICAgIGlmIChjbGllbnRJZCkge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjbGllbnRfaWQnLCBjbGllbnRJZClcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcmV0dXJuIGRhdGFcclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IGhpc3RvcmnEmSB6bWlhbiBkbGEga29ua3JldG5lZ28ga2xpZW50YVxyXG4gIGFzeW5jIGdldENsaWVudEhpc3RvcnkoY2xpZW50SWQ6IHN0cmluZyk6IFByb21pc2U8Q2xpZW50SGlzdG9yeVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUG9iaWVyYW5pZSBoaXN0b3JpaSBkbGEga2xpZW50YTonLCBjbGllbnRJZClcclxuICAgICAgXHJcbiAgICAgIC8vIFNwcmF3ZMW6IGN6eSB1xbx5dGtvd25payBqZXN0IHphbG9nb3dhbnlcclxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcclxuICAgICAgY29uc29sZS5sb2coJ0FrdHVhbG55IHXFvHl0a293bmlrOicsIHVzZXI/LmlkKVxyXG4gICAgICBcclxuICAgICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVcW8eXRrb3duaWsgbmllIGplc3QgemFsb2dvd2FueScpXHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBjbGllbnRfaWQsXHJcbiAgICAgICAgICBjaGFuZ2VkX2J5LFxyXG4gICAgICAgICAgY2hhbmdlX3R5cGUsXHJcbiAgICAgICAgICBmaWVsZF9jaGFuZ2VkLFxyXG4gICAgICAgICAgb2xkX3ZhbHVlLFxyXG4gICAgICAgICAgbmV3X3ZhbHVlLFxyXG4gICAgICAgICAgdGltZXN0YW1wXHJcbiAgICAgICAgYClcclxuICAgICAgICAuZXEoJ2NsaWVudF9pZCcsIGNsaWVudElkKVxyXG4gICAgICAgIC5vcmRlcigndGltZXN0YW1wJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgICAgLmxpbWl0KDIwKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignQsWCxIVkIHF1ZXJ5IGFjdGl2aXR5X2xvZ3M6JywgZXJyb3IpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU3pjemVnw7PFgnkgYsWCxJlkdTonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3ByYXdkxbogY3p5IHRvIHByb2JsZW0geiBSTFNcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2JyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnUkxTJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2JsZW0geiBSb3cgTGV2ZWwgU2VjdXJpdHkgLSB1xbx5dGtvd25payBtb8W8ZSBuaWUgbWllxIcgZG9zdMSZcHUnKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBad3LDs8SHIHB1c3TEhSB0YWJsaWPEmSB6YW1pYXN0IHJ6dWNhbmlhIGLFgsSZZGVtXHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdQb2JyYW5vIGxvZ2k6JywgZGF0YT8ubGVuZ3RoIHx8IDApXHJcblxyXG4gICAgICAvLyBKZcWbbGkgbmllIG1hIGxvZ8Ozdywgendyw7PEhyBwdXN0xIUgdGFibGljxJlcclxuICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBvYmllcnogaW5mb3JtYWNqZSBvIHXFvHl0a293bmlrYWNoIG9zb2JubyB6IGF2YXRhcmFtaVxyXG4gICAgICBjb25zdCB1c2VySWRzID0gWy4uLm5ldyBTZXQoZGF0YS5tYXAobG9nID0+IGxvZy5jaGFuZ2VkX2J5KS5maWx0ZXIoQm9vbGVhbikpXVxyXG4gICAgICBjb25zb2xlLmxvZygnUG9iaWVyYW5pZSB1xbx5dGtvd25pa8OzdzonLCB1c2VySWRzKVxyXG5cclxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VycywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCwgZnVsbF9uYW1lLCByb2xlLCBhdmF0YXJfdXJsJylcclxuICAgICAgICAuaW4oJ2lkJywgdXNlcklkcylcclxuXHJcbiAgICAgIGlmICh1c2Vyc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignQsWCxIVkIHBvYmllcmFuaWEgdcW8eXRrb3duaWvDs3c6JywgdXNlcnNFcnJvcilcclxuICAgICAgICAvLyBLb250eW51dWogYmV6IGRhbnljaCB1xbx5dGtvd25pa8Ozd1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnUG9icmFubyB1xbx5dGtvd25pa8OzdzonLCB1c2Vycz8ubGVuZ3RoIHx8IDApXHJcblxyXG4gICAgICAvLyBNYXB1aiB1xbx5dGtvd25pa8OzdyBkbyBzxYJvd25pa2EgZGxhIHN6eWJraWVnbyBkb3N0xJlwdVxyXG4gICAgICBjb25zdCB1c2Vyc01hcCA9ICh1c2VycyB8fCBbXSkucmVkdWNlKChhY2MsIHVzZXIpID0+IHtcclxuICAgICAgICBhY2NbdXNlci5pZF0gPSB1c2VyXHJcbiAgICAgICAgcmV0dXJuIGFjY1xyXG4gICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxyXG5cclxuICAgICAgLy8gUHJ6ZWtzenRhxYLEhyBkYW5lIHogaW5mb3JtYWNqYW1pIG8gZWR5dG9yemVcclxuICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YS5tYXAoKGxvZzogYW55KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IHVzZXJzTWFwW2xvZy5jaGFuZ2VkX2J5XVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogbG9nLmlkLFxyXG4gICAgICAgICAgY2xpZW50X2lkOiBsb2cuY2xpZW50X2lkLFxyXG4gICAgICAgICAgY2hhbmdlZF9ieTogbG9nLmNoYW5nZWRfYnksXHJcbiAgICAgICAgICBjaGFuZ2VfdHlwZTogbG9nLmNoYW5nZV90eXBlLFxyXG4gICAgICAgICAgZmllbGRfY2hhbmdlZDogbG9nLmZpZWxkX2NoYW5nZWQsXHJcbiAgICAgICAgICBvbGRfdmFsdWU6IGxvZy5vbGRfdmFsdWUsXHJcbiAgICAgICAgICBuZXdfdmFsdWU6IGxvZy5uZXdfdmFsdWUsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IGxvZy50aW1lc3RhbXAsXHJcbiAgICAgICAgICBlZGl0b3JfbmFtZTogdXNlcj8uZnVsbF9uYW1lIHx8IGxvZy5jaGFuZ2VkX2J5IHx8ICdOaWV6bmFueSB1xbx5dGtvd25paycsXHJcbiAgICAgICAgICBlZGl0b3Jfcm9sZTogdXNlcj8ucm9sZSB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICBlZGl0b3JfYXZhdGFyOiB1c2VyPy5hdmF0YXJfdXJsIHx8IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnWndyYWNhbmllIGhpc3RvcmlpOicsIHJlc3VsdC5sZW5ndGgsICd3cGlzw7N3JylcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0LFgsSFZCB3IGdldENsaWVudEhpc3Rvcnk6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gRG9kYWogbG9nIGFrdHl3bm/Fm2NpXHJcbiAgYXN5bmMgY3JlYXRlTG9nKGxvZzogT21pdDxBY3Rpdml0eUxvZywgJ2lkJyB8ICd0aW1lc3RhbXAnPikge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAuaW5zZXJ0KFt7XHJcbiAgICAgICAgLi4ubG9nLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH1dKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpXHJcbiAgICBcclxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgIHJldHVybiBkYXRhIGFzIEFjdGl2aXR5TG9nXHJcbiAgfSxcclxuXHJcbiAgLy8gRnVua2NqYSB0ZXN0b3dhIGRvIHNwcmF3ZHphbmlhIGRvc3TEmXB1IGRvIGFjdGl2aXR5X2xvZ3NcclxuICBhc3luYyB0ZXN0QWN0aXZpdHlMb2dzQWNjZXNzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rlc3Rvd2FuaWUgZG9zdMSZcHUgZG8gYWN0aXZpdHlfbG9ncy4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBTcHJhd2TFuiBhdXRvcnl6YWNqxJlcclxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcclxuICAgICAgY29uc29sZS5sb2coJ1Rlc3QgLSB1xbx5dGtvd25pazonLCB1c2VyPy5pZCwgdXNlcj8uZW1haWwpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICAgIGVycm9yOiAnQnJhayBhdXRvcnl6YWNqaSAtIHXFvHl0a293bmlrIG5pZSBqZXN0IHphbG9nb3dhbnknIFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogY3p5IHXFvHl0a293bmlrIGlzdG5pZWplIHcgdGFiZWxpIHVzZXJzXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlclByb2ZpbGUsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCwgZW1haWwsIHJvbGUnKVxyXG4gICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVGVzdCAtIHByb2ZpbCB1xbx5dGtvd25pa2E6JywgdXNlclByb2ZpbGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUZXN0IC0gYsWCxIVkIHByb2ZpbHU6JywgdXNlckVycm9yKVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXJFcnJvciB8fCAhdXNlclByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4geyBcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICAgIGVycm9yOiAnVcW8eXRrb3duaWsgbmllIGlzdG5pZWplIHcgdGFiZWxpIHVzZXJzJyBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRlc3R1aiBkb3N0xJlwIGRvIGFjdGl2aXR5X2xvZ3NcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXHJcbiAgICAgICAgLmxpbWl0KDEpXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnVGVzdCBhY3Rpdml0eV9sb2dzIC0gZGF0YTonLCBkYXRhKVxyXG4gICAgICBjb25zb2xlLmxvZygnVGVzdCBhY3Rpdml0eV9sb2dzIC0gZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUZXN0IGFjdGl2aXR5X2xvZ3MgLSBjb3VudDonLCBjb3VudClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIHN1Y2Nlc3M6ICFlcnJvciwgXHJcbiAgICAgICAgZGF0YSwgXHJcbiAgICAgICAgZXJyb3IsIFxyXG4gICAgICAgIGNvdW50LFxyXG4gICAgICAgIHVzZXI6IHVzZXJQcm9maWxlXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0LFgsSFZCB0ZXN0dSBhY3Rpdml0eV9sb2dzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3IgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gVHlweSBkbGEgc3RhdHlzdHlrIHByYWNvd25pa8Ozd1xyXG5leHBvcnQgaW50ZXJmYWNlIEVtcGxveWVlU3RhdHMge1xyXG4gIGlkOiBzdHJpbmdcclxuICB1c2VyX2lkOiBzdHJpbmdcclxuICBkYWlseV90YXJnZXQ6IG51bWJlclxyXG4gIGNvbW1pc3Npb25fcmF0ZTogbnVtYmVyXHJcbiAgbW9udGhseV9jYW52YXM6IG51bWJlclxyXG4gIG1vbnRobHlfYW50eXNhbGU6IG51bWJlclxyXG4gIG1vbnRobHlfc2FsZTogbnVtYmVyXHJcbiAgdG90YWxfY29tbWlzc2lvbnM6IG51bWJlclxyXG4gIHRvdGFsX3BlbmFsdGllczogbnVtYmVyXHJcbiAgLy8gUG9sYSBkbyBlZHljamkgcsSZY3puZWpcclxuICBjdXN0b21fY2xpZW50c19jb3VudD86IG51bWJlclxyXG4gIGN1c3RvbV90b3RhbF9wYXltZW50cz86IG51bWJlclxyXG4gIC8vIERvZGF0a293ZSBkYW5lIHogSk9JTlxyXG4gIHVzZXI/OiB7XHJcbiAgICBpZDogc3RyaW5nXHJcbiAgICBmdWxsX25hbWU6IHN0cmluZ1xyXG4gICAgZW1haWw6IHN0cmluZ1xyXG4gICAgYXZhdGFyX3VybD86IHN0cmluZ1xyXG4gICAgcm9sZTogc3RyaW5nXHJcbiAgfVxyXG4gIC8vIE9ibGljem9uZSBuYSBwb2RzdGF3aWUgZGFueWNoIHogY2xpZW50c1xyXG4gIGRhaWx5X2FjaGlldmVkPzogbnVtYmVyXHJcbiAgeWVzdGVyZGF5X3Nob3J0YWdlPzogbnVtYmVyXHJcbiAgc3RhdHVzX2NoYW5nZXNfdG9kYXk/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XHJcbn1cclxuXHJcbi8vIEZ1bmtjamUgQVBJIGRsYSByYXBvcnTDs3dcclxuZXhwb3J0IGNvbnN0IHJlcG9ydHNBcGkgPSB7XHJcbiAgLy8gUG9iaWVyeiBzdGF0eXN0eWtpIHR5bGtvIHByYWNvd25pa8OzdyB6IHByb3dpemrEhVxyXG4gIGFzeW5jIGdldEVtcGxveWVlU3RhdHModXNlcjogVXNlcik6IFByb21pc2U8RW1wbG95ZWVTdGF0c1tdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBQb2JpZXJhbmllIHN0YXR5c3R5ayBwcmFjb3duaWvDs3cuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gS1JPSyAxOiBQb2JpZXJ6IHdzenlzdGtpY2ggdcW8eXRrb3duaWvDs3cgeiByb2zEhSAncHJhY293bmlrJ1xyXG4gICAgICBjb25zdCB7IGRhdGE6IGFsbEVtcGxveWVlcywgZXJyb3I6IHVzZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgZnVsbF9uYW1lLFxyXG4gICAgICAgICAgZW1haWwsXHJcbiAgICAgICAgICBhdmF0YXJfdXJsLFxyXG4gICAgICAgICAgcm9sZVxyXG4gICAgICAgIGApXHJcbiAgICAgICAgLmVxKCdyb2xlJywgJ3ByYWNvd25paycpXHJcbiAgICAgICAgLm9yZGVyKCdmdWxsX25hbWUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG5cclxuICAgICAgaWYgKHVzZXJzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgdcW8eXRrb3duaWvDs3ctcHJhY293bmlrw7N3OicsIHVzZXJzRXJyb3IpXHJcbiAgICAgICAgdGhyb3cgdXNlcnNFcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWFsbEVtcGxveWVlcyB8fCBhbGxFbXBsb3llZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBCcmFrIHXFvHl0a293bmlrw7N3IHogcm9sxIUgcHJhY293bmlrJylcclxuICAgICAgICByZXR1cm4gW11cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQb2JyYW5vIHdzenlzdGtpY2ggcHJhY293bmlrw7N3OicsIGFsbEVtcGxveWVlcy5sZW5ndGgsIGFsbEVtcGxveWVlcy5tYXAoZSA9PiBlLmZ1bGxfbmFtZSkpXHJcblxyXG4gICAgICAvLyBLUk9LIDI6IFBvYmllcnogc3RhdHlzdHlraSB6IHRhYmVsaSBlbXBsb3llZV9zdGF0cyBkbGEgdHljaCBwcmFjb3duaWvDs3dcclxuICAgICAgY29uc3QgZW1wbG95ZWVJZHMgPSBhbGxFbXBsb3llZXMubWFwKGVtcCA9PiBlbXAuaWQpXHJcbiAgICAgIGxldCBleGlzdGluZ1N0YXRzOiBhbnlbXSA9IFtdXHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHN0YXRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnZW1wbG95ZWVfc3RhdHMnKVxyXG4gICAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgICAuaW4oJ3VzZXJfaWQnLCBlbXBsb3llZUlkcylcclxuXHJcbiAgICAgICAgaWYgKHN0YXRzRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIELFgsSFZCBwb2JpZXJhbmlhIGVtcGxveWVlX3N0YXRzOicsIHN0YXRzRXJyb3IpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4aXN0aW5nU3RhdHMgPSBkYXRhIHx8IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIGVtcGxveWVlX3N0YXRzOicsIGVycm9yKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBvYnJhbm8gc3RhdHlzdHlraSBkbGEgcHJhY293bmlrw7N3OicsIGV4aXN0aW5nU3RhdHM/Lmxlbmd0aCB8fCAwKVxyXG5cclxuICAgICAgLy8gS1JPSyAzOiBQb2JpZXJ6IGR6aXNpZWpzemUgc3RhdHlzdHlraSB6IHRhYmVsaSBjbGllbnRzICh6IG9ic8WCdWfEhSBixYLEmWTDs3cpXHJcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cclxuICAgICAgbGV0IHRvZGF5Q2xpZW50czogYW55W10gPSBbXVxyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBjbGllbnRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgICAuc2VsZWN0KCdzdGF0dXMsIGVkaXRlZF9ieSwgY3JlYXRlZF9hdCwgdXBkYXRlZF9hdCcpXHJcbiAgICAgICAgICAuZ3RlKCd1cGRhdGVkX2F0JywgYCR7dG9kYXl9VDAwOjAwOjAwYClcclxuICAgICAgICAgIC5sdCgndXBkYXRlZF9hdCcsIGAke3RvZGF5fVQyMzo1OTo1OWApXHJcblxyXG4gICAgICAgIGlmIChjbGllbnRzRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIELFgsSFZCBwb2JpZXJhbmlhIGtsaWVudMOzdyB6IGR6aXNpYWo6JywgY2xpZW50c0Vycm9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0b2RheUNsaWVudHMgPSBkYXRhIHx8IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIGR6aXNpZWpzenljaCBrbGllbnTDs3c6JywgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUG9icmFubyBkemlzaWVqc3p5Y2gga2xpZW50w7N3OicsIHRvZGF5Q2xpZW50cy5sZW5ndGgpXHJcblxyXG4gICAgICAvLyBLUk9LIDQ6IFBvYmllcnogd2N6b3JhanN6ZSBzdGF0eXN0eWtpIGRsYSBrYXIgKHogb2JzxYJ1Z8SFIGLFgsSZZMOzdylcclxuICAgICAgY29uc3QgeWVzdGVyZGF5ID0gbmV3IERhdGUoKVxyXG4gICAgICB5ZXN0ZXJkYXkuc2V0RGF0ZSh5ZXN0ZXJkYXkuZ2V0RGF0ZSgpIC0gMSlcclxuICAgICAgY29uc3QgeWVzdGVyZGF5U3RyID0geWVzdGVyZGF5LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxyXG4gICAgICBsZXQgeWVzdGVyZGF5Q2xpZW50czogYW55W10gPSBbXVxyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB5ZXN0ZXJkYXlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAgIC5zZWxlY3QoJ3N0YXR1cywgZWRpdGVkX2J5JylcclxuICAgICAgICAgIC5ndGUoJ3VwZGF0ZWRfYXQnLCBgJHt5ZXN0ZXJkYXlTdHJ9VDAwOjAwOjAwYClcclxuICAgICAgICAgIC5sdCgndXBkYXRlZF9hdCcsIGAke3llc3RlcmRheVN0cn1UMjM6NTk6NTlgKVxyXG5cclxuICAgICAgICBpZiAoeWVzdGVyZGF5RXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIELFgsSFZCBwb2JpZXJhbmlhIHdjem9yYWpzenljaCBrbGllbnTDs3c6JywgeWVzdGVyZGF5RXJyb3IpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllc3RlcmRheUNsaWVudHMgPSBkYXRhIHx8IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIHdjem9yYWpzenljaCBrbGllbnTDs3c6JywgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEtST0sgNTogUG9iaWVyeiBXU1pZU1RLSUNIIGtsaWVudMOzdyBwcnp5cGlzYW55Y2ggZG8gcHJhY293bmlrw7N3ICh6IG9ic8WCdWfEhSBixYLEmWTDs3cpXHJcbiAgICAgIGxldCBhbGxPd25lZENsaWVudHM6IGFueVtdID0gW11cclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogb3duZWRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAgIC5zZWxlY3QoJ3N0YXR1cywgb3duZXJfaWQnKVxyXG4gICAgICAgICAgLm5vdCgnb3duZXJfaWQnLCAnaXMnLCBudWxsKVxyXG4gICAgICAgICAgLmluKCdvd25lcl9pZCcsIGVtcGxveWVlSWRzKVxyXG5cclxuICAgICAgICBpZiAob3duZWRFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gQsWCxIVkIHBvYmllcmFuaWEga2xpZW50w7N3IHByenlwaXNhbnljaDonLCBvd25lZEVycm9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhbGxPd25lZENsaWVudHMgPSBkYXRhIHx8IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIHByenlwaXNhbnljaCBrbGllbnTDs3c6JywgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUG9icmFubyB3c3p5c3RraWNoIHByenlwaXNhbnljaCBrbGllbnTDs3c6JywgYWxsT3duZWRDbGllbnRzLmxlbmd0aClcclxuXHJcbiAgICAgIC8vIEtST0sgNjogQWdyZWd1aiBkemlzaWVqc3plIHN0YXR5c3R5a2kgcGVyIHByYWNvd25pa1xyXG4gICAgICBjb25zdCB0b2RheVN0YXRzID0gdG9kYXlDbGllbnRzLnJlZHVjZSgoYWNjOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBjbGllbnQpID0+IHtcclxuICAgICAgICBjb25zdCB1c2VySWQgPSBjbGllbnQuZWRpdGVkX2J5XHJcbiAgICAgICAgaWYgKCF1c2VySWQpIHJldHVybiBhY2NcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWFjY1t1c2VySWRdKSB7XHJcbiAgICAgICAgICBhY2NbdXNlcklkXSA9IHsgdG90YWw6IDAsIGNhbnZhczogMCwgYW50eXNhbGU6IDAsIHNhbGU6IDAsIG90aGVyOiAwIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWNjW3VzZXJJZF0udG90YWwrK1xyXG4gICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAnY2FudmFzJykgYWNjW3VzZXJJZF0uY2FudmFzKytcclxuICAgICAgICBlbHNlIGlmIChjbGllbnQuc3RhdHVzID09PSAnYW50eXNhbGUnKSBhY2NbdXNlcklkXS5hbnR5c2FsZSsrXHJcbiAgICAgICAgZWxzZSBpZiAoY2xpZW50LnN0YXR1cyA9PT0gJ3NhbGUnKSBhY2NbdXNlcklkXS5zYWxlKytcclxuICAgICAgICBlbHNlIGFjY1t1c2VySWRdLm90aGVyKytcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYWNjXHJcbiAgICAgIH0sIHt9KVxyXG5cclxuICAgICAgLy8gS1JPSyA3OiBBZ3JlZ3VqIHdjem9yYWpzemUgc3RhdHlzdHlraSBwZXIgcHJhY293bmlrXHJcbiAgICAgIGNvbnN0IHllc3RlcmRheVN0YXRzID0geWVzdGVyZGF5Q2xpZW50cy5yZWR1Y2UoKGFjYzogUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgY2xpZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gY2xpZW50LmVkaXRlZF9ieVxyXG4gICAgICAgIGlmICh1c2VySWQpIHtcclxuICAgICAgICAgIGFjY1t1c2VySWRdID0gKGFjY1t1c2VySWRdIHx8IDApICsgMVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjXHJcbiAgICAgIH0sIHt9KVxyXG5cclxuICAgICAgLy8gS1JPSyA4OiBBZ3JlZ3VqIHN0YXR1c3kgV1NaWVNUS0lDSCBwcnp5cGlzYW55Y2gga2xpZW50w7N3IHBlciBwcmFjb3duaWtcclxuICAgICAgY29uc3Qgb3duZWRDbGllbnRzU3RhdHMgPSBhbGxPd25lZENsaWVudHMucmVkdWNlKChhY2M6IFJlY29yZDxzdHJpbmcsIGFueT4sIGNsaWVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG93bmVySWQgPSBjbGllbnQub3duZXJfaWRcclxuICAgICAgICBpZiAoIW93bmVySWQpIHJldHVybiBhY2NcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWFjY1tvd25lcklkXSkge1xyXG4gICAgICAgICAgYWNjW293bmVySWRdID0geyB0b3RhbDogMCwgY2FudmFzOiAwLCBhbnR5c2FsZTogMCwgc2FsZTogMCwgYnJha19rb250YWt0dTogMCwgbmllX3phaW50ZXJlc293YW55OiAwLCB6ZGVuZXJ3b3dhbnk6IDAsICckJCc6IDAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBhY2Nbb3duZXJJZF0udG90YWwrK1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoY2xpZW50LnN0YXR1cykge1xyXG4gICAgICAgICAgY2FzZSAnY2FudmFzJzpcclxuICAgICAgICAgICAgYWNjW293bmVySWRdLmNhbnZhcysrXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdhbnR5c2FsZSc6XHJcbiAgICAgICAgICAgIGFjY1tvd25lcklkXS5hbnR5c2FsZSsrXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdzYWxlJzpcclxuICAgICAgICAgICAgYWNjW293bmVySWRdLnNhbGUrK1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnYnJha19rb250YWt0dSc6XHJcbiAgICAgICAgICAgIGFjY1tvd25lcklkXS5icmFrX2tvbnRha3R1KytcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgJ25pZV96YWludGVyZXNvd2FueSc6XHJcbiAgICAgICAgICAgIGFjY1tvd25lcklkXS5uaWVfemFpbnRlcmVzb3dhbnkrK1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnemRlbmVyd293YW55JzpcclxuICAgICAgICAgICAgYWNjW293bmVySWRdLnpkZW5lcndvd2FueSsrXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICckJCc6XHJcbiAgICAgICAgICAgIGFjY1tvd25lcklkXVsnJCQnXSsrXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBhY2NcclxuICAgICAgfSwge30pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBTdGF0eXN0eWtpIHByenlwaXNhbnljaCBrbGllbnTDs3c6Jywgb3duZWRDbGllbnRzU3RhdHMpXHJcblxyXG4gICAgICAvLyBLUk9LIDk6IFN0d8OzcnogbWFwxJkgc3RhdHlzdHlrIGVtcGxveWVlX3N0YXRzXHJcbiAgICAgIGNvbnN0IHN0YXRzTWFwID0gbmV3IE1hcCgpXHJcbiAgICAgIGV4aXN0aW5nU3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcclxuICAgICAgICBzdGF0c01hcC5zZXQoc3RhdC51c2VyX2lkLCBzdGF0KVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gS1JPSyAxMDogS29tYmludWogZGFuZSAtIGRsYSBXU1pZU1RLSUNIIHByYWNvd25pa8OzdyAoemF3c3plIHp3cmFjYSBsaXN0xJkpXHJcbiAgICAgIGNvbnN0IGVuaGFuY2VkU3RhdHM6IEVtcGxveWVlU3RhdHNbXSA9IGFsbEVtcGxveWVlcy5tYXAoZW1wbG95ZWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IGVtcGxveWVlLmlkXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUG9iaWVyeiBzdGF0eXN0eWtpIHogZW1wbG95ZWVfc3RhdHMgbHViIHV0d8OzcnogZG9tecWbbG5lXHJcbiAgICAgICAgY29uc3QgYmFzaWNTdGF0ID0gc3RhdHNNYXAuZ2V0KHVzZXJJZCkgfHwge1xyXG4gICAgICAgICAgaWQ6ICd0ZW1wXycgKyB1c2VySWQsXHJcbiAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXHJcbiAgICAgICAgICBkYWlseV90YXJnZXQ6IDIwLFxyXG4gICAgICAgICAgY29tbWlzc2lvbl9yYXRlOiAzLjAsXHJcbiAgICAgICAgICBtb250aGx5X2NhbnZhczogMCxcclxuICAgICAgICAgIG1vbnRobHlfYW50eXNhbGU6IDAsXHJcbiAgICAgICAgICBtb250aGx5X3NhbGU6IDAsXHJcbiAgICAgICAgICB0b3RhbF9jb21taXNzaW9uczogMCxcclxuICAgICAgICAgIHRvdGFsX3BlbmFsdGllczogMCxcclxuICAgICAgICAgIGN1c3RvbV9jbGllbnRzX2NvdW50OiAwLFxyXG4gICAgICAgICAgY3VzdG9tX3RvdGFsX3BheW1lbnRzOiAwLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHRvZGF5Rm9yVXNlciA9IHRvZGF5U3RhdHNbdXNlcklkXSB8fCB7IHRvdGFsOiAwLCBjYW52YXM6IDAsIGFudHlzYWxlOiAwLCBzYWxlOiAwIH1cclxuICAgICAgICBjb25zdCB5ZXN0ZXJkYXlGb3JVc2VyID0geWVzdGVyZGF5U3RhdHNbdXNlcklkXSB8fCAwXHJcbiAgICAgICAgY29uc3Qgb3duZWRGb3JVc2VyID0gb3duZWRDbGllbnRzU3RhdHNbdXNlcklkXSB8fCB7IFxyXG4gICAgICAgICAgdG90YWw6IDAsIFxyXG4gICAgICAgICAgY2FudmFzOiAwLCBcclxuICAgICAgICAgIGFudHlzYWxlOiAwLCBcclxuICAgICAgICAgIHNhbGU6IDAsIFxyXG4gICAgICAgICAgYnJha19rb250YWt0dTogMCwgXHJcbiAgICAgICAgICBuaWVfemFpbnRlcmVzb3dhbnk6IDAsIFxyXG4gICAgICAgICAgemRlbmVyd293YW55OiAwLCBcclxuICAgICAgICAgICckJCc6IDAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE9ibGljeiBrYXLEmSB6YSB3Y3pvcmFqXHJcbiAgICAgICAgY29uc3QgeWVzdGVyZGF5U2hvcnRhZ2UgPSBNYXRoLm1heCgwLCBiYXNpY1N0YXQuZGFpbHlfdGFyZ2V0IC0geWVzdGVyZGF5Rm9yVXNlcilcclxuICAgICAgICBjb25zdCBwZW5hbHR5ID0geWVzdGVyZGF5U2hvcnRhZ2UgKiAxNVxyXG5cclxuICAgICAgICAvLyBPYmxpY3ogcHJvd2l6asSZIG5hIHBvZHN0YXdpZSBwcnp5cGlzYW55Y2gga2xpZW50w7N3IFNhbGVcclxuICAgICAgICBjb25zdCBjb21taXNzaW9uID0gKG93bmVkRm9yVXNlci5zYWxlICogYmFzaWNTdGF0LmNvbW1pc3Npb25fcmF0ZSAvIDEwMCkgKiAxMDBcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfkaQgUHJhY293bmlrICR7ZW1wbG95ZWUuZnVsbF9uYW1lfTogQ2FudmFzPSR7b3duZWRGb3JVc2VyLmNhbnZhc30sIEFudHlTPSR7b3duZWRGb3JVc2VyLmFudHlzYWxlfSwgU2FsZT0ke293bmVkRm9yVXNlci5zYWxlfWApXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAuLi5iYXNpY1N0YXQsXHJcbiAgICAgICAgICAvLyBXQcW7TkU6IERvxYLEhWN6IGRhbmUgdcW8eXRrb3duaWthXHJcbiAgICAgICAgICB1c2VyOiB7XHJcbiAgICAgICAgICAgIGlkOiBlbXBsb3llZS5pZCxcclxuICAgICAgICAgICAgZnVsbF9uYW1lOiBlbXBsb3llZS5mdWxsX25hbWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiBlbXBsb3llZS5lbWFpbCxcclxuICAgICAgICAgICAgYXZhdGFyX3VybDogZW1wbG95ZWUuYXZhdGFyX3VybCxcclxuICAgICAgICAgICAgcm9sZTogZW1wbG95ZWUucm9sZVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRhaWx5X2FjaGlldmVkOiB0b2RheUZvclVzZXIudG90YWwsXHJcbiAgICAgICAgICB5ZXN0ZXJkYXlfc2hvcnRhZ2U6IHllc3RlcmRheVNob3J0YWdlLFxyXG4gICAgICAgICAgc3RhdHVzX2NoYW5nZXNfdG9kYXk6IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0b2RheUZvclVzZXIuY2FudmFzLFxyXG4gICAgICAgICAgICBhbnR5c2FsZTogdG9kYXlGb3JVc2VyLmFudHlzYWxlLFxyXG4gICAgICAgICAgICBzYWxlOiB0b2RheUZvclVzZXIuc2FsZSxcclxuICAgICAgICAgICAgb3RoZXI6IHRvZGF5Rm9yVXNlci5vdGhlclxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIC8vIFXFvHl3YWogc3RhdHlzdHlrIG9wYXJ0eWNoIG5hIG93bmVyX2lkIChwcnp5cGlzYW55Y2gga2xpZW50w7N3KVxyXG4gICAgICAgICAgbW9udGhseV9jYW52YXM6IG93bmVkRm9yVXNlci5jYW52YXMsXHJcbiAgICAgICAgICBtb250aGx5X2FudHlzYWxlOiBvd25lZEZvclVzZXIuYW50eXNhbGUsXHJcbiAgICAgICAgICBtb250aGx5X3NhbGU6IG93bmVkRm9yVXNlci5zYWxlLFxyXG4gICAgICAgICAgdG90YWxfY29tbWlzc2lvbnM6IGNvbW1pc3Npb24sXHJcbiAgICAgICAgICB0b3RhbF9wZW5hbHRpZXM6IHBlbmFsdHlcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFByenlnb3Rvd2FubyByb3pzemVyem9uZSBzdGF0eXN0eWtpIGRsYSB3c3p5c3RraWNoIHByYWNvd25pa8OzdzonLCBlbmhhbmNlZFN0YXRzLmxlbmd0aClcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgTGlzdGEgcHJhY293bmlrw7N3OicsIGVuaGFuY2VkU3RhdHMubWFwKHMgPT4gcy51c2VyPy5mdWxsX25hbWUpLmpvaW4oJywgJykpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZW5oYW5jZWRTdGF0c1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBzdGF0eXN0eWsgcHJhY293bmlrw7N3OicsIGVycm9yKVxyXG4gICAgICAvLyBXIHByenlwYWRrdSBixYLEmWR1LCB6d3LDs8SHIHB1c3TEhSBsaXN0xJkgemFtaWFzdCByenVjYcSHIGLFgsSFZFxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2RzdW1vd2FuaWUgZG5pYVxyXG4gIGFzeW5jIGdldERhaWx5U3VtbWFyeShkYXRlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgLnNlbGVjdCgnc3RhdHVzLCBlZGl0ZWRfYnknKVxyXG4gICAgICAuZ3RlKCd1cGRhdGVkX2F0JywgYCR7ZGF0ZX1UMDA6MDA6MDBgKVxyXG4gICAgICAubHQoJ3VwZGF0ZWRfYXQnLCBgJHtkYXRlfVQyMzo1OTo1OWApXHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAgIC8vIEFncmVnYWNqYSBkYW55Y2hcclxuICAgIGNvbnN0IHN0YXR1c0JyZWFrZG93biA9IGRhdGEucmVkdWNlKChhY2M6IGFueSwgY2xpZW50KSA9PiB7XHJcbiAgICAgIGFjY1tjbGllbnQuc3RhdHVzXSA9IChhY2NbY2xpZW50LnN0YXR1c10gfHwgMCkgKyAxXHJcbiAgICAgIHJldHVybiBhY2NcclxuICAgIH0sIHt9KVxyXG5cclxuICAgIGNvbnN0IGVtcGxveWVlU3RhdHMgPSBkYXRhLnJlZHVjZSgoYWNjOiBhbnksIGNsaWVudCkgPT4ge1xyXG4gICAgICBhY2NbY2xpZW50LmVkaXRlZF9ieV0gPSAoYWNjW2NsaWVudC5lZGl0ZWRfYnldIHx8IDApICsgMVxyXG4gICAgICByZXR1cm4gYWNjXHJcbiAgICB9LCB7fSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbENsaWVudHM6IGRhdGEubGVuZ3RoLFxyXG4gICAgICBzdGF0dXNCcmVha2Rvd24sXHJcbiAgICAgIGVtcGxveWVlU3RhdHNcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2RzdW1vd2FuaWUgdHlnb2RuaW93ZVxyXG4gIGFzeW5jIGdldFdlZWtseVN1bW1hcnkoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2NsaWVudHMnKVxyXG4gICAgICAuc2VsZWN0KCdzdGF0dXMsIGVkaXRlZF9ieSwgdXBkYXRlZF9hdCcpXHJcbiAgICAgIC5ndGUoJ3VwZGF0ZWRfYXQnLCBzdGFydERhdGUpXHJcbiAgICAgIC5sdCgndXBkYXRlZF9hdCcsIGVuZERhdGUpXHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcmV0dXJuIGRhdGFcclxuICB9LFxyXG5cclxuICAvLyBBa3R1YWxpenVqIHN0YXR5c3R5a2kgcHJhY293bmlrYSAoZGxhIG1hbmFnZXIvcHJvamVjdF9tYW5hZ2VyL2p1bmlvcl9tYW5hZ2VyL3N6ZWYvYWRtaW4pXHJcbiAgYXN5bmMgdXBkYXRlRW1wbG95ZWVTdGF0cyh1c2VySWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxFbXBsb3llZVN0YXRzPiwgY3VycmVudFVzZXI6IFVzZXIpIHtcclxuICAgIC8vIFNwcmF3ZMW6IHVwcmF3bmllbmlhXHJcbiAgICBpZiAoIVsnbWFuYWdlcicsICdwcm9qZWN0X21hbmFnZXInLCAnanVuaW9yX21hbmFnZXInLCAnc3plZicsICdhZG1pbiddLmluY2x1ZGVzKGN1cnJlbnRVc2VyLnJvbGUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJhayB1cHJhd25pZcWEIGRvIG1vZHlmaWthY2ppIHN0YXR5c3R5aycpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2VtcGxveWVlX3N0YXRzJylcclxuICAgICAgLnVwZGF0ZSh1cGRhdGVzKVxyXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKClcclxuXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH0sXHJcblxyXG4gIC8vIEVkeXR1aiBpbG/Fm8SHIGtsaWVudMOzdyBpIHN1bcSZIHdwxYJhdCBwcmFjb3duaWthIChkbGEgbWFuYWdlci9wcm9qZWN0X21hbmFnZXIvanVuaW9yX21hbmFnZXIvc3plZi9hZG1pbilcclxuICBhc3luYyB1cGRhdGVFbXBsb3llZUNsaWVudFN0YXRzKHVzZXJJZDogc3RyaW5nLCBjbGllbnRzQ291bnQ6IG51bWJlciwgdG90YWxQYXltZW50czogbnVtYmVyLCBjdXJyZW50VXNlcjogVXNlcikge1xyXG4gICAgLy8gU3ByYXdkxbogdXByYXduaWVuaWFcclxuICAgIGlmICghWydtYW5hZ2VyJywgJ3Byb2plY3RfbWFuYWdlcicsICdqdW5pb3JfbWFuYWdlcicsICdzemVmJywgJ2FkbWluJ10uaW5jbHVkZXMoY3VycmVudFVzZXIucm9sZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcmFrIHVwcmF3bmllxYQgZG8gbW9keWZpa2Fjamkgc3RhdHlzdHlrJylcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBBa3R1YWxpenVqxJkgc3RhdHlzdHlraSBwcmFjb3duaWthICR7dXNlcklkfToga2xpZW5jaT0ke2NsaWVudHNDb3VudH0sIHdwxYJhdHk9JHt0b3RhbFBheW1lbnRzfWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBNRVRPREEgMTogU3Byw7NidWogcHJvc3TEhSBha3R1YWxpemFjasSZIHcgZW1wbG95ZWVfc3RhdHNcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TnSBQcsOzYmEgcHJvc3RlaiBha3R1YWxpemFjamkgdyBlbXBsb3llZV9zdGF0cycpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbGVnYWN5VXBkYXRlcyA9IHtcclxuICAgICAgICAgIGN1c3RvbV9jbGllbnRzX2NvdW50OiBjbGllbnRzQ291bnQsXHJcbiAgICAgICAgICBjdXN0b21fdG90YWxfcGF5bWVudHM6IHRvdGFsUGF5bWVudHMsXHJcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnZW1wbG95ZWVfc3RhdHMnKVxyXG4gICAgICAgICAgLnVwZGF0ZShsZWdhY3lVcGRhdGVzKVxyXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxyXG4gICAgICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgICAgICosXHJcbiAgICAgICAgICAgIHVzZXI6dXNlcnMhdXNlcl9pZCAoXHJcbiAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgZnVsbF9uYW1lLFxyXG4gICAgICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgICAgIGF2YXRhcl91cmwsXHJcbiAgICAgICAgICAgICAgcm9sZVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICBgKVxyXG4gICAgICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgICAgIGlmICghZXJyb3IgJiYgZGF0YSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBaYWt0dWFsaXpvd2FubyBzdGF0eXN0eWtpIHcgZW1wbG95ZWVfc3RhdHMgKG1ldG9kYSAxKScpXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBLbGllbmNpOiAke2NsaWVudHNDb3VudH0sIFdwxYJhdHk6IOKCrCR7dG90YWxQYXltZW50c31gKVxyXG4gICAgICAgICAgcmV0dXJuIGRhdGFcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTWV0b2RhIDEgbmllIHphZHppYcWCYcWCYTonLCBlcnJvcilcclxuICAgICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBjYXRjaCAobWV0aG9kMUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTWV0b2RhIDEgKHByb3N0YSBha3R1YWxpemFjamEpIG5pZSB6YWR6aWHFgmHFgmE6JywgbWV0aG9kMUVycm9yKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1FVE9EQSAyOiBTcHLDs2J1aiBJTlNFUlQgeiBPTiBDT05GTElDVFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TnSBQcsOzYmEgSU5TRVJUIHogT04gQ09ORkxJQ1QgdyBlbXBsb3llZV9zdGF0cycpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGluc2VydERhdGEgPSB7XHJcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcclxuICAgICAgICAgICAgZGFpbHlfdGFyZ2V0OiAyMCxcclxuICAgICAgICAgICAgY29tbWlzc2lvbl9yYXRlOiAzLjAsXHJcbiAgICAgICAgICAgIG1vbnRobHlfY2FudmFzOiAwLFxyXG4gICAgICAgICAgICBtb250aGx5X2FudHlzYWxlOiAwLFxyXG4gICAgICAgICAgICBtb250aGx5X3NhbGU6IDAsXHJcbiAgICAgICAgICAgIHRvdGFsX2NvbW1pc3Npb25zOiAwLFxyXG4gICAgICAgICAgICB0b3RhbF9wZW5hbHRpZXM6IDAsXHJcbiAgICAgICAgICAgIGN1c3RvbV9jbGllbnRzX2NvdW50OiBjbGllbnRzQ291bnQsXHJcbiAgICAgICAgICAgIGN1c3RvbV90b3RhbF9wYXltZW50czogdG90YWxQYXltZW50cyxcclxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgnZW1wbG95ZWVfc3RhdHMnKVxyXG4gICAgICAgICAgICAudXBzZXJ0KGluc2VydERhdGEsIHsgXHJcbiAgICAgICAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQnLFxyXG4gICAgICAgICAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlIFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgICAgICAqLFxyXG4gICAgICAgICAgICAgIHVzZXI6dXNlcnMhdXNlcl9pZCAoXHJcbiAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgIGZ1bGxfbmFtZSxcclxuICAgICAgICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgICAgICAgYXZhdGFyX3VybCxcclxuICAgICAgICAgICAgICAgIHJvbGVcclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIGApXHJcbiAgICAgICAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgICAgICAgIGlmICghZXJyb3IgJiYgZGF0YSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFpha3R1YWxpem93YW5vIHN0YXR5c3R5a2kgdyBlbXBsb3llZV9zdGF0cyAobWV0b2RhIDIpJylcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogS2xpZW5jaTogJHtjbGllbnRzQ291bnR9LCBXcMWCYXR5OiDigqwke3RvdGFsUGF5bWVudHN9YClcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE1ldG9kYSAyIG5pZSB6YWR6aWHFgmHFgmE6JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKG1ldGhvZDJFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTWV0b2RhIDIgKHVwc2VydCkgbmllIHphZHppYcWCYcWCYTonLCBtZXRob2QyRXJyb3IpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIE1FVE9EQSAzOiBaYWt0dWFsaXp1aiB0eWxrbyB3IHBhbWnEmWNpIChmYWxsYmFjaylcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEZhbGxiYWNrIC0gendyYWNhbSBzeW11bG93YW5lIGRhbmUnKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogJ3RlbXBfJyArIHVzZXJJZCxcclxuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxyXG4gICAgICAgICAgICBkYWlseV90YXJnZXQ6IDIwLFxyXG4gICAgICAgICAgICBjb21taXNzaW9uX3JhdGU6IDMuMCxcclxuICAgICAgICAgICAgbW9udGhseV9jYW52YXM6IDAsXHJcbiAgICAgICAgICAgIG1vbnRobHlfYW50eXNhbGU6IDAsXHJcbiAgICAgICAgICAgIG1vbnRobHlfc2FsZTogMCxcclxuICAgICAgICAgICAgdG90YWxfY29tbWlzc2lvbnM6IDAsXHJcbiAgICAgICAgICAgIHRvdGFsX3BlbmFsdGllczogMCxcclxuICAgICAgICAgICAgY3VzdG9tX2NsaWVudHNfY291bnQ6IGNsaWVudHNDb3VudCxcclxuICAgICAgICAgICAgY3VzdG9tX3RvdGFsX3BheW1lbnRzOiB0b3RhbFBheW1lbnRzLFxyXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgdXNlcjoge1xyXG4gICAgICAgICAgICAgIGlkOiB1c2VySWQsXHJcbiAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnUHJhY293bmlrJyxcclxuICAgICAgICAgICAgICBlbWFpbDogJ2JyYWtAZW1haWwuY29tJyxcclxuICAgICAgICAgICAgICBhdmF0YXJfdXJsOiBudWxsLFxyXG4gICAgICAgICAgICAgIHJvbGU6ICdwcmFjb3duaWsnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyB1cGRhdGVFbXBsb3llZUNsaWVudFN0YXRzOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFN0d8Ozcnogc3RhdHlzdHlraSBkbGEgbm93ZWdvIHByYWNvd25pa2FcclxuICBhc3luYyBjcmVhdGVFbXBsb3llZVN0YXRzKHVzZXJJZDogc3RyaW5nLCBjdXJyZW50VXNlcjogVXNlcikge1xyXG4gICAgLy8gU3ByYXdkxbogdXByYXduaWVuaWFcclxuICAgIGlmICghWydtYW5hZ2VyJywgJ3Byb2plY3RfbWFuYWdlcicsICdqdW5pb3JfbWFuYWdlcicsICdzemVmJywgJ2FkbWluJ10uaW5jbHVkZXMoY3VycmVudFVzZXIucm9sZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcmFrIHVwcmF3bmllxYQgZG8gdHdvcnplbmlhIHN0YXR5c3R5aycpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2VtcGxveWVlX3N0YXRzJylcclxuICAgICAgLmluc2VydChbe1xyXG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcclxuICAgICAgICBkYWlseV90YXJnZXQ6IDIwLFxyXG4gICAgICAgIGNvbW1pc3Npb25fcmF0ZTogMy4wXHJcbiAgICAgIH1dKVxyXG4gICAgICAuc2VsZWN0KClcclxuICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcmV0dXJuIGRhdGFcclxuICB9LFxyXG5cclxuICAvLyDwn5OKIE5vd2EgZnVua2NqYTogUG9iaWVyeiBzdGF0eXN0eWtpIHd5a29yenlzdGFuaWEgYmF6eSAoa2xpZW5jaSB6L2JleiB3xYJhxZtjaWNpZWxhKVxyXG4gIGFzeW5jIGdldERhdGFiYXNlVXRpbGl6YXRpb24oKTogUHJvbWlzZTx7IHdpdGhPd25lcjogbnVtYmVyLCB3aXRob3V0T3duZXI6IG51bWJlciwgdG90YWw6IG51bWJlciwgdXRpbGl6YXRpb25QZXJjZW50YWdlOiBudW1iZXIgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUG9iaWVyYW5pZSBzdGF0eXN0eWsgd3lrb3J6eXN0YW5pYSBiYXp5Li4uJylcclxuICAgICAgXHJcbiAgICAgIC8vIFpsaWN6IHdzenlzdGtpY2gga2xpZW50w7N3XHJcbiAgICAgIGNvbnN0IHsgY291bnQ6IHRvdGFsQ291bnQsIGVycm9yOiB0b3RhbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG5cclxuICAgICAgaWYgKHRvdGFsRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgxYLEhWN6bmVqIGxpY3pieSBrbGllbnTDs3c6JywgdG90YWxFcnJvcilcclxuICAgICAgICB0aHJvdyB0b3RhbEVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFpsaWN6IGtsaWVudMOzdyB6IHfFgmHFm2NpY2llbGVtIChvd25lcl9pZCAhPSBudWxsKVxyXG4gICAgICBjb25zdCB7IGNvdW50OiB3aXRoT3duZXJDb3VudCwgZXJyb3I6IHdpdGhPd25lckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAgIC5ub3QoJ293bmVyX2lkJywgJ2lzJywgbnVsbClcclxuXHJcbiAgICAgIGlmICh3aXRoT3duZXJFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBrbGllbnTDs3cgeiB3xYJhxZtjaWNpZWxlbTonLCB3aXRoT3duZXJFcnJvcilcclxuICAgICAgICB0aHJvdyB3aXRoT3duZXJFcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPYmxpY3oga2xpZW50w7N3IGJleiB3xYJhxZtjaWNpZWxhXHJcbiAgICAgIGNvbnN0IHdpdGhvdXRPd25lckNvdW50ID0gKHRvdGFsQ291bnQgfHwgMCkgLSAod2l0aE93bmVyQ291bnQgfHwgMClcclxuICAgICAgXHJcbiAgICAgIC8vIE9ibGljeiBwcm9jZW50IHd5a29yenlzdGFuaWFcclxuICAgICAgY29uc3QgdXRpbGl6YXRpb25QZXJjZW50YWdlID0gdG90YWxDb3VudCA/IE1hdGgucm91bmQoKHdpdGhPd25lckNvdW50IHx8IDApIC8gdG90YWxDb3VudCAqIDEwMCkgOiAwXHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgd2l0aE93bmVyOiB3aXRoT3duZXJDb3VudCB8fCAwLFxyXG4gICAgICAgIHdpdGhvdXRPd25lcjogd2l0aG91dE93bmVyQ291bnQsXHJcbiAgICAgICAgdG90YWw6IHRvdGFsQ291bnQgfHwgMCxcclxuICAgICAgICB1dGlsaXphdGlvblBlcmNlbnRhZ2VcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU3RhdHlzdHlraSB3eWtvcnp5c3RhbmlhIGJhenk6JywgcmVzdWx0KVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHN0YXR5c3R5ayB3eWtvcnp5c3RhbmlhIGJhenk6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8g8J+UhCBBRE1JTjogUmVzZXR1aiB3xYJhxZtjaWNpZWxpIHdzenlzdGtpY2gga2xpZW50w7N3XHJcbiAgYXN5bmMgcmVzZXRBbGxDbGllbnRPd25lcnMoY3VycmVudFVzZXI6IFVzZXIpOiBQcm9taXNlPHsgc3VjY2VzczogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcgfT4ge1xyXG4gICAgLy8gU3ByYXdkxbogdXByYXduaWVuaWEgLSB0eWxrbyBhZG1pblxyXG4gICAgaWYgKGN1cnJlbnRVc2VyLnJvbGUgIT09ICdhZG1pbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcmFrIHVwcmF3bmllxYQhIFR5bGtvIGFkbWluaXN0cmF0b3IgbW/FvGUgcmVzZXRvd2HEhyB3xYJhxZtjaWNpZWxpIGtsaWVudMOzdy4nKVxyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJvenBvY3p5bmFtIHJlc2V0b3dhbmllIHfFgmHFm2NpY2llbGkga2xpZW50w7N3Li4uJylcclxuICAgICAgXHJcbiAgICAgIC8vIFBvYmllcnogbGljemLEmSBrbGllbnTDs3cgeiB3xYJhxZtjaWNpZWxlbSBwcnplZCByZXNldG93YW5pZW1cclxuICAgICAgY29uc3QgeyBjb3VudDogYmVmb3JlQ291bnQsIGVycm9yOiBiZWZvcmVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcclxuICAgICAgICAubm90KCdvd25lcl9pZCcsICdpcycsIG51bGwpXHJcblxyXG4gICAgICBpZiAoYmVmb3JlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHNwcmF3ZHphbmlhIHN0YW51IHByemVkIHJlc2V0b3dhbmllbTonLCBiZWZvcmVFcnJvcilcclxuICAgICAgICB0aHJvdyBiZWZvcmVFcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXNldHVqIG93bmVyX2lkIGRsYSB3c3p5c3RraWNoIGtsaWVudMOzd1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAudXBkYXRlKHsgb3duZXJfaWQ6IG51bGwgfSlcclxuICAgICAgICAubm90KCdvd25lcl9pZCcsICdpcycsIG51bGwpIC8vIFR5bGtvIHRlIGt0w7NyZSBtYWrEhSB3xYJhxZtjaWNpZWxhXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIGZpcnN0X25hbWUsIGxhc3RfbmFtZScpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHJlc2V0b3dhbmlhIHfFgmHFm2NpY2llbGk6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVzZXRDb3VudCA9IGRhdGE/Lmxlbmd0aCB8fCAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBMb2d1aiBha2NqxJkgZG8gYWN0aXZpdHlfbG9nc1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGFjdGl2aXR5TG9nc0FwaS5jcmVhdGVMb2coe1xyXG4gICAgICAgICAgY2xpZW50X2lkOiAnYnVsa19hY3Rpb24nLFxyXG4gICAgICAgICAgY2hhbmdlZF9ieTogY3VycmVudFVzZXIuaWQsXHJcbiAgICAgICAgICBjaGFuZ2VfdHlwZTogJ3VwZGF0ZScsXHJcbiAgICAgICAgICBmaWVsZF9jaGFuZ2VkOiAnb3duZXJfaWQnLFxyXG4gICAgICAgICAgb2xkX3ZhbHVlOiAndmFyaW91cycsXHJcbiAgICAgICAgICBuZXdfdmFsdWU6ICdudWxsIChyZXNldCBieSBhZG1pbiknLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0gY2F0Y2ggKGxvZ0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSB6YWxvZ293YcSHIGFrY2ppOicsIGxvZ0Vycm9yKVxyXG4gICAgICAgIC8vIE5pZSBwcnplcnl3YW15IHByb2Nlc3UgeiBwb3dvZHUgYsWCxJlkdSBsb2dvd2FuaWFcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBacmVzZXRvd2FubyB3xYJhxZtjaWNpZWxpIGRsYSAke3Jlc2V0Q291bnR9IGtsaWVudMOzd2ApXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHJlc2V0Q291bnQsXHJcbiAgICAgICAgbWVzc2FnZTogYFBvbXnFm2xuaWUgenJlc2V0b3dhbm8gd8WCYcWbY2ljaWVsaSBkbGEgJHtyZXNldENvdW50fSBrbGllbnTDs3cuIFdzenlzY3kga2xpZW5jaSBzxIUgdGVyYXogYmV6IHByenlwaXNhbmVnbyB3xYJhxZtjaWNpZWxhLmBcclxuICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCByZXNldG93YW5pYSB3xYJhxZtjaWNpZWxpIGtsaWVudMOzdzonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IHN0YXR5c3R5a2kgYWt0eXdub8WbY2kgcHJhY293bmlrw7N3IHogdGFiZWxpIGVtcGxveWVlX3N0YXRpc3RpY3NcclxuICBhc3luYyBnZXRFbXBsb3llZUFjdGl2aXR5U3RhdHModXNlcjogVXNlcik6IFByb21pc2U8RW1wbG95ZWVBY3Rpdml0eVN0YXRzW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFBvYmllcmFuaWUgc3RhdHlzdHlrIGFrdHl3bm/Fm2NpIHByYWNvd25pa8Ozdy4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBTcHJhd2TFuiB1cHJhd25pZW5pYVxyXG4gICAgICBpZiAoIXVzZXIgfHwgIVsnbWFuYWdlcicsICdwcm9qZWN0X21hbmFnZXInLCAnanVuaW9yX21hbmFnZXInLCAnc3plZicsICdhZG1pbiddLmluY2x1ZGVzKHVzZXIucm9sZSkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBCcmFrIHVwcmF3bmllxYQgZG8gcG9kZ2zEhWR1IHN0YXR5c3R5ayBha3R5d25vxZtjaScpXHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEtST0sgMTogUG9iaWVyeiB3c3p5c3RraWNoIHXFvHl0a293bmlrw7N3IHogcm9sxIUgJ3ByYWNvd25paydcclxuICAgICAgbGV0IGFsbEVtcGxveWVlcyA9IFtdXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhOiBlbXBsb3llZXMsIGVycm9yOiB1c2Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgZnVsbF9uYW1lLFxyXG4gICAgICAgICAgICBlbWFpbCxcclxuICAgICAgICAgICAgYXZhdGFyX3VybCxcclxuICAgICAgICAgICAgcm9sZVxyXG4gICAgICAgICAgYClcclxuICAgICAgICAgIC5lcSgncm9sZScsICdwcmFjb3duaWsnKVxyXG4gICAgICAgICAgLm9yZGVyKCdmdWxsX25hbWUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG5cclxuICAgICAgICBpZiAodXNlcnNFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHXFvHl0a293bmlrw7N3LXByYWNvd25pa8OzdzonLCB1c2Vyc0Vycm9yKVxyXG4gICAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbGxFbXBsb3llZXMgPSBlbXBsb3llZXMgfHwgW11cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+RpSBabmFsZXppb25vIHByYWNvd25pa8OzdzogJHthbGxFbXBsb3llZXMubGVuZ3RofWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGFsbEVtcGxveWVlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQnJhayB1xbx5dGtvd25pa8OzdyB6IHJvbMSFIHByYWNvd25paycpXHJcbiAgICAgICAgICByZXR1cm4gW11cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHByYWNvd25pa8OzdzonLCBlcnJvcilcclxuICAgICAgICByZXR1cm4gW11cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gS1JPSyAyOiBQb2JpZXJ6IHN0YXR5c3R5a2kgYWt0eXdub8WbY2kgLSB6IG9ic8WCdWfEhSBixYLEmWTDs3cgUkxTXHJcbiAgICAgIGxldCBhY3Rpdml0eVN0YXRzID0gW11cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlbXBsb3llZUlkcyA9IGFsbEVtcGxveWVlcy5tYXAoZW1wID0+IGVtcC5pZClcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQb2JpZXJhbmllIHN0YXR5c3R5ayBkbGEgSUQ6ICR7ZW1wbG95ZWVJZHMuc2xpY2UoMCwgMykuam9pbignLCAnKX0uLi4gKCR7ZW1wbG95ZWVJZHMubGVuZ3RofSB0b3RhbClgKVxyXG5cclxuICAgICAgICBjb25zdCB7IGRhdGE6IHN0YXRzLCBlcnJvcjogc3RhdHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdlbXBsb3llZV9zdGF0aXN0aWNzJylcclxuICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgLmVxKCdwZXJpb2RfdHlwZScsICdtb250aGx5JylcclxuICAgICAgICAgIC5pbigndXNlcl9pZCcsIGVtcGxveWVlSWRzKVxyXG4gICAgICAgICAgLm9yZGVyKCdwZXJpb2RfZW5kJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgICAgIGlmIChzdGF0c0Vycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgc3RhdHlzdHlrIGFrdHl3bm/Fm2NpOicsIHN0YXRzRXJyb3IpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEplxZtsaSB0byBixYLEhWQgUkxTICg0MDMpLCBuaWUgcHJ6ZXJ5d2FqIC0gdcW8eWogZG9tecWbbG55Y2ggZGFueWNoXHJcbiAgICAgICAgICBpZiAoc3RhdHNFcnJvci5jb2RlID09PSAnUEdSU1QxMTYnIHx8IHN0YXRzRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ1JMUycpIHx8IHN0YXRzRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ/CflJIgUHJvYmxlbSB6IFJMUyAtIHXFvHl3YW0gZG9tecWbbG55Y2ggZGFueWNoIGFrdHl3bm/Fm2NpJylcclxuICAgICAgICAgICAgYWN0aXZpdHlTdGF0cyA9IFtdXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5KlIEtyeXR5Y3pueSBixYLEhWQgcG9iaWVyYW5pYSBzdGF0eXN0eWsgLSBwcnplcnl3YW0nKVxyXG4gICAgICAgICAgICByZXR1cm4gW11cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWN0aXZpdHlTdGF0cyA9IHN0YXRzIHx8IFtdXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBabmFsZXppb25vIHJla29yZMOzdyBha3R5d25vxZtjaTogJHthY3Rpdml0eVN0YXRzLmxlbmd0aH1gKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHphcHl0YW5pYSBvIHN0YXR5c3R5a2kgYWt0eXdub8WbY2k6JywgZXJyb3IpXHJcbiAgICAgICAgYWN0aXZpdHlTdGF0cyA9IFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEtST0sgMzogU3R3w7NyeiBtYXDEmSBuYWpub3dzenljaCBzdGF0eXN0eWsgZGxhIGthxbxkZWdvIHByYWNvd25pa2FcclxuICAgICAgY29uc3QgbGF0ZXN0U3RhdHNNYXAgPSBuZXcgTWFwKClcclxuICAgICAgaWYgKGFjdGl2aXR5U3RhdHMgJiYgYWN0aXZpdHlTdGF0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgYWN0aXZpdHlTdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdXNlcklkID0gc3RhdC51c2VyX2lkXHJcbiAgICAgICAgICBpZiAoIWxhdGVzdFN0YXRzTWFwLmhhcyh1c2VySWQpKSB7XHJcbiAgICAgICAgICAgIGxhdGVzdFN0YXRzTWFwLnNldCh1c2VySWQsIHN0YXQpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+Xuu+4jyBabWFwb3dhbm8gc3RhdHlzdHlraSBkbGEgJHtsYXRlc3RTdGF0c01hcC5zaXplfSBwcmFjb3duaWvDs3dgKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQnJhayBkYW55Y2ggYWt0eXdub8WbY2kgLSB1xbx5asSZIGRvbXnFm2xueWNoIHdhcnRvxZtjaScpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEtST0sgNDogS29tYmludWogZGFuZSBwcmFjb3duaWvDs3cgemUgc3RhdHlzdHlrYW1pIGFrdHl3bm/Fm2NpXHJcbiAgICAgIGNvbnN0IHJlc3VsdDogRW1wbG95ZWVBY3Rpdml0eVN0YXRzW10gPSBhbGxFbXBsb3llZXMubWFwKGVtcGxveWVlID0+IHtcclxuICAgICAgICBjb25zdCB1c2VySWQgPSBlbXBsb3llZS5pZFxyXG4gICAgICAgIGNvbnN0IGFjdGl2aXR5U3RhdCA9IGxhdGVzdFN0YXRzTWFwLmdldCh1c2VySWQpXHJcblxyXG4gICAgICAgIGlmIChhY3Rpdml0eVN0YXQpIHtcclxuICAgICAgICAgIC8vIE1hbXkgc3RhdHlzdHlraSAtIHXFvHlqIHByYXdkeml3eWNoIGRhbnljaFxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uYWN0aXZpdHlTdGF0LFxyXG4gICAgICAgICAgICB1c2VyOiB7XHJcbiAgICAgICAgICAgICAgaWQ6IGVtcGxveWVlLmlkLFxyXG4gICAgICAgICAgICAgIGZ1bGxfbmFtZTogZW1wbG95ZWUuZnVsbF9uYW1lLFxyXG4gICAgICAgICAgICAgIGVtYWlsOiBlbXBsb3llZS5lbWFpbCxcclxuICAgICAgICAgICAgICBhdmF0YXJfdXJsOiBlbXBsb3llZS5hdmF0YXJfdXJsLFxyXG4gICAgICAgICAgICAgIHJvbGU6IGVtcGxveWVlLnJvbGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBCcmFrIHN0YXR5c3R5ayAtIHN0d8OzcnogZG9tecWbbG5lIGRhbmVcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDFcclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKVxyXG4gICAgICAgICAgY29uc3QgbW9udGhTdGFydCA9IGAke2N1cnJlbnRZZWFyfS0ke2N1cnJlbnRNb250aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LTAxYFxyXG4gICAgICAgICAgY29uc3QgbW9udGhFbmQgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCAwKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogJ3RlbXBfJyArIHVzZXJJZCxcclxuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxyXG4gICAgICAgICAgICBwZXJpb2RfdHlwZTogJ21vbnRobHknLFxyXG4gICAgICAgICAgICBwZXJpb2Rfc3RhcnQ6IG1vbnRoU3RhcnQsXHJcbiAgICAgICAgICAgIHBlcmlvZF9lbmQ6IG1vbnRoRW5kLFxyXG4gICAgICAgICAgICB0b3RhbF93b3JrX21pbnV0ZXM6IDAsXHJcbiAgICAgICAgICAgIGF2ZXJhZ2VfZGFpbHlfbWludXRlczogMCxcclxuICAgICAgICAgICAgZXhwZWN0ZWRfd29ya19taW51dGVzOiAxNzYgKiA2MCwgLy8gMTc2aCAqIDYwbWluID0gMTA1NjAgbWluXHJcbiAgICAgICAgICAgIGVmZmljaWVuY3lfcGVyY2VudGFnZTogMCxcclxuICAgICAgICAgICAgdG90YWxfYWN0aXZpdGllczogMCxcclxuICAgICAgICAgICAgYXZlcmFnZV9kYWlseV9hY3Rpdml0aWVzOiAwLFxyXG4gICAgICAgICAgICBkYXlzX3dvcmtlZDogMCxcclxuICAgICAgICAgICAgZGF5c19hYnNlbnQ6IDAsXHJcbiAgICAgICAgICAgIHVzZXI6IHtcclxuICAgICAgICAgICAgICBpZDogZW1wbG95ZWUuaWQsXHJcbiAgICAgICAgICAgICAgZnVsbF9uYW1lOiBlbXBsb3llZS5mdWxsX25hbWUsXHJcbiAgICAgICAgICAgICAgZW1haWw6IGVtcGxveWVlLmVtYWlsLFxyXG4gICAgICAgICAgICAgIGF2YXRhcl91cmw6IGVtcGxveWVlLmF2YXRhcl91cmwsXHJcbiAgICAgICAgICAgICAgcm9sZTogZW1wbG95ZWUucm9sZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBQcnp5Z290b3dhbm8gc3RhdHlzdHlraSBha3R5d25vxZtjaSBkbGEgd3N6eXN0a2ljaCBwcmFjb3duaWvDs3c6ICR7cmVzdWx0Lmxlbmd0aH1gKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+RpSBMaXN0YSBwcmFjb3duaWvDs3c6ICR7cmVzdWx0Lm1hcChzID0+IHMudXNlcj8uZnVsbF9uYW1lKS5qb2luKCcsICcpfWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBQb2thxbwgc3RhdHlzdHlraSBwb2RzdW1vd3VqxIVjZVxyXG4gICAgICBjb25zdCB3aXRoRGF0YSA9IHJlc3VsdC5maWx0ZXIociA9PiByLnRvdGFsX3dvcmtfbWludXRlcyA+IDApLmxlbmd0aFxyXG4gICAgICBjb25zdCB3aXRob3V0RGF0YSA9IHJlc3VsdC5sZW5ndGggLSB3aXRoRGF0YVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBQcmFjb3duaWN5IHogZGFueW1pOiAke3dpdGhEYXRhfSwgYmV6IGRhbnljaDogJHt3aXRob3V0RGF0YX1gKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBzdGF0eXN0eWsgYWt0eXdub8WbY2k6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBHcmFjZWZ1bCBmYWxsYmFjayAtIHp3csOzxIcgcHVzdMSFIHRhYmxpY8SZIHphbWlhc3QgY3Jhc2hvd2HEh1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBHcmFjZWZ1bCBmYWxsYmFjayAtIHp3cmFjYW0gcHVzdMSFIHRhYmxpY8SZJylcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiB0cmVuZHkgc3ByemVkYcW8b3dlIHogb3N0YXRuaWNoIDcgZG5pXHJcbiAgYXN5bmMgZ2V0U2FsZXNUcmVuZHModXNlcjogVXNlcik6IFByb21pc2U8QXJyYXk8eyBkYXk6IHN0cmluZywgY2FudmFzOiBudW1iZXIsIHNhbGU6IG51bWJlciwgYW50eXNhbGU6IG51bWJlciB9Pj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ggUG9iaWVyYW5pZSB0cmVuZMOzdyBzcHJ6ZWRhxbxvd3ljaCB6IG9zdGF0bmljaCA3IGRuaS4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQb2JpZXJ6IGRhbmUgeiBvc3RhdG5pY2ggNyBkbmlcclxuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKClcclxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICBzdGFydERhdGUuc2V0RGF0ZShlbmREYXRlLmdldERhdGUoKSAtIDYpIC8vIDcgZG5pIHdzdGVjeiAod8WCxIVjem5pZSB6IGR6aXNpYWopXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjbGllbnRzJylcclxuICAgICAgICAuc2VsZWN0KCdzdGF0dXMsIHVwZGF0ZWRfYXQsIHN0YXR1c19jaGFuZ2VkX2F0LCBvd25lcl9pZCwgZWRpdGVkX2J5JylcclxuICAgICAgICAuZ3RlKCd1cGRhdGVkX2F0Jywgc3RhcnREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSlcclxuICAgICAgICAubHRlKCd1cGRhdGVkX2F0JywgZW5kRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gKyAnVDIzOjU5OjU5JylcclxuICAgICAgICAuaW4oJ3N0YXR1cycsIFsnY2FudmFzJywgJ3NhbGUnLCAnYW50eXNhbGUnXSlcclxuICAgICAgICAub3JkZXIoJ3VwZGF0ZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHRyZW5kw7N3IHNwcnplZGHFvG93eWNoOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9icmFubyAke2RhdGE/Lmxlbmd0aCB8fCAwfSByZWtvcmTDs3cgeiBvc3RhdG5pY2ggNyBkbmlgKVxyXG5cclxuICAgICAgLy8gRmlsdHJ1aiBrbGllbnTDs3cgd2VkxYJ1ZyB1cHJhd25pZcWEIHXFvHl0a293bmlrYVxyXG4gICAgICBsZXQgZmlsdGVyZWREYXRhID0gZGF0YSB8fCBbXVxyXG4gICAgICBpZiAodXNlci5yb2xlID09PSAncHJhY293bmlrJykge1xyXG4gICAgICAgIGZpbHRlcmVkRGF0YSA9IGZpbHRlcmVkRGF0YS5maWx0ZXIoY2xpZW50ID0+IFxyXG4gICAgICAgICAgY2xpZW50Lm93bmVyX2lkID09PSB1c2VyLmlkIHx8IFxyXG4gICAgICAgICAgY2xpZW50Lm93bmVyX2lkID09PSBudWxsIHx8IFxyXG4gICAgICAgICAgY2xpZW50LmVkaXRlZF9ieSA9PT0gdXNlci5pZFxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU3R3w7NyeiBtYXDEmSBkbGEgZG5pIHR5Z29kbmlhXHJcbiAgICAgIGNvbnN0IGRheU5hbWVzID0gWydOZHonLCAnUG9uJywgJ1d0JywgJ8WacicsICdDencnLCAnUHQnLCAnU29iJ11cclxuICAgICAgY29uc3QgdHJlbmRzOiBSZWNvcmQ8c3RyaW5nLCB7IGNhbnZhczogbnVtYmVyLCBzYWxlOiBudW1iZXIsIGFudHlzYWxlOiBudW1iZXIgfT4gPSB7fVxyXG5cclxuICAgICAgLy8gSW5pY2phbGl6dWogb3N0YXRuaWUgNyBkbmlcclxuICAgICAgZm9yIChsZXQgaSA9IDY7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKVxyXG4gICAgICAgIGNvbnN0IGRheU5hbWUgPSBkYXlOYW1lc1tkYXRlLmdldERheSgpXVxyXG4gICAgICAgIHRyZW5kc1tkYXlOYW1lXSA9IHsgY2FudmFzOiAwLCBzYWxlOiAwLCBhbnR5c2FsZTogMCB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdydXB1aiBkYW5lIHdlZMWCdWcgZG5pXHJcbiAgICAgIGZpbHRlcmVkRGF0YS5mb3JFYWNoKGNsaWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGNsaWVudC51cGRhdGVkX2F0KVxyXG4gICAgICAgIGNvbnN0IGRheU5hbWUgPSBkYXlOYW1lc1tkYXRlLmdldERheSgpXVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0cmVuZHNbZGF5TmFtZV0pIHtcclxuICAgICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAnY2FudmFzJykgdHJlbmRzW2RheU5hbWVdLmNhbnZhcysrXHJcbiAgICAgICAgICBlbHNlIGlmIChjbGllbnQuc3RhdHVzID09PSAnc2FsZScpIHRyZW5kc1tkYXlOYW1lXS5zYWxlKytcclxuICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC5zdGF0dXMgPT09ICdhbnR5c2FsZScpIHRyZW5kc1tkYXlOYW1lXS5hbnR5c2FsZSsrXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgLy8gUHJ6ZWtzenRhxYLEhyBuYSBmb3JtYXQgZGxhIHd5a3Jlc3UgKG9zdGF0bmllIDcgZG5pIHcga29sZWpub8WbY2kpXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdXHJcbiAgICAgIGZvciAobGV0IGkgPSA2OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gaSlcclxuICAgICAgICBjb25zdCBkYXlOYW1lID0gZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV1cclxuICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICBkYXk6IGRheU5hbWUsXHJcbiAgICAgICAgICBjYW52YXM6IHRyZW5kc1tkYXlOYW1lXS5jYW52YXMsXHJcbiAgICAgICAgICBzYWxlOiB0cmVuZHNbZGF5TmFtZV0uc2FsZSxcclxuICAgICAgICAgIGFudHlzYWxlOiB0cmVuZHNbZGF5TmFtZV0uYW50eXNhbGVcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyZW5keSBzcHJ6ZWRhxbxvd2UgcHJ6eWdvdG93YW5lOicsIHJlc3VsdClcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSB0cmVuZMOzdyBzcHJ6ZWRhxbxvd3ljaDonLCBlcnJvcilcclxuICAgICAgLy8gVyBwcnp5cGFka3UgYsWCxJlkdSB6d3LDs8SHIHB1c3RlIGRhbmUgZGxhIG9zdGF0bmljaCA3IGRuaVxyXG4gICAgICBjb25zdCBkYXlOYW1lcyA9IFsnTmR6JywgJ1BvbicsICdXdCcsICfFmnInLCAnQ3p3JywgJ1B0JywgJ1NvYiddXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdXHJcbiAgICAgIGZvciAobGV0IGkgPSA2OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gaSlcclxuICAgICAgICBjb25zdCBkYXlOYW1lID0gZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV1cclxuICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICBkYXk6IGRheU5hbWUsXHJcbiAgICAgICAgICBjYW52YXM6IDAsXHJcbiAgICAgICAgICBzYWxlOiAwLFxyXG4gICAgICAgICAgYW50eXNhbGU6IDBcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHRcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IHN0YXR5c3R5a2kga2xpa25pxJnEhyB0ZWxlZm9udSB0eWxrbyBkbGEgcHJhY293bmlrw7N3XHJcbiAgYXN5bmMgZ2V0UGhvbmVDbGlja3NTdGF0cyh1c2VyOiBVc2VyKTogUHJvbWlzZTx7IHRvdGFsUGhvbmVDYWxsczogbnVtYmVyLCB0b3RhbFBob25lQ2FsbHNUb2RheTogbnVtYmVyIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OeIFBvYmllcmFuaWUgc3RhdHlzdHlrIGtsaWtuacSZxIcgdGVsZWZvbnUuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gUG9iaWVyeiB3c3p5c3RraWNoIHByYWNvd25pa8Ozd1xyXG4gICAgICBjb25zdCB7IGRhdGE6IGVtcGxveWVlcywgZXJyb3I6IGVtcGxveWVlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxyXG4gICAgICAgIC5lcSgncm9sZScsICdwcmFjb3duaWsnKVxyXG5cclxuICAgICAgaWYgKGVtcGxveWVlc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHByYWNvd25pa8OzdzonLCBlbXBsb3llZXNFcnJvcilcclxuICAgICAgICB0aHJvdyBlbXBsb3llZXNFcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBlbXBsb3llZUlkcyA9IChlbXBsb3llZXMgfHwgW10pLm1hcChlbXAgPT4gZW1wLmlkKVxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+RpSBabmFsZXppb25vICR7ZW1wbG95ZWVJZHMubGVuZ3RofSBwcmFjb3duaWvDs3dgKVxyXG5cclxuICAgICAgaWYgKGVtcGxveWVlSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvdGFsUGhvbmVDYWxsczogMCwgdG90YWxQaG9uZUNhbGxzVG9kYXk6IDAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQb2JpZXJ6IHdzenlzdGtpZSBrbGlrbmnEmWNpYSB0ZWxlZm9udSB6IGFjdGl2aXR5X2xvZ3MgdHlsa28gZGxhIHByYWNvd25pa8Ozd1xyXG4gICAgICBjb25zdCB7IGRhdGE6IGFsbFBob25lQ2xpY2tzLCBlcnJvcjogYWxsQ2xpY2tzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBjaGFuZ2VkX2J5LCB0aW1lc3RhbXAnKVxyXG4gICAgICAgIC5lcSgnZmllbGRfY2hhbmdlZCcsICdsYXN0X3Bob25lX2NsaWNrJylcclxuICAgICAgICAuaW4oJ2NoYW5nZWRfYnknLCBlbXBsb3llZUlkcylcclxuXHJcbiAgICAgIGlmIChhbGxDbGlja3NFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBrbGlrbmnEmcSHIHRlbGVmb251OicsIGFsbENsaWNrc0Vycm9yKVxyXG4gICAgICAgIHRocm93IGFsbENsaWNrc0Vycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsUGhvbmVDYWxscyA9IGFsbFBob25lQ2xpY2tzPy5sZW5ndGggfHwgMFxyXG5cclxuICAgICAgLy8gUG9iaWVyeiBkemlzaWVqc3plIGtsaWtuacSZY2lhIHRlbGVmb251XHJcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gLy8gWVlZWS1NTS1ERFxyXG4gICAgICBjb25zdCB7IGRhdGE6IHRvZGF5UGhvbmVDbGlja3MsIGVycm9yOiB0b2RheUNsaWNrc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhY3Rpdml0eV9sb2dzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCwgY2hhbmdlZF9ieSwgdGltZXN0YW1wJylcclxuICAgICAgICAuZXEoJ2ZpZWxkX2NoYW5nZWQnLCAnbGFzdF9waG9uZV9jbGljaycpXHJcbiAgICAgICAgLmluKCdjaGFuZ2VkX2J5JywgZW1wbG95ZWVJZHMpXHJcbiAgICAgICAgLmd0ZSgndGltZXN0YW1wJywgYCR7dG9kYXl9VDAwOjAwOjAwYClcclxuICAgICAgICAubHQoJ3RpbWVzdGFtcCcsIGAke3RvZGF5fVQyMzo1OTo1OWApXHJcblxyXG4gICAgICBpZiAodG9kYXlDbGlja3NFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBkemlzaWVqc3p5Y2gga2xpa25pxJnEhyB0ZWxlZm9udTonLCB0b2RheUNsaWNrc0Vycm9yKVxyXG4gICAgICAgIHRocm93IHRvZGF5Q2xpY2tzRXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdG90YWxQaG9uZUNhbGxzVG9kYXkgPSB0b2RheVBob25lQ2xpY2tzPy5sZW5ndGggfHwgMFxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBTdGF0eXN0eWtpIGtsaWtuacSZxIcgdGVsZWZvbnU6IMWCxIVjem5pZSAke3RvdGFsUGhvbmVDYWxsc30sIGR6acWbICR7dG90YWxQaG9uZUNhbGxzVG9kYXl9YClcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxQaG9uZUNhbGxzLFxyXG4gICAgICAgIHRvdGFsUGhvbmVDYWxsc1RvZGF5XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgc3RhdHlzdHlrIGtsaWtuacSZxIcgdGVsZWZvbnU6JywgZXJyb3IpXHJcbiAgICAgIC8vIFcgcHJ6eXBhZGt1IGLFgsSZZHUgendyw7PEhyB6ZXJvd2Ugc3RhdHlzdHlraVxyXG4gICAgICByZXR1cm4geyB0b3RhbFBob25lQ2FsbHM6IDAsIHRvdGFsUGhvbmVDYWxsc1RvZGF5OiAwIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBQb2JpZXJ6IGRhbmUgdHJlbmTDs3cgd3lkYWpub8WbY2kgemVzcG/FgnUgeiBvc3RhdG5pY2ggNyBkbmlcclxuICBhc3luYyBnZXRUZWFtUGVyZm9ybWFuY2VUcmVuZHModXNlcjogVXNlcik6IFByb21pc2U8QXJyYXk8eyBkYXk6IHN0cmluZywgdGVsZWZvbnk6IG51bWJlciwga29ud2Vyc2phOiBudW1iZXIsIGtsaWVuY2k6IG51bWJlciB9Pj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUG9iaWVyYW5pZSB0cmVuZMOzdyB3eWRham5vxZtjaSB6ZXNwb8WCdSB6IG9zdGF0bmljaCA3IGRuaS4uLicpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQb2JpZXJ6IHdzenlzdGtpY2ggcHJhY293bmlrw7N3XHJcbiAgICAgIGNvbnN0IHsgZGF0YTogZW1wbG95ZWVzLCBlcnJvcjogZW1wbG95ZWVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAuc2VsZWN0KCdpZCcpXHJcbiAgICAgICAgLmVxKCdyb2xlJywgJ3ByYWNvd25paycpXHJcblxyXG4gICAgICBpZiAoZW1wbG95ZWVzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgcHJhY293bmlrw7N3OicsIGVtcGxveWVlc0Vycm9yKVxyXG4gICAgICAgIHRocm93IGVtcGxveWVlc0Vycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGVtcGxveWVlSWRzID0gKGVtcGxveWVlcyB8fCBbXSkubWFwKGVtcCA9PiBlbXAuaWQpXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5GlIFpuYWxlemlvbm8gJHtlbXBsb3llZUlkcy5sZW5ndGh9IHByYWNvd25pa8Ozd2ApXHJcblxyXG4gICAgICBpZiAoZW1wbG95ZWVJZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gWndyw7PEhyBwdXN0ZSBkYW5lIGRsYSBvc3RhdG5pY2ggNyBkbmlcclxuICAgICAgICBjb25zdCBkYXlOYW1lcyA9IFsnTmR6JywgJ1BvbicsICdXdCcsICfFmnInLCAnQ3p3JywgJ1B0JywgJ1NvYiddXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW11cclxuICAgICAgICBmb3IgKGxldCBpID0gNjsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKVxyXG4gICAgICAgICAgY29uc3QgZGF5TmFtZSA9IGRheU5hbWVzW2RhdGUuZ2V0RGF5KCldXHJcbiAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgIGRheTogZGF5TmFtZSxcclxuICAgICAgICAgICAgdGVsZWZvbnk6IDAsXHJcbiAgICAgICAgICAgIGtvbndlcnNqYTogMCxcclxuICAgICAgICAgICAga2xpZW5jaTogMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQb2JpZXJ6IGRhbmUgeiBvc3RhdG5pY2ggNyBkbmlcclxuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKClcclxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICBzdGFydERhdGUuc2V0RGF0ZShlbmREYXRlLmdldERhdGUoKSAtIDYpIC8vIDcgZG5pIHdzdGVjeiAod8WCxIVjem5pZSB6IGR6aXNpYWopXHJcbiAgICAgIFxyXG4gICAgICAvLyAxLiBQb2JpZXJ6IGtsaWtuacSZY2lhIHRlbGVmb251IHogYWN0aXZpdHlfbG9ncyAodHlsa28gcHJhY293bmljeSlcclxuICAgICAgY29uc3QgeyBkYXRhOiBwaG9uZUNsaWNrcywgZXJyb3I6IHBob25lRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2NoYW5nZWRfYnksIHRpbWVzdGFtcCcpXHJcbiAgICAgICAgLmVxKCdmaWVsZF9jaGFuZ2VkJywgJ2xhc3RfcGhvbmVfY2xpY2snKVxyXG4gICAgICAgIC5pbignY2hhbmdlZF9ieScsIGVtcGxveWVlSWRzKVxyXG4gICAgICAgIC5ndGUoJ3RpbWVzdGFtcCcsIHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pXHJcbiAgICAgICAgLmx0ZSgndGltZXN0YW1wJywgZW5kRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gKyAnVDIzOjU5OjU5JylcclxuXHJcbiAgICAgIGlmIChwaG9uZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIGtsaWtuacSZxIcgdGVsZWZvbnU6JywgcGhvbmVFcnJvcilcclxuICAgICAgICB0aHJvdyBwaG9uZUVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDIuIFBvYmllcnogem1pYW55IGtsaWVudMOzdyB6IG9zdGF0bmljaCA3IGRuaSAodHlsa28gcHJ6ZXogcHJhY293bmlrw7N3KVxyXG4gICAgICBjb25zdCB7IGRhdGE6IGNsaWVudENoYW5nZXMsIGVycm9yOiBjaGFuZ2VzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2NsaWVudHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ3VwZGF0ZWRfYXQsIHN0YXR1cywgZWRpdGVkX2J5JylcclxuICAgICAgICAuaW4oJ2VkaXRlZF9ieScsIGVtcGxveWVlSWRzKVxyXG4gICAgICAgIC5ndGUoJ3VwZGF0ZWRfYXQnLCBzdGFydERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKVxyXG4gICAgICAgIC5sdGUoJ3VwZGF0ZWRfYXQnLCBlbmREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSArICdUMjM6NTk6NTknKVxyXG4gICAgICAgIC5vcmRlcigndXBkYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcblxyXG4gICAgICBpZiAoY2hhbmdlc0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHptaWFuIGtsaWVudMOzdzonLCBjaGFuZ2VzRXJyb3IpXHJcbiAgICAgICAgdGhyb3cgY2hhbmdlc0Vycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9icmFubyAke3Bob25lQ2xpY2tzPy5sZW5ndGggfHwgMH0ga2xpa25pxJnEhyB0ZWxlZm9udSBpICR7Y2xpZW50Q2hhbmdlcz8ubGVuZ3RoIHx8IDB9IHptaWFuIGtsaWVudMOzd2ApXHJcblxyXG4gICAgICAvLyBTdHfDs3J6IG1hcMSZIGRsYSBkbmkgdHlnb2RuaWFcclxuICAgICAgY29uc3QgZGF5TmFtZXMgPSBbJ05keicsICdQb24nLCAnV3QnLCAnxZpyJywgJ0N6dycsICdQdCcsICdTb2InXVxyXG4gICAgICBjb25zdCB0cmVuZHNEYXRhOiBSZWNvcmQ8c3RyaW5nLCB7IHRlbGVmb255OiBudW1iZXIsIGtsaWVuY2k6IG51bWJlciwgc2FsZXM6IG51bWJlciB9PiA9IHt9XHJcblxyXG4gICAgICAvLyBJbmljamFsaXp1aiBvc3RhdG5pZSA3IGRuaVxyXG4gICAgICBmb3IgKGxldCBpID0gNjsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKVxyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGkpXHJcbiAgICAgICAgY29uc3QgZGF5TmFtZSA9IGRheU5hbWVzW2RhdGUuZ2V0RGF5KCldXHJcbiAgICAgICAgdHJlbmRzRGF0YVtkYXlOYW1lXSA9IHsgdGVsZWZvbnk6IDAsIGtsaWVuY2k6IDAsIHNhbGVzOiAwIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgICAgICAgIC8vIEdydXB1aiBrbGlrbmnEmWNpYSB0ZWxlZm9udSB3ZWTFgnVnIGRuaVxyXG4gICAgICAgaWYgKHBob25lQ2xpY2tzICYmIEFycmF5LmlzQXJyYXkocGhvbmVDbGlja3MpKSB7XHJcbiAgICAgICAgIHBob25lQ2xpY2tzLmZvckVhY2goKGNsaWNrOiBhbnkpID0+IHtcclxuICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoY2xpY2sudGltZXN0YW1wKVxyXG4gICAgICAgICAgIGNvbnN0IGRheU5hbWUgPSBkYXlOYW1lc1tkYXRlLmdldERheSgpXVxyXG4gICAgICAgICAgIGlmICh0cmVuZHNEYXRhW2RheU5hbWVdKSB7XHJcbiAgICAgICAgICAgICB0cmVuZHNEYXRhW2RheU5hbWVdLnRlbGVmb255KytcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pXHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLy8gR3J1cHVqIHptaWFueSBrbGllbnTDs3cgd2VkxYJ1ZyBkbmlcclxuICAgICAgIGlmIChjbGllbnRDaGFuZ2VzICYmIEFycmF5LmlzQXJyYXkoY2xpZW50Q2hhbmdlcykpIHtcclxuICAgICAgICAgY2xpZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2U6IGFueSkgPT4ge1xyXG4gICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjaGFuZ2UudXBkYXRlZF9hdClcclxuICAgICAgICAgICBjb25zdCBkYXlOYW1lID0gZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV1cclxuICAgICAgICAgICBpZiAodHJlbmRzRGF0YVtkYXlOYW1lXSkge1xyXG4gICAgICAgICAgICAgdHJlbmRzRGF0YVtkYXlOYW1lXS5rbGllbmNpKytcclxuICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc3RhdHVzID09PSAnc2FsZScpIHtcclxuICAgICAgICAgICAgICAgdHJlbmRzRGF0YVtkYXlOYW1lXS5zYWxlcysrXHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICB9KVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJ6ZWtzenRhxYLEhyBuYSBmb3JtYXQgZGxhIHd5a3Jlc3UgKG9zdGF0bmllIDcgZG5pIHcga29sZWpub8WbY2kpXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdXHJcbiAgICAgIGZvciAobGV0IGkgPSA2OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gaSlcclxuICAgICAgICBjb25zdCBkYXlOYW1lID0gZGF5TmFtZXNbZGF0ZS5nZXREYXkoKV1cclxuICAgICAgICBjb25zdCBkYXlEYXRhID0gdHJlbmRzRGF0YVtkYXlOYW1lXVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE9ibGljeiBrb253ZXJzasSZIChwcm9jZW50IHNhbGVzIHd6Z2zEmWRlbSB3c3p5c3RraWNoIGtsaWVudMOzdylcclxuICAgICAgICBjb25zdCBrb253ZXJzamEgPSBkYXlEYXRhLmtsaWVuY2kgPiAwID8gTWF0aC5yb3VuZCgoZGF5RGF0YS5zYWxlcyAvIGRheURhdGEua2xpZW5jaSkgKiAxMDApIDogMFxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgIGRheTogZGF5TmFtZSxcclxuICAgICAgICAgIHRlbGVmb255OiBkYXlEYXRhLnRlbGVmb255LFxyXG4gICAgICAgICAga29ud2Vyc2phOiBrb253ZXJzamEsXHJcbiAgICAgICAgICBrbGllbmNpOiBkYXlEYXRhLmtsaWVuY2lcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyZW5keSB3eWRham5vxZtjaSB6ZXNwb8WCdSBwcnp5Z290b3dhbmU6JywgcmVzdWx0KVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHRyZW5kw7N3IHd5ZGFqbm/Fm2NpIHplc3BvxYJ1OicsIGVycm9yKVxyXG4gICAgICAvLyBXIHByenlwYWRrdSBixYLEmWR1IHp3csOzxIcgcHVzdGUgZGFuZSBkbGEgb3N0YXRuaWNoIDcgZG5pXHJcbiAgICAgIGNvbnN0IGRheU5hbWVzID0gWydOZHonLCAnUG9uJywgJ1d0JywgJ8WacicsICdDencnLCAnUHQnLCAnU29iJ11cclxuICAgICAgY29uc3QgcmVzdWx0ID0gW11cclxuICAgICAgZm9yIChsZXQgaSA9IDY7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBpKVxyXG4gICAgICAgIGNvbnN0IGRheU5hbWUgPSBkYXlOYW1lc1tkYXRlLmdldERheSgpXVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgIGRheTogZGF5TmFtZSxcclxuICAgICAgICAgIHRlbGVmb255OiAwLFxyXG4gICAgICAgICAga29ud2Vyc2phOiAwLFxyXG4gICAgICAgICAga2xpZW5jaTogMFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIEFQSSBkbGEgc3RhdHlzdHlrIG9zb2Jpc3R5Y2ggcHJhY293bmlrYVxyXG4gIGFzeW5jIGdldE15UGVyc29uYWxTdGF0cyh1c2VyOiBVc2VyKTogUHJvbWlzZTx7XHJcbiAgICBwaG9uZUNhbGxzVGhpc01vbnRoOiBudW1iZXIsXHJcbiAgICBjbGllbnRTdGF0czogeyBzdGF0dXM6IHN0cmluZywgY291bnQ6IG51bWJlciwgY29sb3I6IHN0cmluZyB9W10sXHJcbiAgICB0b3RhbENsaWVudHM6IG51bWJlcixcclxuICAgIGNvbW1pc3Npb25Ub3RhbDogbnVtYmVyLFxyXG4gICAgd29ya2luZ0hvdXJzVGhpc01vbnRoOiB7IGRheTogc3RyaW5nLCBob3VyczogbnVtYmVyIH1bXSxcclxuICAgIHRvdGFsV29ya2luZ0hvdXJzOiBudW1iZXIsXHJcbiAgICB0b3RhbFdvcmtpbmdEYXlzOiBudW1iZXJcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBQb2JpZXJhbmllIG9zb2Jpc3R5Y2ggc3RhdHlzdHlrIHByYWNvd25pa2E6JywgdXNlci5pZCwgdXNlci5yb2xlKVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogY3p5IHXFvHl0a293bmlrIHRvIHByYWNvd25pa1xyXG4gICAgICBpZiAodXNlci5yb2xlICE9PSAncHJhY293bmlrJykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBOaWVhdXRvcnl6b3dhbmEgcm9sYTonLCB1c2VyLnJvbGUpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb3N0xJlwIHR5bGtvIGRsYSBwcmFjb3duaWvDs3cnKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFXFvHl0a293bmlrIGF1dG9yeXpvd2FueSBqYWtvIHByYWNvd25paycpXHJcblxyXG4gICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKClcclxuICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gY3VycmVudERhdGUudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KSAvLyBZWVlZLU1NXHJcbiAgICAgIFxyXG4gICAgICAvLyBVc3RhdyBwaWVyd3N6eSBpIG9zdGF0bmkgZHppZcWEIG1pZXNpxIVjYSBwcmF3aWTFgm93b1xyXG4gICAgICBjb25zdCBzdGFydE9mTW9udGggPSBuZXcgRGF0ZShjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpLCBjdXJyZW50RGF0ZS5nZXRNb250aCgpLCAxKVxyXG4gICAgICBjb25zdCBlbmRPZk1vbnRoID0gbmV3IERhdGUoY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSwgY3VycmVudERhdGUuZ2V0TW9udGgoKSArIDEsIDAsIDIzLCA1OSwgNTkpXHJcbiAgICAgIFxyXG4gICAgICAvLyAxLiBQb2JpZXJ6IGxpY3pixJkgdGVsZWZvbsOzdyB3IHR5bSBtaWVzacSFY3UgKGtsaWtuacSZY2lhIHRlbGVmb251KVxyXG4gICAgICBjb25zdCB7IGRhdGE6IHBob25lQ2xpY2tzLCBlcnJvcjogcGhvbmVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnYWN0aXZpdHlfbG9ncycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIHRpbWVzdGFtcCcpXHJcbiAgICAgICAgLmVxKCdjaGFuZ2VkX2J5JywgdXNlci5pZClcclxuICAgICAgICAuZXEoJ2ZpZWxkX2NoYW5nZWQnLCAnbGFzdF9waG9uZV9jbGljaycpXHJcbiAgICAgICAgLmd0ZSgndGltZXN0YW1wJywgc3RhcnRPZk1vbnRoLnRvSVNPU3RyaW5nKCkpXHJcbiAgICAgICAgLmx0ZSgndGltZXN0YW1wJywgZW5kT2ZNb250aC50b0lTT1N0cmluZygpKVxyXG5cclxuICAgICAgaWYgKHBob25lRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEga2xpa25pxJnEhyB0ZWxlZm9udTonLCBwaG9uZUVycm9yKVxyXG4gICAgICAgIHRocm93IHBob25lRXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcGhvbmVDYWxsc1RoaXNNb250aCA9IHBob25lQ2xpY2tzPy5sZW5ndGggfHwgMFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TniBabmFsZXppb25vICR7cGhvbmVDYWxsc1RoaXNNb250aH0ga2xpa25pxJnEhyB0ZWxlZm9udSB3IHR5bSBtaWVzacSFY3VgKVxyXG5cclxuICAgICAgLy8gMi4gUG9iaWVyeiBrbGllbnTDs3cgcHJ6eXBpc2FueWNoIGRvIHByYWNvd25pa2FcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgUG9iaWVyYW5pZSBrbGllbnTDs3cgcHJ6eXBpc2FueWNoIGRvIHByYWNvd25pa2EuLi4nKVxyXG4gICAgICBjb25zdCB7IGRhdGE6IG15Q2xpZW50cywgZXJyb3I6IGNsaWVudHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY2xpZW50cycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIHN0YXR1cywgZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCBjb21wYW55X25hbWUnKVxyXG4gICAgICAgIC5lcSgnb3duZXJfaWQnLCB1c2VyLmlkKVxyXG5cclxuICAgICAgaWYgKGNsaWVudHNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBrbGllbnTDs3c6JywgY2xpZW50c0Vycm9yKVxyXG4gICAgICAgIHRocm93IGNsaWVudHNFcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjbGllbnRzID0gbXlDbGllbnRzIHx8IFtdXHJcbiAgICAgIGNvbnN0IHRvdGFsQ2xpZW50cyA9IGNsaWVudHMubGVuZ3RoXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5GkIFByYWNvd25payBtYSAke3RvdGFsQ2xpZW50c30gcHJ6eXBpc2FueWNoIGtsaWVudMOzd2ApXHJcblxyXG4gICAgICAvLyAzLiBBZ3JlZ3VqIHN0YXR1c3kga2xpZW50w7N3XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEFncmVnb3dhbmllIHN0YXR1c8OzdyBrbGllbnTDs3cuLi4nKVxyXG4gICAgICBjb25zdCBzdGF0dXNNYXAgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpXHJcbiAgICAgIGNsaWVudHMuZm9yRWFjaChjbGllbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGNsaWVudC5zdGF0dXNcclxuICAgICAgICBzdGF0dXNNYXAuc2V0KHN0YXR1cywgKHN0YXR1c01hcC5nZXQoc3RhdHVzKSB8fCAwKSArIDEpXHJcbiAgICAgIH0pXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OIIFN0YXR1c3kga2xpZW50w7N3OicsIE9iamVjdC5mcm9tRW50cmllcyhzdGF0dXNNYXApKVxyXG5cclxuICAgICAgLy8gTWFwdWogc3RhdHVzeSBuYSBrb2xvcnlcclxuICAgICAgY29uc3Qgc3RhdHVzQ29sb3JzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgIGNhbnZhczogJyMwNmI2ZDQnLFxyXG4gICAgICAgIHNhbGU6ICcjMTBiOTgxJyxcclxuICAgICAgICBhbnR5c2FsZTogJyNmNTllMGInLFxyXG4gICAgICAgIGJyYWtfa29udGFrdHU6ICcjNmI3MjgwJyxcclxuICAgICAgICBuaWVfemFpbnRlcmVzb3dhbnk6ICcjZWY0NDQ0JyxcclxuICAgICAgICB6ZGVuZXJ3b3dhbnk6ICcjZGMyNjI2JyxcclxuICAgICAgICAnJCQnOiAnI2ZiYmYyNCdcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2xpZW50U3RhdHMgPSBBcnJheS5mcm9tKHN0YXR1c01hcC5lbnRyaWVzKCkpLm1hcCgoW3N0YXR1cywgY291bnRdKSA9PiAoe1xyXG4gICAgICAgIHN0YXR1cyxcclxuICAgICAgICBjb3VudCxcclxuICAgICAgICBjb2xvcjogc3RhdHVzQ29sb3JzW3N0YXR1c10gfHwgJyM2NDc0OGInXHJcbiAgICAgIH0pKVxyXG5cclxuICAgICAgLy8gNC4gUG9iaWVyeiBwcm93aXpqxJkgeiB0YWJlbGkgZW1wbG95ZWVfc3RhdHNcclxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgUG9iaWVyYW5pZSBwcm93aXpqaSB6IHRhYmVsaSBlbXBsb3llZV9zdGF0cy4uLicpXHJcbiAgICAgIGxldCBjb21taXNzaW9uVG90YWwgPSAwIC8vIHcgRVVSXHJcbiAgICAgIFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZW1wbG95ZWVTdGF0cywgZXJyb3I6IHN0YXRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnZW1wbG95ZWVfc3RhdHMnKVxyXG4gICAgICAgICAgLnNlbGVjdCgndG90YWxfY29tbWlzc2lvbnMnKVxyXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcclxuICAgICAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgICAgICBpZiAoc3RhdHNFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTmllIHpuYWxlemlvbm8gc3RhdHlzdHlrIHByYWNvd25pa2EsIHByb3dpemphID0gMDonLCBzdGF0c0Vycm9yKVxyXG4gICAgICAgICAgY29tbWlzc2lvblRvdGFsID0gMFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyB0b3RhbF9jb21taXNzaW9ucyBqdcW8IGplc3QgdyBFVVIgLSB1xbx5d2FqIGJlenBvxZtyZWRuaW9cclxuICAgICAgICAgIGNvbW1pc3Npb25Ub3RhbCA9IGVtcGxveWVlU3RhdHMudG90YWxfY29tbWlzc2lvbnMgfHwgMFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfkrAgUHJvd2l6amEgcG9icmFuYSB6IGJhenk6ICR7Y29tbWlzc2lvblRvdGFsfSBFVVJgKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgcHJvd2l6amkgeiBlbXBsb3llZV9zdGF0czonLCBlcnJvcilcclxuICAgICAgICBjb21taXNzaW9uVG90YWwgPSAwXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDUuIFBvYmllcnogZ29kemlueSBwcmFjeSB6IHRlZ28gbWllc2nEhWNhIG5hIHBvZHN0YXdpZSBhY3Rpdml0eV9sb2dzXHJcbiAgICAgIGNvbnNvbGUubG9nKCfij7AgUG9iaWVyYW5pZSBha3R5d25vxZtjaSB6IHRlZ28gbWllc2nEhWNhLi4uJylcclxuICAgICAgY29uc29sZS5sb2coYPCfk4UgWmFrcmVzIGRhdDogJHtzdGFydE9mTW9udGgudG9JU09TdHJpbmcoKX0gLSAke2VuZE9mTW9udGgudG9JU09TdHJpbmcoKX1gKVxyXG4gICAgICBjb25zdCB7IGRhdGE6IGFjdGl2aXRpZXMsIGVycm9yOiBhY3Rpdml0aWVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2FjdGl2aXR5X2xvZ3MnKVxyXG4gICAgICAgIC5zZWxlY3QoJ3RpbWVzdGFtcCcpXHJcbiAgICAgICAgLmVxKCdjaGFuZ2VkX2J5JywgdXNlci5pZClcclxuICAgICAgICAuZ3RlKCd0aW1lc3RhbXAnLCBzdGFydE9mTW9udGgudG9JU09TdHJpbmcoKSlcclxuICAgICAgICAubHRlKCd0aW1lc3RhbXAnLCBlbmRPZk1vbnRoLnRvSVNPU3RyaW5nKCkpXHJcbiAgICAgICAgLm9yZGVyKCd0aW1lc3RhbXAnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxyXG5cclxuICAgICAgaWYgKGFjdGl2aXRpZXNFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBha3R5d25vxZtjaTonLCBhY3Rpdml0aWVzRXJyb3IpXHJcbiAgICAgICAgdGhyb3cgYWN0aXZpdGllc0Vycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgWm5hbGV6aW9ubyAke2FjdGl2aXRpZXM/Lmxlbmd0aCB8fCAwfSBha3R5d25vxZtjaSB3IHR5bSBtaWVzacSFY3VgKVxyXG5cclxuICAgICAgLy8gR3J1cHVqIGFrdHl3bm/Fm2NpIHdlZMWCdWcgZG5pIGkgb2JsaWN6IGdvZHppbnkgcHJhY3lcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4UgR3J1cG93YW5pZSBha3R5d25vxZtjaSB3ZWTFgnVnIGRuaS4uLicpXHJcbiAgICAgIGNvbnN0IGRhaWx5QWN0aXZpdGllcyA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8bnVtYmVyPj4oKVxyXG4gICAgICBcclxuICAgICAgaWYgKGFjdGl2aXRpZXMgJiYgYWN0aXZpdGllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgYWN0aXZpdGllcy5mb3JFYWNoKGFjdGl2aXR5ID0+IHtcclxuICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShhY3Rpdml0eS50aW1lc3RhbXApXHJcbiAgICAgICAgICBjb25zdCBkYXkgPSBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSAvLyBZWVlZLU1NLUREXHJcbiAgICAgICAgICBjb25zdCBob3VyID0gZGF0ZS5nZXRIb3VycygpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICghZGFpbHlBY3Rpdml0aWVzLmhhcyhkYXkpKSB7XHJcbiAgICAgICAgICAgIGRhaWx5QWN0aXZpdGllcy5zZXQoZGF5LCBuZXcgU2V0KCkpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYWlseUFjdGl2aXRpZXMuZ2V0KGRheSkhLmFkZChob3VyKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByemVrc3p0YcWCxIcgbmEgZm9ybWF0IGRsYSB3eWtyZXN1XHJcbiAgICAgIGNvbnN0IHdvcmtpbmdIb3Vyc1RoaXNNb250aCA9IEFycmF5LmZyb20oZGFpbHlBY3Rpdml0aWVzLmVudHJpZXMoKSlcclxuICAgICAgICAubWFwKChbZGF5LCBob3Vyc10pID0+ICh7XHJcbiAgICAgICAgICBkYXk6IG5ldyBEYXRlKGRheSkudG9Mb2NhbGVEYXRlU3RyaW5nKCdwbC1QTCcsIHsgd2Vla2RheTogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfSksXHJcbiAgICAgICAgICBob3VyczogaG91cnMuc2l6ZSxcclxuICAgICAgICAgIHNvcnREYXRlOiBuZXcgRGF0ZShkYXkpIC8vIERvZGFqIHBvbGUgZG8gc29ydG93YW5pYVxyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnNvcnREYXRlLmdldFRpbWUoKSAtIGIuc29ydERhdGUuZ2V0VGltZSgpKVxyXG4gICAgICAgIC5tYXAoKHsgZGF5LCBob3VycyB9KSA9PiAoeyBkYXksIGhvdXJzIH0pKSAvLyBVc3XFhCBwb2xlIHNvcnREYXRlIHogd3luaWtvd3ljaCBkYW55Y2hcclxuXHJcbiAgICAgIGNvbnN0IHRvdGFsV29ya2luZ0hvdXJzID0gQXJyYXkuZnJvbShkYWlseUFjdGl2aXRpZXMudmFsdWVzKCkpXHJcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBob3VycykgPT4gc3VtICsgaG91cnMuc2l6ZSwgMClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRvdGFsV29ya2luZ0RheXMgPSBkYWlseUFjdGl2aXRpZXMuc2l6ZVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ+KchSBTdGF0eXN0eWtpIG9zb2Jpc3RlIHByenlnb3Rvd2FuZTonLCB7XHJcbiAgICAgICAgcGhvbmVDYWxsc1RoaXNNb250aCxcclxuICAgICAgICB0b3RhbENsaWVudHMsXHJcbiAgICAgICAgY29tbWlzc2lvblRvdGFsLFxyXG4gICAgICAgIHRvdGFsV29ya2luZ0hvdXJzLFxyXG4gICAgICAgIHRvdGFsV29ya2luZ0RheXNcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGhvbmVDYWxsc1RoaXNNb250aCxcclxuICAgICAgICBjbGllbnRTdGF0cyxcclxuICAgICAgICB0b3RhbENsaWVudHMsXHJcbiAgICAgICAgY29tbWlzc2lvblRvdGFsLFxyXG4gICAgICAgIHdvcmtpbmdIb3Vyc1RoaXNNb250aCxcclxuICAgICAgICB0b3RhbFdvcmtpbmdIb3VycyxcclxuICAgICAgICB0b3RhbFdvcmtpbmdEYXlzXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgb3NvYmlzdHljaCBzdGF0eXN0eWs6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBTemN6ZWfDs8WCb3dlIGluZm9ybWFjamUgbyBixYLEmWR6aWVcclxuICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfwn5OLIFN6Y3plZ8OzxYJ5IGLFgsSZZHU6Jywge1xyXG4gICAgICAgICAgbWVzc2FnZTogKGVycm9yIGFzIGFueSkubWVzc2FnZSxcclxuICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUsXHJcbiAgICAgICAgICBkZXRhaWxzOiAoZXJyb3IgYXMgYW55KS5kZXRhaWxzLFxyXG4gICAgICAgICAgaGludDogKGVycm9yIGFzIGFueSkuaGludCxcclxuICAgICAgICAgIHN0YWNrOiAoZXJyb3IgYXMgYW55KS5zdGFja1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEplxZtsaSB0byBixYLEhWQgUkxTIGx1YiB1cHJhd25pZcWELCB6d3LDs8SHIHB1c3TEhSBzdHJ1a3R1csSZIHphbWlhc3QgY3Jhc2hvd2HEh1xyXG4gICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBcclxuICAgICAgICAgICgoZXJyb3IgYXMgYW55KS5jb2RlID09PSAnUEdSU1QxMTYnIHx8IFxyXG4gICAgICAgICAgIChlcnJvciBhcyBhbnkpLm1lc3NhZ2U/LmluY2x1ZGVzKCdSTFMnKSB8fCBcclxuICAgICAgICAgICAoZXJyb3IgYXMgYW55KS5tZXNzYWdlPy5pbmNsdWRlcygncGVybWlzc2lvbicpKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign8J+UkiBQcm9ibGVtIHogdXByYXduaWVuaWFtaSAtIHp3cmFjYW0gZG9tecWbbG5lIGRhbmUnKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwaG9uZUNhbGxzVGhpc01vbnRoOiAwLFxyXG4gICAgICAgICAgY2xpZW50U3RhdHM6IFtdLFxyXG4gICAgICAgICAgdG90YWxDbGllbnRzOiAwLFxyXG4gICAgICAgICAgY29tbWlzc2lvblRvdGFsOiAwLFxyXG4gICAgICAgICAgd29ya2luZ0hvdXJzVGhpc01vbnRoOiBbXSxcclxuICAgICAgICAgIHRvdGFsV29ya2luZ0hvdXJzOiAwLFxyXG4gICAgICAgICAgdG90YWxXb3JraW5nRGF5czogMFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBGdW5rY2plIGRvIHphcnrEhWR6YW5pYSBnb2R6aW5hbWkgcHJhY3kgcHJhY293bmlrYVxyXG4gIGFzeW5jIHNhdmVXb3JraW5nSG91cnModXNlcjogVXNlciwgZGF0ZTogc3RyaW5nLCBob3VyczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4o+wIFphcGlzeXdhbmllIGdvZHppbiBwcmFjeTogJHtob3Vyc31oIGRsYSBkbmlhICR7ZGF0ZX1gKVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogY3p5IHXFvHl0a293bmlrIHRvIHByYWNvd25pa1xyXG4gICAgICBpZiAodXNlci5yb2xlICE9PSAncHJhY293bmlrJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9zdMSZcCB0eWxrbyBkbGEgcHJhY293bmlrw7N3JylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRU5IQU5DRUQgREVCVUc6IFNwcmF3ZMW6IGN6eSB0byBkemllxYQgcm9ib2N6eSAocG9uLXB0KSAtIGJlenBpZWN6bmUgcGFyc293YW5pZSBkYXR5XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIERFQlVHOiBJbnB1dCBkYXRlIHN0cmluZzogXCIke2RhdGV9XCJgKVxyXG4gICAgICBjb25zdCBkYXRlUGFydHMgPSBkYXRlLnNwbGl0KCctJykgLy8gXCIyMDI1LTA2LTAyXCIgLT4gW1wiMjAyNVwiLCBcIjA2XCIsIFwiMDJcIl1cclxuICAgICAgY29uc29sZS5sb2coYPCflI0gREVCVUc6IERhdGUgcGFydHM6YCwgZGF0ZVBhcnRzKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGRhdGVQYXJ0c1swXSlcclxuICAgICAgY29uc3QgbW9udGggPSBwYXJzZUludChkYXRlUGFydHNbMV0pIC0gMSAvLyAtMSBibyBKYXZhU2NyaXB0IHXFvHl3YSAwLTExIGRsYSBtaWVzacSZY3lcclxuICAgICAgY29uc3QgZGF5ID0gcGFyc2VJbnQoZGF0ZVBhcnRzWzJdKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gREVCVUc6IFBhcnNlZCBjb21wb25lbnRzOiB5ZWFyPSR7eWVhcn0sIG1vbnRoPSR7bW9udGh9IChKUyBmb3JtYXQpLCBkYXk9JHtkYXl9YClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhdGVPYmogPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KVxyXG4gICAgICBjb25zdCBkYXlPZldlZWsgPSBkYXRlT2JqLmdldERheSgpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBERUJVRzogQ3JlYXRlZCBEYXRlIG9iamVjdDogJHtkYXRlT2JqLnRvSVNPU3RyaW5nKCl9YClcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gREVCVUc6IERhdGUgaW4gbG9jYWwgZm9ybWF0OiAke2RhdGVPYmoudG9Mb2NhbGVEYXRlU3RyaW5nKCdwbC1QTCcsIHsgd2Vla2RheTogJ2xvbmcnLCB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pfWApXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5eT77iPIFNwcmF3ZHphbmllIGRuaWEgcm9ib2N6ZWdvOiAke2RhdGV9ID0+IGRheU9mV2Vlaz0ke2RheU9mV2Vla30gKCR7WyduaWVkemllbGEnLCAncG9uaWVkemlhxYJlaycsICd3dG9yZWsnLCAnxZtyb2RhJywgJ2N6d2FydGVrJywgJ3BpxIV0ZWsnLCAnc29ib3RhJ11bZGF5T2ZXZWVrXX0pYClcclxuICAgICAgXHJcbiAgICAgIGlmIChkYXlPZldlZWsgPT09IDAgfHwgZGF5T2ZXZWVrID09PSA2KSB7IC8vIDAgPSBuaWVkemllbGEsIDYgPSBzb2JvdGFcclxuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgQsWBxIREOiBQcsOzYmEgemFwaXNhbmlhIGdvZHppbiBkbGEgd2Vla2VuZHUhIER6aWXFhCB0eWdvZG5pYTogJHtkYXlPZldlZWt9ICgke1snbmllZHppZWxhJywgJ3BvbmllZHppYcWCZWsnLCAnd3RvcmVrJywgJ8Wbcm9kYScsICdjendhcnRlaycsICdwacSFdGVrJywgJ3NvYm90YSddW2RheU9mV2Vla119KWApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb8W8bmEgd3Bpc3l3YcSHIGdvZHppbnkgdHlsa28gZGxhIGRuaSByb2JvY3p5Y2ggKHBvbi1wdCknKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIER6aWXFhCByb2JvY3p5IHBvdHdpZXJkem9ueTogJHtbJ25pZWR6aWVsYScsICdwb25pZWR6aWHFgmVrJywgJ3d0b3JlaycsICfFm3JvZGEnLCAnY3p3YXJ0ZWsnLCAncGnEhXRlaycsICdzb2JvdGEnXVtkYXlPZldlZWtdfWApXHJcblxyXG4gICAgICAvLyBXYWxpZGFjamEgZ29kemluICgwLTEyKVxyXG4gICAgICBpZiAoaG91cnMgPCAwIHx8IGhvdXJzID4gMTIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpY3piYSBnb2R6aW4gbXVzaSBiecSHIG1pxJlkenkgMCBhIDEyJylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBzZXJ0IGdvZHppbiBwcmFjeSB3IGJhemllIGRhbnljaCAodGFiZWxhIGp1xbwgaXN0bmllamUpXHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ3dvcmtpbmdfaG91cnMnKVxyXG4gICAgICAgIC51cHNlcnQoe1xyXG4gICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcclxuICAgICAgICAgIHdvcmtfZGF0ZTogZGF0ZSxcclxuICAgICAgICAgIGhvdXJzX3dvcmtlZDogaG91cnMsXHJcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCx3b3JrX2RhdGUnXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgemFwaXN5d2FuaWEgZ29kemluIHByYWN5IGRvIGJhenk6JywgZXJyb3IpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRmFsbGJhY2sgZG8gbG9jYWxTdG9yYWdlIHR5bGtvIHByenkgYsWCxJlkemllIGJhenkgZGFueWNoXHJcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gQsWCxIVkIGJhenkgZGFueWNoIC0gdcW8eXdhbSBsb2NhbFN0b3JhZ2UgamFrbyBmYWxsYmFjaycpXHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IGB3b3JraW5nX2hvdXJzXyR7dXNlci5pZH1gXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KSB8fCAne30nKVxyXG4gICAgICAgIGV4aXN0aW5nRGF0YVtkYXRlXSA9IGhvdXJzXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhKSlcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFphcGlzYW5vICR7aG91cnN9aCBkbGEgZG5pYSAke2RhdGV9IChsb2NhbFN0b3JhZ2UgZmFsbGJhY2spYClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBaYXBpc2FubyAke2hvdXJzfWggZGxhIGRuaWEgJHtkYXRlfSAoYmF6YSBkYW55Y2ggd29ya2luZ19ob3VycylgKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IHNhdmVXb3JraW5nSG91cnM6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBVbHRpbWF0ZSBmYWxsYmFjayAtIGxvY2FsU3RvcmFnZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFXFvHl3YW0gbG9jYWxTdG9yYWdlIGpha28gb3N0YXRlY3pueSBmYWxsYmFjaycpXHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IGB3b3JraW5nX2hvdXJzXyR7dXNlci5pZH1gXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KSB8fCAne30nKVxyXG4gICAgICAgIGV4aXN0aW5nRGF0YVtkYXRlXSA9IGhvdXJzXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhKSlcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFphcGlzYW5vICR7aG91cnN9aCBkbGEgZG5pYSAke2RhdGV9IChsb2NhbFN0b3JhZ2UgdWx0aW1hdGUgZmFsbGJhY2spYClcclxuICAgICAgfSBjYXRjaCAoc3RvcmFnZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE5pZSB1ZGHFgm8gc2nEmSB6YXBpc2HEhyBuYXdldCBkbyBsb2NhbFN0b3JhZ2U6Jywgc3RvcmFnZUVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBnZXRXb3JraW5nSG91cnNGb3JNb250aCh1c2VyOiBVc2VyLCB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgUG9iaWVyYW5pZSBnb2R6aW4gcHJhY3kgZGxhICR7eWVhcn0tJHttb250aH1gKVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogY3p5IHXFvHl0a293bmlrIHRvIHByYWNvd25pa1xyXG4gICAgICBpZiAodXNlci5yb2xlICE9PSAncHJhY293bmlrJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9zdMSZcCB0eWxrbyBkbGEgcHJhY293bmlrw7N3JylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT2JsaWN6IHBpZXJ3c3p5IGkgb3N0YXRuaSBkemllxYQgbWllc2nEhWNhIChwb3ByYXdrYSBzdHJlZnkgY3phc293ZWopXHJcbiAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGAke3llYXJ9LSR7bW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfS0wMWBcclxuICAgICAgY29uc3QgZW5kRGF0ZSA9IGAke3llYXJ9LSR7bW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfS0ke25ldyBEYXRlKHllYXIsIG1vbnRoLCAwKS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWBcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OFIFBvYmllcmFuaWUgZ29kemluIGRsYSB6YWtyZXN1OiAke3N0YXJ0RGF0ZX0gLSAke2VuZERhdGV9YClcclxuXHJcbiAgICAgIC8vIFBvYmllcnogZ29kemlueSBwcmFjeSB6IHRhYmVsaSB3b3JraW5nX2hvdXJzICh0YWJlbGEganXFvCBpc3RuaWVqZSlcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnd29ya2luZ19ob3VycycpXHJcbiAgICAgICAgLnNlbGVjdCgnd29ya19kYXRlLCBob3Vyc193b3JrZWQnKVxyXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXHJcbiAgICAgICAgLmd0ZSgnd29ya19kYXRlJywgc3RhcnREYXRlKVxyXG4gICAgICAgIC5sdGUoJ3dvcmtfZGF0ZScsIGVuZERhdGUpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgZ29kemluIHByYWN5IHogYmF6eTonLCBlcnJvcilcclxuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBCxYLEhWQgYmF6eSBkYW55Y2ggLSB1xbx5d2FtIGxvY2FsU3RvcmFnZSBqYWtvIGZhbGxiYWNrJylcclxuICAgICAgICBcclxuICAgICAgICAvLyBGYWxsYmFjayBkbyBsb2NhbFN0b3JhZ2UgdHlsa28gcHJ6eSBixYLEmWR6aWUgYmF6eSBkYW55Y2hcclxuICAgICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYHdvcmtpbmdfaG91cnNfJHt1c2VyLmlkfWBcclxuICAgICAgICBjb25zdCBzdG9yZWREYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KSB8fCAne30nKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZpbHRydWogZGFuZSBkbGEgb2Rwb3dpZWRuaWVnbyBtaWVzacSFY2FcclxuICAgICAgICBjb25zdCBob3Vyc01hcDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkuZm9yRWFjaCgoW2RhdGUsIGhvdXJzXSkgPT4ge1xyXG4gICAgICAgICAgLy8gVcW8eWogcG9yw7N3bmFuaWEgc3RyaW5nw7N3IGRsYSBkYXQgdyBmb3JtYWNpZSBZWVlZLU1NLUREXHJcbiAgICAgICAgICBpZiAoZGF0ZSA+PSBzdGFydERhdGUgJiYgZGF0ZSA8PSBlbmREYXRlKSB7XHJcbiAgICAgICAgICAgIGhvdXJzTWFwW2RhdGVdID0gaG91cnMgYXMgbnVtYmVyXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBvYnJhbm8gZ29kemlueSBwcmFjeSB6IGxvY2FsU3RvcmFnZSBmYWxsYmFjayBkbGEgJHtPYmplY3Qua2V5cyhob3Vyc01hcCkubGVuZ3RofSBkbmlgKVxyXG4gICAgICAgIHJldHVybiBob3Vyc01hcFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBLb253ZXJ0dWogbmEgb2JpZWt0IGRhdGUgLT4gaG91cnNcclxuICAgICAgY29uc3QgaG91cnNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICBob3Vyc01hcFtlbnRyeS53b3JrX2RhdGVdID0gZW50cnkuaG91cnNfd29ya2VkXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBQb2JyYW5vIGdvZHppbnkgcHJhY3kgeiB0YWJlbGkgd29ya2luZ19ob3VycyBkbGEgJHtkYXRhPy5sZW5ndGggfHwgMH0gZG5pYClcclxuICAgICAgcmV0dXJuIGhvdXJzTWFwXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHcgZ2V0V29ya2luZ0hvdXJzRm9yTW9udGg6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBVbHRpbWF0ZSBmYWxsYmFjayAtIGxvY2FsU3RvcmFnZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFXFvHl3YW0gbG9jYWxTdG9yYWdlIGpha28gb3N0YXRlY3pueSBmYWxsYmFjaycpXHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleSA9IGB3b3JraW5nX2hvdXJzXyR7dXNlci5pZH1gXHJcbiAgICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkgfHwgJ3t9JylcclxuICAgICAgICBcclxuICAgICAgICAvLyBGaWx0cnVqIGRhbmUgZGxhIG9kcG93aWVkbmllZ28gbWllc2nEhWNhXHJcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlU3RyID0gYCR7eWVhcn0tJHttb250aC50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LTAxYFxyXG4gICAgICAgIGNvbnN0IGVuZERhdGVTdHIgPSBgJHt5ZWFyfS0ke21vbnRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0tJHtuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCkuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gXHJcbiAgICAgICAgY29uc3QgaG91cnNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxyXG4gICAgICAgIFxyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN0b3JlZERhdGEpLmZvckVhY2goKFtkYXRlLCBob3Vyc10pID0+IHtcclxuICAgICAgICAgIC8vIFXFvHlqIHBvcsOzd25hbmlhIHN0cmluZ8OzdyBkbGEgZGF0IHcgZm9ybWFjaWUgWVlZWS1NTS1ERFxyXG4gICAgICAgICAgaWYgKGRhdGUgPj0gc3RhcnREYXRlU3RyICYmIGRhdGUgPD0gZW5kRGF0ZVN0cikge1xyXG4gICAgICAgICAgICBob3Vyc01hcFtkYXRlXSA9IGhvdXJzIGFzIG51bWJlclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBQb2JyYW5vIGdvZHppbnkgcHJhY3kgeiBsb2NhbFN0b3JhZ2UgdWx0aW1hdGUgZmFsbGJhY2sgZGxhICR7T2JqZWN0LmtleXMoaG91cnNNYXApLmxlbmd0aH0gZG5pYClcclxuICAgICAgICByZXR1cm4gaG91cnNNYXBcclxuICAgICAgfSBjYXRjaCAoc3RvcmFnZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIG5hd2V0IHogbG9jYWxTdG9yYWdlOicsIHN0b3JhZ2VFcnJvcilcclxuICAgICAgICByZXR1cm4ge31cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIPCfmoAgTk9XRSBGVU5LQ0pFIFBFUkZPUk1BTkNFIC0gTWF0ZXJpYWxpem93YW5lIFdpZG9raVxyXG5cclxuICAvLyBaYXN0xJlwdWplIGNpxJnFvGtpZSBKT0lOJ3kgLSB0ZXJheiBuYXR5Y2htaWFzdG93ZSDFgmFkb3dhbmllXHJcbiAgYXN5bmMgZ2V0TW9udGhseUVtcGxveWVlUGVyZm9ybWFuY2UoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBQb2JpZXJhbmllIHd5ZGFqbm/Fm2NpIHByYWNvd25pa8OzdyBkbGEgJHt5ZWFyfS0ke21vbnRofSAoem9wdHltYWxpem93YW5lKS4uLmApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2dldF9tb250aGx5X2VtcGxveWVlX3BlcmZvcm1hbmNlJywge1xyXG4gICAgICAgIHRhcmdldF95ZWFyOiB5ZWFyLFxyXG4gICAgICAgIHRhcmdldF9tb250aDogbW9udGhcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSB3eWRham5vxZtjaSBwcmFjb3duaWvDs3c6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYOKchSBXeWRham5vxZvEhyBwcmFjb3duaWvDs3cgcG9icmFuYTogJHtkYXRhPy5sZW5ndGggfHwgMH0gcmVrb3Jkw7N3YClcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRNb250aGx5RW1wbG95ZWVQZXJmb3JtYW5jZSBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gU3p5YmtpZSBzdGF0eXN0eWtpIHplc3BvxYJ1IG5hIHBvZHN0YXdpZSBtYXRlcmlhbGl6b3dhbnljaCB3aWRva8Ozd1xyXG4gIGFzeW5jIGdldFRlYW1TdW1tYXJ5KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnbXZfbW9udGhseV9lbXBsb3llZV9zdGF0cycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLmVxKCd5ZWFyJywgeWVhcilcclxuICAgICAgICAuZXEoJ21vbnRoJywgbW9udGgpXHJcbiAgICAgICAgLm9yZGVyKCdvd25lZF9zYWxlcycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRUZWFtU3VtbWFyeSBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHl0aWNzIC0gdG9wIHBlcmZvcm1lcnNcclxuICBhc3luYyBnZXRUb3BQZXJmb3JtZXJzKGxpbWl0OiBudW1iZXIgPSAxMCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdnZXRfdG9wX3BlcmZvcm1lcnMnLCB7XHJcbiAgICAgICAgbGltaXRfY291bnQ6IGxpbWl0XHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIGdldFRvcFBlcmZvcm1lcnMgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQVBJIGRsYSBsb2thbGl6YWNqaS9rcmFqw7N3XHJcbmV4cG9ydCBjb25zdCBsb2NhdGlvbnNBcGkgPSB7XHJcbiAgLy8gUG9iaWVyeiB3c3p5c3RraWUgbG9rYWxpemFjamUgKHBvZHN0YXdvd2UgaW5mb3JtYWNqZSAtIGRsYSByZWplc3RyYWNqaSlcclxuICBhc3luYyBnZXRBbGxMb2NhdGlvbnMoKTogUHJvbWlzZTxMb2NhdGlvbltdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdsb2NhdGlvbnMnKVxyXG4gICAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgY29kZSxcclxuICAgICAgICAgIGN1cnJlbmN5LFxyXG4gICAgICAgICAgdGltZXpvbmUsXHJcbiAgICAgICAgICByZWdpb24sXHJcbiAgICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgICAgdXBkYXRlZF9hdFxyXG4gICAgICAgIGApXHJcbiAgICAgICAgLm9yZGVyKCduYW1lJylcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBsb2thbGl6YWNqaTonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBvYnJhbm8gbG9rYWxpemFjamU6JywgZGF0YT8ubGVuZ3RoIHx8IDApXHJcbiAgICAgIHJldHVybiBkYXRhIGFzIExvY2F0aW9uW11cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRBbGxMb2NhdGlvbnMgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFBvYmllcnogd3N6eXN0a2llIGxva2FsaXphY2plIHogcGXFgm55bWkgaW5mb3JtYWNqYW1pIChkbGEgemFsb2dvd2FueWNoIHXFvHl0a293bmlrw7N3KVxyXG4gIGFzeW5jIGdldEFsbExvY2F0aW9uc1dpdGhNYW5hZ2VycygpOiBQcm9taXNlPExvY2F0aW9uW10+IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdsb2NhdGlvbnMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGNvZGUsXHJcbiAgICAgICAgY3VycmVuY3ksXHJcbiAgICAgICAgdGltZXpvbmUsXHJcbiAgICAgICAgcmVnaW9uLFxyXG4gICAgICAgIHByb2plY3RfbWFuYWdlcl9pZCxcclxuICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgIHVwZGF0ZWRfYXQsXHJcbiAgICAgICAgcHJvamVjdF9tYW5hZ2VyOnVzZXJzIXByb2plY3RfbWFuYWdlcl9pZCAoXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIGZ1bGxfbmFtZSxcclxuICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgYXZhdGFyX3VybFxyXG4gICAgICAgIClcclxuICAgICAgYClcclxuICAgICAgLm9yZGVyKCduYW1lJylcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgXHJcbiAgICAvLyBQcnpla3N6dGHFgsSHIGRhbmUgLSBTdXBhYmFzZSBKT0lOIHp3cmFjYSBwcm9qZWN0X21hbmFnZXIgamFrbyB0YWJsaWPEmVxyXG4gICAgY29uc3QgdHJhbnNmb3JtZWREYXRhID0gZGF0YT8ubWFwKChsb2NhdGlvbjogYW55KSA9PiAoe1xyXG4gICAgICAuLi5sb2NhdGlvbixcclxuICAgICAgcHJvamVjdF9tYW5hZ2VyOiBsb2NhdGlvbi5wcm9qZWN0X21hbmFnZXIgJiYgQXJyYXkuaXNBcnJheShsb2NhdGlvbi5wcm9qZWN0X21hbmFnZXIpICYmIGxvY2F0aW9uLnByb2plY3RfbWFuYWdlci5sZW5ndGggPiAwIFxyXG4gICAgICAgID8gbG9jYXRpb24ucHJvamVjdF9tYW5hZ2VyWzBdIC8vIFdlxbogcGllcndzenkgZWxlbWVudCB6IHRhYmxpY3lcclxuICAgICAgICA6IGxvY2F0aW9uLnByb2plY3RfbWFuYWdlciAmJiAhQXJyYXkuaXNBcnJheShsb2NhdGlvbi5wcm9qZWN0X21hbmFnZXIpXHJcbiAgICAgICAgPyBsb2NhdGlvbi5wcm9qZWN0X21hbmFnZXIgLy8gSnXFvCBqZXN0IHBvamVkeW5jenltIG9iaWVrdGVtXHJcbiAgICAgICAgOiBudWxsIC8vIEJyYWsgcHJvamVjdCBtYW5hZ2VyYVxyXG4gICAgfSkpXHJcbiAgICBcclxuICAgIHJldHVybiB0cmFuc2Zvcm1lZERhdGEgYXMgTG9jYXRpb25bXVxyXG4gIH0sXHJcblxyXG4gIC8vIFBvYmllcnogZG9zdMSZcG5lIGxva2FsaXphY2plIGRsYSB1xbx5dGtvd25pa2FcclxuICBhc3luYyBnZXRVc2VyQWNjZXNzaWJsZUxvY2F0aW9ucyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8TG9jYXRpb25bXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gTmFqcGllcncgc3Byw7NidWogdcW8ecSHIGZ1bmtjamkgU1FMIChqZcWbbGkgaXN0bmllamUpXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLnJwYygnZ2V0X3VzZXJfYWNjZXNzaWJsZV9sb2NhdGlvbnMnLCB7IHVzZXJfaWQ6IHVzZXJJZCB9KVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCfwn5SEIEZ1bmtjamEgU1FMIGdldF91c2VyX2FjY2Vzc2libGVfbG9jYXRpb25zIG5pZSBpc3RuaWVqZSwgdcW8eXdhbSBmYWxsYmFjayBsb2dpa2knKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBkYXRhIGFzIExvY2F0aW9uW11cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIELFgsSFZCB3eXdvxYJhbmlhIGZ1bmtjamkgU1FMLCB1xbx5d2FtIEphdmFTY3JpcHQgZmFsbGJhY2s6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBGYWxsYmFjayAtIGltcGxlbWVudGFjamEgbG9naWtpIHcgSmF2YVNjcmlwdFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFBvYmllcnogdcW8eXRrb3duaWthXHJcbiAgICAgICAgY29uc3QgeyBkYXRhOiB1c2VyLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAgIC5zZWxlY3QoJ3JvbGUsIGxvY2F0aW9uX2lkJylcclxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAgICAgICAuc2luZ2xlKClcclxuICAgICAgICBcclxuICAgICAgICBpZiAodXNlckVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTmllIG1vxbxuYSBwb2JyYcSHIGRhbnljaCB1xbx5dGtvd25pa2E6JywgdXNlckVycm9yKVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsTG9jYXRpb25zKCkgLy8gRmFsbGJhY2sgLSB6d3LDs8SHIHdzenlzdGtpZVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBTcHJhd2TFuiByb2zEmSB1xbx5dGtvd25pa2FcclxuICAgICAgICBpZiAodXNlci5yb2xlID09PSAnYWRtaW4nIHx8IHVzZXIucm9sZSA9PT0gJ3N6ZWYnKSB7XHJcbiAgICAgICAgICAvLyBBZG1pbiBpIHN6ZWYgd2lkesSFIHdzenlzdGtpZSBsb2thbGl6YWNqZVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkZEgQWRtaW4vU3plZiAtIHp3cmFjYW0gd3N6eXN0a2llIGxva2FsaXphY2plJylcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbExvY2F0aW9ucygpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFBvem9zdGFsaSB3aWR6xIUgdHlsa28gc3dvasSFIGxva2FsaXphY2rEmVxyXG4gICAgICAgICAgaWYgKCF1c2VyLmxvY2F0aW9uX2lkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFXFvHl0a293bmlrIG5pZSBtYSBwcnp5cGlzYW5laiBsb2thbGl6YWNqaScpXHJcbiAgICAgICAgICAgIHJldHVybiBbXVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+RpCBad3lrxYJ5IHXFvHl0a293bmlrIC0gendyYWNhbSBsb2thbGl6YWNqxJk6JywgdXNlci5sb2NhdGlvbl9pZClcclxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogbG9jYXRpb24sIGVycm9yOiBsb2NhdGlvbkVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgnbG9jYXRpb25zJylcclxuICAgICAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmxvY2F0aW9uX2lkKVxyXG4gICAgICAgICAgICAuc2luZ2xlKClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGxvY2F0aW9uRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE5pZSBtb8W8bmEgcG9icmHEhyBsb2thbGl6YWNqaSB1xbx5dGtvd25pa2E6JywgbG9jYXRpb25FcnJvcilcclxuICAgICAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiBbbG9jYXRpb24gYXMgTG9jYXRpb25dXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhbGxiYWNrIGxvZ2ljIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKVxyXG4gICAgICAgIC8vIE9zdGF0ZWN6bnkgZmFsbGJhY2sgLSB3c3p5c3RraWUgbG9rYWxpemFjamVcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxMb2NhdGlvbnMoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiBsb2thbGl6YWNqxJkgcG8gSURcclxuICBhc3luYyBnZXRMb2NhdGlvbkJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8TG9jYXRpb24+IHtcclxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdsb2NhdGlvbnMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICBpZCxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGNvZGUsXHJcbiAgICAgICAgY3VycmVuY3ksXHJcbiAgICAgICAgdGltZXpvbmUsXHJcbiAgICAgICAgcmVnaW9uLFxyXG4gICAgICAgIHByb2plY3RfbWFuYWdlcl9pZCxcclxuICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgIHVwZGF0ZWRfYXQsXHJcbiAgICAgICAgcHJvamVjdF9tYW5hZ2VyOnVzZXJzIXByb2plY3RfbWFuYWdlcl9pZCAoXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIGZ1bGxfbmFtZSxcclxuICAgICAgICAgIGVtYWlsLFxyXG4gICAgICAgICAgYXZhdGFyX3VybFxyXG4gICAgICAgIClcclxuICAgICAgYClcclxuICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAuc2luZ2xlKClcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgXHJcbiAgICAvLyBQcnpla3N6dGHFgsSHIGRhbmUgLSBTdXBhYmFzZSBKT0lOIHp3cmFjYSBwcm9qZWN0X21hbmFnZXIgamFrbyB0YWJsaWPEmVxyXG4gICAgY29uc3QgdHJhbnNmb3JtZWREYXRhID0ge1xyXG4gICAgICAuLi5kYXRhLFxyXG4gICAgICBwcm9qZWN0X21hbmFnZXI6IGRhdGEucHJvamVjdF9tYW5hZ2VyICYmIEFycmF5LmlzQXJyYXkoZGF0YS5wcm9qZWN0X21hbmFnZXIpICYmIGRhdGEucHJvamVjdF9tYW5hZ2VyLmxlbmd0aCA+IDAgXHJcbiAgICAgICAgPyBkYXRhLnByb2plY3RfbWFuYWdlclswXSAvLyBXZcW6IHBpZXJ3c3p5IGVsZW1lbnQgeiB0YWJsaWN5XHJcbiAgICAgICAgOiBkYXRhLnByb2plY3RfbWFuYWdlciAmJiAhQXJyYXkuaXNBcnJheShkYXRhLnByb2plY3RfbWFuYWdlcilcclxuICAgICAgICA/IGRhdGEucHJvamVjdF9tYW5hZ2VyIC8vIEp1xbwgamVzdCBwb2plZHluY3p5bSBvYmlla3RlbVxyXG4gICAgICAgIDogbnVsbCAvLyBCcmFrIHByb2plY3QgbWFuYWdlcmFcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkRGF0YSBhcyBMb2NhdGlvblxyXG4gIH0sXHJcblxyXG4gIC8vIEFrdHVhbGl6dWogcHJvamVjdCBtYW5hZ2VyYSBkbGEgbG9rYWxpemFjamlcclxuICBhc3luYyB1cGRhdGVMb2NhdGlvblByb2plY3RNYW5hZ2VyKGxvY2F0aW9uSWQ6IHN0cmluZywgcHJvamVjdE1hbmFnZXJJZDogc3RyaW5nIHwgbnVsbCwgY3VycmVudFVzZXI6IFVzZXIpOiBQcm9taXNlPExvY2F0aW9uPiB7XHJcbiAgICBpZiAoIXBlcm1pc3Npb25zQXBpLmNhbkNoYW5nZVJvbGVzKGN1cnJlbnRVc2VyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JyYWsgdXByYXduaWXFhCBkbyB6bWlhbnkgcHJvamVjdCBtYW5hZ2VyYScpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ2xvY2F0aW9ucycpXHJcbiAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgIHByb2plY3RfbWFuYWdlcl9pZDogcHJvamVjdE1hbmFnZXJJZCxcclxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgfSlcclxuICAgICAgLmVxKCdpZCcsIGxvY2F0aW9uSWQpXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKClcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcmV0dXJuIGRhdGEgYXMgTG9jYXRpb25cclxuICB9XHJcbn1cclxuXHJcbi8vIEZ1bmtjamUgYXV0b3J5emFjamlcclxuZXhwb3J0IGNvbnN0IGF1dGhBcGkgPSB7XHJcbiAgLy8gWmFsb2d1aiB1xbx5dGtvd25pa2FcclxuICBhc3luYyBzaWduSW4oZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQoe1xyXG4gICAgICBlbWFpbCxcclxuICAgICAgcGFzc3dvcmRcclxuICAgIH0pXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH0sXHJcblxyXG4gIC8vIFphcmVqZXN0cnVqIG5vd2VnbyB1xbx5dGtvd25pa2FcclxuICBhc3luYyBzaWduVXAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgZnVsbE5hbWU6IHN0cmluZywgbG9jYXRpb25JZD86IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduVXAoe1xyXG4gICAgICBlbWFpbCxcclxuICAgICAgcGFzc3dvcmQsXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBmdWxsX25hbWU6IGZ1bGxOYW1lLFxyXG4gICAgICAgICAgbG9jYXRpb25faWQ6IGxvY2F0aW9uSWRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gIH0sXHJcblxyXG4gIC8vIFd5bG9ndWogdcW8eXRrb3duaWthXHJcbiAgYXN5bmMgc2lnbk91dCgpIHtcclxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguc2lnbk91dCgpXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiBha3R1YWxuZWdvIHXFvHl0a293bmlrYVxyXG4gIGFzeW5jIGdldEN1cnJlbnRVc2VyKCkge1xyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcclxuICAgIHJldHVybiB1c2VyXHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiBwcm9maWwgdcW8eXRrb3duaWthIHogcm9sxIVcclxuICBhc3luYyBnZXRVc2VyUHJvZmlsZSh1c2VySWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAgIC5zaW5nbGUoKVxyXG4gICAgXHJcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICByZXR1cm4gZGF0YSBhcyBVc2VyXHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiB3c3p5c3RraWNoIHXFvHl0a293bmlrw7N3IChkbGEgb3BjamkgZmlsdHJvd2FuaWEpXHJcbiAgYXN5bmMgZ2V0QWxsVXNlcnMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+RpSBnZXRBbGxVc2VycyBTVEFSVCAtIHNwcmF3ZHphbSBSTFMuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogYWt0dWFsbmVnbyB1xbx5dGtvd25pa2FcclxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaQgQWt0dWFsbnkgdcW8eXRrb3duaWs6JywgdXNlcj8uZW1haWwsIHVzZXI/LmlkKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndXNlcnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmdWxsX25hbWUsIGVtYWlsLCByb2xlLCBhdmF0YXJfdXJsJylcclxuICAgICAgICAub3JkZXIoJ2Z1bGxfbmFtZScpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn8J+RpSBnZXRBbGxVc2VycyAtIHpuYWxlemlvbm8gdcW8eXRrb3duaWvDs3c6JywgZGF0YT8ubGVuZ3RoIHx8IDApXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIGdldEFsbFVzZXJzIC0gYsWCxIVkOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFJMUyBFcnJvciBpbiBnZXRBbGxVc2VyczonLCBlcnJvcilcclxuICAgICAgICBcclxuICAgICAgICAvLyBTcHJhd2TFuiBjenkgdG8gcHJvYmxlbSB6IFJMU1xyXG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnUEdSU1QxMTYnIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdSTFMnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncGVybWlzc2lvbicpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfwn5SSIFByb2JsZW0geiBSb3cgTGV2ZWwgU2VjdXJpdHkgLSBwcmFjb3duaWsgbmllIG1vxbxlIHdpZHppZcSHIGlubnljaCB1xbx5dGtvd25pa8OzdycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5GlIFByenlrxYJhZCB1xbx5dGtvd25pa8OzdzonLCBkYXRhLnNsaWNlKDAsIDMpLm1hcCh1ID0+ICh7XHJcbiAgICAgICAgICBpZDogdS5pZCxcclxuICAgICAgICAgIG5hbWU6IHUuZnVsbF9uYW1lLFxyXG4gICAgICAgICAgcm9sZTogdS5yb2xlXHJcbiAgICAgICAgfSkpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5GlIFVXQUdBOiBCcmFrIGRhbnljaCB1xbx5dGtvd25pa8OzdyAtIG1vxbxlIFJMUyBibG9rdWplIGRvc3TEmXAnKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZGF0YSBhcyBVc2VyW11cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRBbGxVc2VycyBGQUlMRUQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gU3ByYXdkxbogc2VzasSZIHXFvHl0a293bmlrYVxyXG4gIGFzeW5jIGdldFNlc3Npb24oKSB7XHJcbiAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKVxyXG4gICAgcmV0dXJuIHNlc3Npb25cclxuICB9LFxyXG5cclxuICAvLyBOYXPFgnVjaHVqIHptaWFuIHcgYXV0b3J5emFjamlcclxuICBvbkF1dGhTdGF0ZUNoYW5nZShjYWxsYmFjazogKGV2ZW50OiBzdHJpbmcsIHNlc3Npb246IGFueSkgPT4gdm9pZCkge1xyXG4gICAgcmV0dXJuIHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spXHJcbiAgfSxcclxuXHJcbiAgLy8gWmFrdHVhbGl6dWogasSZenlrIHXFvHl0a293bmlrYVxyXG4gIGFzeW5jIHVwZGF0ZVVzZXJMYW5ndWFnZSh1c2VySWQ6IHN0cmluZywgbGFuZ3VhZ2U6ICdwbCcgfCAnZW4nIHwgJ3NrJykge1xyXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgLnVwZGF0ZSh7IGxhbmd1YWdlIH0pXHJcbiAgICAgIC5lcSgnaWQnLCB1c2VySWQpXHJcbiAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAuc2luZ2xlKClcclxuICAgIFxyXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgcmV0dXJuIGRhdGEgYXMgVXNlclxyXG4gIH0sXHJcblxyXG4gIC8vIEJlenBpZWN6bmUgcG9iaWVyYW5pZSB1xbx5dGtvd25pa8OzdyBkbyB3ecWbd2lldGxhbmlhIChvZHBvcm5lIG5hIFJMUylcclxuICBhc3luYyBnZXRBbGxVc2Vyc0ZvckRpc3BsYXkoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+RpSBnZXRBbGxVc2Vyc0ZvckRpc3BsYXkgU1RBUlQgLSBiZXpwaWVjem5lIHBvYmllcmFuaWUuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gU3ByYXdkxbogYWt0dWFsbmVnbyB1xbx5dGtvd25pa2FcclxuICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaQgQWt0dWFsbnkgdcW8eXRrb3duaWs6JywgdXNlcj8uZW1haWwsIHVzZXI/LmlkKVxyXG4gICAgICBcclxuICAgICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KdjCBCcmFrIHphbG9nb3dhbmVnbyB1xbx5dGtvd25pa2EnKVxyXG4gICAgICAgIHJldHVybiBbXVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIGZ1bGxfbmFtZSwgZW1haWwsIHJvbGUsIGF2YXRhcl91cmwnKVxyXG4gICAgICAgIC5vcmRlcignZnVsbF9uYW1lJylcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5GlIGdldEFsbFVzZXJzRm9yRGlzcGxheSAtIHpuYWxlemlvbm8gdcW8eXRrb3duaWvDs3c6JywgZGF0YT8ubGVuZ3RoIHx8IDApXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUkxTIEVycm9yIGluIGdldEFsbFVzZXJzRm9yRGlzcGxheTonLCBlcnJvcilcclxuICAgICAgICBcclxuICAgICAgICAvLyBKZcWbbGkgdG8gcHJvYmxlbSB6IFJMUywgendyw7PEhyBwcnp5bmFqbW5pZWogYWt0dWFsbmVnbyB1xbx5dGtvd25pa2FcclxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1BHUlNUMTE2JyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnUkxTJykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign8J+UkiBSTFMgYmxva3VqZSBkb3N0xJlwIC0gendyYWNhbSB0eWxrbyBha3R1YWxuZWdvIHXFvHl0a293bmlrYScpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFBvYmllcnogcHJvZmlsIGFrdHVhbG5lZ28gdcW8eXRrb3duaWthXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZSA9IGF3YWl0IHRoaXMuZ2V0VXNlclByb2ZpbGUodXNlci5pZClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfkaQgRmFsbGJhY2s6IHXFvHl3YW0gcHJvZmlsdSBha3R1YWxuZWdvIHXFvHl0a293bmlrYTonLCB1c2VyUHJvZmlsZS5mdWxsX25hbWUpXHJcbiAgICAgICAgICAgIHJldHVybiBbdXNlclByb2ZpbGVdXHJcbiAgICAgICAgICB9IGNhdGNoIChwcm9maWxlRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE5pZSBtb8W8bmEgcG9icmHEhyBwcm9maWx1IHXFvHl0a293bmlrYTonLCBwcm9maWxlRXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVybiBbXVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJbm55IGLFgsSFZCAtIHp3csOzxIcgcHVzdMSFIHRhYmxpY8SZXHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIElubnkgYsWCxIVkIC0gendyYWNhbSBwdXN0xIUgdGFibGljxJknKVxyXG4gICAgICAgIHJldHVybiBbXVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+RpSBVZGFuZSBwb2JyYW5pZSB1xbx5dGtvd25pa8OzdzonLCBkYXRhLmxlbmd0aClcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+RpSBQcnp5a8WCYWQgdcW8eXRrb3duaWvDs3c6JywgZGF0YS5zbGljZSgwLCAzKS5tYXAodSA9PiAoe1xyXG4gICAgICAgICAgaWQ6IHUuaWQsXHJcbiAgICAgICAgICBuYW1lOiB1LmZ1bGxfbmFtZSxcclxuICAgICAgICAgIHJvbGU6IHUucm9sZVxyXG4gICAgICAgIH0pKSlcclxuICAgICAgICByZXR1cm4gZGF0YSBhcyBVc2VyW11cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+RpSBVV0FHQTogQnJhayBkYW55Y2ggdcW8eXRrb3duaWvDs3cnKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZhbGxiYWNrIC0gcHJ6eW5ham1uaWVqIGFrdHVhbG55IHXFvHl0a293bmlrXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHVzZXJQcm9maWxlID0gYXdhaXQgdGhpcy5nZXRVc2VyUHJvZmlsZSh1c2VyLmlkKVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkaQgRmFsbGJhY2s6IHXFvHl3YW0gcHJvZmlsdSBha3R1YWxuZWdvIHXFvHl0a293bmlrYTonLCB1c2VyUHJvZmlsZS5mdWxsX25hbWUpXHJcbiAgICAgICAgICByZXR1cm4gW3VzZXJQcm9maWxlXVxyXG4gICAgICAgIH0gY2F0Y2ggKHByb2ZpbGVFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE5pZSBtb8W8bmEgcG9icmHEhyBwcm9maWx1IHXFvHl0a293bmlrYTonLCBwcm9maWxlRXJyb3IpXHJcbiAgICAgICAgICByZXR1cm4gW11cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0QWxsVXNlcnNGb3JEaXNwbGF5IENSSVRJQ0FMIEVSUk9SOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgLy8gS3J5dHljem55IGZhbGxiYWNrIC0gc3Byw7NidWogcHJ6eW5ham1uaWVqIHBvYnJhxIcgYWt0dWFsbmVnbyB1xbx5dGtvd25pa2FcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKVxyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZSA9IGF3YWl0IHRoaXMuZ2V0VXNlclByb2ZpbGUodXNlci5pZClcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5GkIEtyeXR5Y3pueSBmYWxsYmFjazogendyYWNhbSBha3R1YWxuZWdvIHXFvHl0a293bmlrYTonLCB1c2VyUHJvZmlsZS5mdWxsX25hbWUpXHJcbiAgICAgICAgICByZXR1cm4gW3VzZXJQcm9maWxlXVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoY3JpdGljYWxFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBLcnl0eWN6bnkgYsWCxIVkIGZhbGxiYWNrOicsIGNyaXRpY2FsRXJyb3IpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gRnVua2NqYSBkbyBva3JlxZtsYW5pYSBrb2xvcnUgc3RhdHVzdSBcImNhbnZhc1wiIG5hIHBvZHN0YXdpZSBjemFzdVxyXG5leHBvcnQgY29uc3QgZ2V0Q2FudmFzU3RhdHVzQ29sb3IgPSAoc3RhdHVzQ2hhbmdlZEF0Pzogc3RyaW5nKTogeyBjb2xvcjogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB9ID0+IHtcclxuICBpZiAoIXN0YXR1c0NoYW5nZWRBdCkge1xyXG4gICAgcmV0dXJuIHsgY29sb3I6ICdiZy1ibHVlLTUwMC8yMCB0ZXh0LWJsdWUtNDAwIGJvcmRlci1ibHVlLTUwMC8zMCcsIGRlc2NyaXB0aW9uOiAnTm93eScsIHByaW9yaXR5OiAnbG93JyB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXHJcbiAgY29uc3Qgc3RhdHVzRGF0ZSA9IG5ldyBEYXRlKHN0YXR1c0NoYW5nZWRBdClcclxuICBjb25zdCBkYXlzRGlmZiA9IE1hdGguZmxvb3IoKG5vdy5nZXRUaW1lKCkgLSBzdGF0dXNEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXHJcblxyXG4gIGlmIChkYXlzRGlmZiA8PSAyKSB7XHJcbiAgICAvLyAwLTIgZG5pIC0gemllbG9ueSAoxZt3aWXFvHkpXHJcbiAgICByZXR1cm4geyBcclxuICAgICAgY29sb3I6ICdiZy1ncmVlbi01MDAvMjAgdGV4dC1ncmVlbi00MDAgYm9yZGVyLWdyZWVuLTUwMC8zMCcsIFxyXG4gICAgICBkZXNjcmlwdGlvbjogYMWad2llxbx5ICgke2RheXNEaWZmfWQpYCxcclxuICAgICAgcHJpb3JpdHk6ICdsb3cnXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkYXlzRGlmZiA8PSA0KSB7XHJcbiAgICAvLyAyLTQgZG5pIC0gxbzDs8WCdHkgKHV3YWdhKVxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIGNvbG9yOiAnYmcteWVsbG93LTUwMC8yMCB0ZXh0LXllbGxvdy00MDAgYm9yZGVyLXllbGxvdy01MDAvMzAnLCBcclxuICAgICAgZGVzY3JpcHRpb246IGBXeW1hZ2EgdXdhZ2kgKCR7ZGF5c0RpZmZ9ZClgLFxyXG4gICAgICBwcmlvcml0eTogJ21lZGl1bSdcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gNSsgZG5pIC0gY3plcndvbnkgKHBpbG55KVxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIGNvbG9yOiAnYmctcmVkLTUwMC8yMCB0ZXh0LXJlZC00MDAgYm9yZGVyLXJlZC01MDAvMzAnLCBcclxuICAgICAgZGVzY3JpcHRpb246IGBQaWxueSAoJHtkYXlzRGlmZn1kKWAsXHJcbiAgICAgIHByaW9yaXR5OiAnaGlnaCdcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEZ1bmtjamEgZG8gcG9iaWVyYW5pYSBrbGllbnTDs3cgeiBvem5hY3plbmlhbWkgcHJpb3J5dGV0w7N3XHJcbmV4cG9ydCBjb25zdCBnZXRDYW52YXNDbGllbnRzV2l0aFByaW9yaXR5ID0gYXN5bmMgKHVzZXI6IFVzZXIpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IGNsaWVudHNBcGkuZ2V0Q2xpZW50cyh1c2VyKVxyXG4gICAgY29uc3QgY2FudmFzQ2xpZW50cyA9IGNsaWVudHMuZmlsdGVyKChjbGllbnQ6IGFueSkgPT4gY2xpZW50LnN0YXR1cyA9PT0gJ2NhbnZhcycpXHJcbiAgICBcclxuICAgIGNvbnN0IHByaW9yaXR5U3RhdHMgPSB7XHJcbiAgICAgIGhpZ2g6IDAsXHJcbiAgICAgIG1lZGl1bTogMCxcclxuICAgICAgbG93OiAwLFxyXG4gICAgICB0b3RhbDogY2FudmFzQ2xpZW50cy5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXNDbGllbnRzLmZvckVhY2goKGNsaWVudDogYW55KSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcHJpb3JpdHkgfSA9IGdldENhbnZhc1N0YXR1c0NvbG9yKGNsaWVudC5zdGF0dXNfY2hhbmdlZF9hdClcclxuICAgICAgcHJpb3JpdHlTdGF0c1twcmlvcml0eV0rK1xyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGllbnRzOiBjYW52YXNDbGllbnRzLFxyXG4gICAgICBzdGF0czogcHJpb3JpdHlTdGF0c1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdCxYLEhWQgcG9iaWVyYW5pYSBrbGllbnTDs3cgY2FudmFzOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIHsgY2xpZW50czogW10sIHN0YXRzOiB7IGhpZ2g6IDAsIG1lZGl1bTogMCwgbG93OiAwLCB0b3RhbDogMCB9IH1cclxuICB9XHJcbn0gXHJcblxyXG4vLyDwn5qAIE5PV0UgQVBJIFBFUkZPUk1BTkNFIC0gTWF0ZXJpYWxpem93YW5lIFdpZG9raSBpIE9wdHltYWxpemFjamVcclxuLy8gRG9kYW5lIHpnb2RuaWUgeiBJTlNUUlVLQ0pFX1BFUkZPUk1BTkNFX09QVElNSVpBVElPTlMubWRcclxuXHJcbmV4cG9ydCBjb25zdCBkYXNoYm9hcmRBcGkgPSB7XHJcbiAgLy8gWmFzdMSZcHVqZSB3b2xuZSB6YXB5dGFuaWEgZGFzaGJvYXJkIC0gdGVyYXogfjEwbXMgemFtaWFzdCB+MjAwbXNcclxuICBhc3luYyBnZXREYXNoYm9hcmRNZXRyaWNzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ+KaoSBQb2JpZXJhbmllIHN6eWJraWNoIG1ldHJ5ayBkYXNoYm9hcmQgeiBtYXRlcmlhbGl6b3dhbmVnbyB3aWRva3UuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdnZXRfZGFzaGJvYXJkX21ldHJpY3MnKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBtZXRyeWsgZGFzaGJvYXJkOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRGFzaGJvYXJkIG1ldHJpY3MgcG9icmFuZSB3IHRyeWJpZSBleHByZXNzOicsIGRhdGE/Lmxlbmd0aCB8fCAwLCAnbWV0cnlrJylcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXREYXNoYm9hcmRNZXRyaWNzIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBTcHJhd2R6ZW5pZSBjenkgbWF0ZXJpYWxpem93YW5lIHdpZG9raSBzxIUgxZt3aWXFvGVcclxuICBhc3luYyBjaGVja1ZpZXdGcmVzaG5lc3MoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTcHJhd2TFuiBjenkgdGFiZWxhIG12X2Rhc2hib2FyZF9zdW1tYXJ5IGlzdG5pZWplXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ212X2Rhc2hib2FyZF9zdW1tYXJ5JylcclxuICAgICAgICAuc2VsZWN0KCdsYXN0X3VwZGF0ZWQnKVxyXG4gICAgICAgIC5saW1pdCgxKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTWF0ZXJpYWxpemVkIHZpZXcgbXZfZGFzaGJvYXJkX3N1bW1hcnkgbmllIGlzdG5pZWplIGx1YiBicmFrIHVwcmF3bmllxYQ6JywgZXJyb3IpXHJcbiAgICAgICAgLy8gRmFsbGJhY2sgLSB1xbx5aiBha3R1YWxuZWdvIGN6YXN1XHJcbiAgICAgICAgcmV0dXJuIHsgXHJcbiAgICAgICAgICBsYXN0VXBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIFxyXG4gICAgICAgICAgbWludXRlc1NpbmNlVXBkYXRlOiAwLCBcclxuICAgICAgICAgIGlzU3RhbGU6IGZhbHNlIC8vIFphxYJvxbwgxbxlIGRhbmUgc8SFIMWbd2llxbxlIGplxZtsaSBuaWUgbWEgd2lkb2t1XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBsYXN0VXBkYXRlID0gbmV3IERhdGUoZGF0YS5sYXN0X3VwZGF0ZWQpXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcclxuICAgICAgY29uc3QgbWludXRlc1NpbmNlVXBkYXRlID0gTWF0aC5mbG9vcigobm93LmdldFRpbWUoKSAtIGxhc3RVcGRhdGUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBsYXN0VXBkYXRlOiBkYXRhLmxhc3RfdXBkYXRlZCxcclxuICAgICAgICBtaW51dGVzU2luY2VVcGRhdGUsXHJcbiAgICAgICAgaXNTdGFsZTogbWludXRlc1NpbmNlVXBkYXRlID4gMzAgLy8gVXpuYWogemEgbmllYWt0dWFsbmUgcG8gMzAgbWludXRhY2hcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBzcHJhd2R6YW5pYSDFm3dpZcW8b8WbY2kgd2lkb2vDs3c6JywgZXJyb3IpXHJcbiAgICAgIC8vIEdyYWNlZnVsIGZhbGxiYWNrXHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIGxhc3RVcGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgXHJcbiAgICAgICAgbWludXRlc1NpbmNlVXBkYXRlOiAwLCBcclxuICAgICAgICBpc1N0YWxlOiBmYWxzZSBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+agCBOT1dFIEZVTktDSkUgUEVSRk9STUFOQ0UgZG9kYW5lIGRvIGlzdG5pZWrEhWNlZ28gcmVwb3J0c0FwaVxyXG5cclxuZXhwb3J0IGNvbnN0IHRlYW1BcGkgPSB7XHJcbiAgLy8gU3p5YmtpIHByemVnbMSFZCBha3R5d25vxZtjaSB6ZXNwb8WCdVxyXG4gIGFzeW5jIGdldFRlYW1BY3Rpdml0eU92ZXJ2aWV3KCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfkaUgUG9iaWVyYW5pZSBwcnplZ2zEhWR1IGFrdHl3bm/Fm2NpIHplc3BvxYJ1ICh6b3B0eW1hbGl6b3dhbmUpLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ212X2FjdGl2aXR5X3N1bW1hcnknKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5pbigncm9sZScsIFsncHJhY293bmlrJywgJ21hbmFnZXInLCAncHJvamVjdF9tYW5hZ2VyJywgJ2p1bmlvcl9tYW5hZ2VyJywgJ3N6ZWYnXSlcclxuICAgICAgICAub3JkZXIoJ2FjdGl2aXRpZXNfMjRoJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgYWt0eXdub8WbY2kgemVzcG/FgnU6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYOKchSBBa3R5d25vxZvEhyB6ZXNwb8WCdSBwb2JyYW5hOiAke2RhdGE/Lmxlbmd0aCB8fCAwfSB1xbx5dGtvd25pa8Ozd2ApXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0VGVhbUFjdGl2aXR5T3ZlcnZpZXcgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFNwcmF3ZHplbmllIGFrdHl3bnljaCB1xbx5dGtvd25pa8OzdyB3IGN6YXNpZSByemVjenl3aXN0eW1cclxuICBhc3luYyBnZXRBY3RpdmVVc2Vyc05vdygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ212X2FjdGl2aXR5X3N1bW1hcnknKVxyXG4gICAgICAgIC5zZWxlY3QoJ3VzZXJfaWQsIGZ1bGxfbmFtZSwgYWN0aXZpdHlfc3RhdHVzLCBsYXN0X2FjdGl2aXR5JylcclxuICAgICAgICAuZXEoJ2FjdGl2aXR5X3N0YXR1cycsICdhY3RpdmUnKVxyXG4gICAgICAgIC5vcmRlcignbGFzdF9hY3Rpdml0eScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBnZXRBY3RpdmVVc2Vyc05vdyBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gU3RhdHlzdHlraSBwcm9kdWt0eXdub8WbY2kgemVzcG/FgnVcclxuICBhc3luYyBnZXRQcm9kdWN0aXZpdHlTdGF0cygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ212X2FjdGl2aXR5X3N1bW1hcnknKVxyXG4gICAgICAgIC5zZWxlY3QoJ2FjdGl2aXRpZXNfMjRoLCBhY3Rpdml0aWVzXzdkLCBwaG9uZV9jbGlja3MsIHN0YXR1c19jaGFuZ2VzJylcclxuICAgICAgICAuaW4oJ3JvbGUnLCBbJ3ByYWNvd25paycsICdtYW5hZ2VyJywgJ3Byb2plY3RfbWFuYWdlcicsICdqdW5pb3JfbWFuYWdlcicsICdzemVmJ10pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcbiAgICAgIFxyXG4gICAgICAvLyBPYmxpY3ogxZtyZWRuaWVcclxuICAgICAgY29uc3QgdG90YWxVc2VycyA9IGRhdGEubGVuZ3RoXHJcbiAgICAgIGNvbnN0IGF2Z0RhaWx5ID0gZGF0YS5yZWR1Y2UoKHN1bSwgdXNlcikgPT4gc3VtICsgdXNlci5hY3Rpdml0aWVzXzI0aCwgMCkgLyB0b3RhbFVzZXJzXHJcbiAgICAgIGNvbnN0IGF2Z1dlZWtseSA9IGRhdGEucmVkdWNlKChzdW0sIHVzZXIpID0+IHN1bSArIHVzZXIuYWN0aXZpdGllc183ZCwgMCkgLyB0b3RhbFVzZXJzXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsVXNlcnMsXHJcbiAgICAgICAgYXZnRGFpbHlBY3Rpdml0aWVzOiBNYXRoLnJvdW5kKGF2Z0RhaWx5KSxcclxuICAgICAgICBhdmdXZWVrbHlBY3Rpdml0aWVzOiBNYXRoLnJvdW5kKGF2Z1dlZWtseSksXHJcbiAgICAgICAgdG90YWxEYWlseUFjdGl2aXRpZXM6IGRhdGEucmVkdWNlKChzdW0sIHVzZXIpID0+IHN1bSArIHVzZXIuYWN0aXZpdGllc18yNGgsIDApLFxyXG4gICAgICAgIHRvdGFsV2Vla2x5QWN0aXZpdGllczogZGF0YS5yZWR1Y2UoKHN1bSwgdXNlcikgPT4gc3VtICsgdXNlci5hY3Rpdml0aWVzXzdkLCAwKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0UHJvZHVjdGl2aXR5U3RhdHMgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8g8J+UpyBQRVJGT1JNQU5DRSBNT05JVE9SSU5HIEFQSVxyXG5leHBvcnQgY29uc3QgcGVyZm9ybWFuY2VBcGkgPSB7XHJcbiAgLy8gU3ByYXdkemVuaWUgbWV0cnlrIHd5ZGFqbm/Fm2NpIHN5c3RlbXVcclxuICBhc3luYyBnZXRTeXN0ZW1NZXRyaWNzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gUG9iaWVyYW5pZSBtZXRyeWsgd3lkYWpub8WbY2kgc3lzdGVtdS4uLicpXHJcbiAgICAgIGNvbnN0IHRhYmxlU3RhdHMgPSBbXVxyXG4gICAgICBcclxuICAgICAgLy8gUG9tb2NuaWN6YSBmdW5rY2phIGRvIGJlenBpZWN6bmVnbyBwb2JpZXJhbmlhIHN0YXR5c3R5ayB0YWJlbGlcclxuICAgICAgY29uc3QgZ2V0VGFibGVTdGF0cyA9IGFzeW5jICh0YWJsZU5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB7IGNvdW50LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20odGFibGVOYW1lKVxyXG4gICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gTmllIG1vxbxuYSBwb2JyYcSHIHN0YXR5c3R5ayB0YWJlbGkgJHt0YWJsZU5hbWV9OmAsIGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRhYmxlX25hbWU6IHRhYmxlTmFtZSxcclxuICAgICAgICAgICAgcmVjb3JkX2NvdW50OiBjb3VudCB8fCAwLFxyXG4gICAgICAgICAgICB0YWJsZV9zaXplOiAnTi9BJywgLy8gVXByb3N6Y3plbmllIC0gcm96bWlhciBuaWUgamVzdCBrcnl0eWN6bnlcclxuICAgICAgICAgICAgbGFzdF91cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIELFgsSFZCB0YWJlbGkgJHt0YWJsZU5hbWV9OmAsIGVycilcclxuICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTcHJhd2TFuiBrYcW8ZMSFIHRhYmVsxJkgb2RkemllbG5pZVxyXG4gICAgICBjb25zdCB0YWJsZXMgPSBbJ2NsaWVudHMnLCAndXNlcnMnLCAnYWN0aXZpdHlfbG9ncycsICdhY3Rpdml0eV9sb2dzX2FyY2hpdmUnXVxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBnZXRUYWJsZVN0YXRzKHRhYmxlTmFtZSlcclxuICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgIHRhYmxlU3RhdHMucHVzaChzdGF0cylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEplxZtsaSBuaWUgdWRhxYJvIHNpxJkgcG9icmHEhyDFvGFkbnljaCBzdGF0eXN0eWssIHp3csOzxIcgcG9kc3Rhd293ZSBpbmZvcm1hY2plXHJcbiAgICAgIGlmICh0YWJsZVN0YXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5pZSB1ZGHFgm8gc2nEmSBwb2JyYcSHIHN0YXR5c3R5ayDFvGFkbmVqIHRhYmVsaSAtIHp3cmFjYW0gZGFuZSBwcnp5a8WCYWRvd2UnKVxyXG4gICAgICAgIHRhYmxlU3RhdHMucHVzaCh7XHJcbiAgICAgICAgICB0YWJsZV9uYW1lOiAnc3lzdGVtX2luZm8nLFxyXG4gICAgICAgICAgcmVjb3JkX2NvdW50OiAwLFxyXG4gICAgICAgICAgdGFibGVfc2l6ZTogJ0JyYWsgZG9zdMSZcHUnLFxyXG4gICAgICAgICAgbGFzdF91cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFBvYnJhbm8gc3RhdHlzdHlraSAke3RhYmxlU3RhdHMubGVuZ3RofSB0YWJlbGApXHJcbiAgICAgIHJldHVybiB0YWJsZVN0YXRzXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgZ2V0U3lzdGVtTWV0cmljcyBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICAvLyBHcmFjZWZ1bCBmYWxsYmFjayAtIHp3csOzxIcgcG9kc3Rhd293ZSBkYW5lIHphbWlhc3Qgcnp1Y2HEhyBixYLEhWRcclxuICAgICAgcmV0dXJuIFt7XHJcbiAgICAgICAgdGFibGVfbmFtZTogJ2Vycm9yX2ZhbGxiYWNrJyxcclxuICAgICAgICByZWNvcmRfY291bnQ6IDAsXHJcbiAgICAgICAgdGFibGVfc2l6ZTogJ0LFgsSFZCBwb8WCxIVjemVuaWEnLFxyXG4gICAgICAgIGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgIH1dXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gTWFudWFsbmUgb2TFm3dpZcW8ZW5pZSBtYXRlcmlhbGl6b3dhbnljaCB3aWRva8Ozd1xyXG4gIGFzeW5jIHJlZnJlc2hNYXRlcmlhbGl6ZWRWaWV3cygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIE1hbnVhbG5pZSBvZMWbd2llxbxhbSBtYXRlcmlhbGl6b3dhbmUgd2lkb2tpLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygncmVmcmVzaF9hbGxfbWF0ZXJpYWxpemVkX3ZpZXdzJylcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgV2lkb2tpIG9kxZt3aWXFvG9uZTonLCBkYXRhKVxyXG4gICAgICByZXR1cm4gZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIHJlZnJlc2hNYXRlcmlhbGl6ZWRWaWV3cyBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gQXJjaGl3aXphY2phIHN0YXJ5Y2ggbG9nw7N3XHJcbiAgYXN5bmMgYXJjaGl2ZU9sZExvZ3MoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpiBVcnVjaGFtaWFtIGFyY2hpd2l6YWNqxJkgc3RhcnljaCBsb2fDs3cuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdhcmNoaXZlX29sZF9hY3Rpdml0eV9sb2dzJylcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgWmFyY2hpd2l6b3dhbm8gJHtkYXRhfSBzdGFyeWNoIGxvZ8Ozd2ApXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgYXJjaGl2ZU9sZExvZ3MgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIE9wdHltYWxpemFjamEgYmF6eSBkYW55Y2hcclxuICBhc3luYyBvcHRpbWl6ZURhdGFiYXNlKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CfmoAgVXJ1Y2hhbWlhbSBvcHR5bWFsaXphY2rEmSBiYXp5IGRhbnljaC4uLicpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ29wdGltaXplX2RhdGFiYXNlX3BlcmZvcm1hbmNlJylcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQmF6YSBkYW55Y2ggem9wdHltYWxpem93YW5hOicsIGRhdGEpXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgb3B0aW1pemVEYXRhYmFzZSBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVtcGxveWVlQWN0aXZpdHlTdGF0cyB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHVzZXJfaWQ6IHN0cmluZ1xyXG4gIHBlcmlvZF90eXBlOiBzdHJpbmdcclxuICBwZXJpb2Rfc3RhcnQ6IHN0cmluZ1xyXG4gIHBlcmlvZF9lbmQ6IHN0cmluZ1xyXG4gIHRvdGFsX3dvcmtfbWludXRlczogbnVtYmVyXHJcbiAgYXZlcmFnZV9kYWlseV9taW51dGVzOiBudW1iZXJcclxuICBleHBlY3RlZF93b3JrX21pbnV0ZXM6IG51bWJlclxyXG4gIGVmZmljaWVuY3lfcGVyY2VudGFnZTogbnVtYmVyXHJcbiAgdG90YWxfYWN0aXZpdGllczogbnVtYmVyXHJcbiAgYXZlcmFnZV9kYWlseV9hY3Rpdml0aWVzOiBudW1iZXJcclxuICBkYXlzX3dvcmtlZDogbnVtYmVyXHJcbiAgZGF5c19hYnNlbnQ6IG51bWJlclxyXG4gIHVzZXI/OiB7XHJcbiAgICBpZDogc3RyaW5nXHJcbiAgICBmdWxsX25hbWU6IHN0cmluZ1xyXG4gICAgZW1haWw6IHN0cmluZ1xyXG4gICAgYXZhdGFyX3VybD86IHN0cmluZ1xyXG4gICAgcm9sZTogc3RyaW5nXHJcbiAgfVxyXG59IFxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBDQUxMUyBBUEkgLSBISVNUT1JJQSBQT8WBxIRDWkXFgyBURUxFRk9OSUNaTllDSFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhbGxSZWNvcmQge1xyXG4gIGlkOiBzdHJpbmdcclxuICBjbGllbnRfaWQ6IHN0cmluZ1xyXG4gIGNsaWVudF9uYW1lOiBzdHJpbmdcclxuICBjbGllbnRfY29tcGFueTogc3RyaW5nXHJcbiAgY2xpZW50X3Bob25lOiBzdHJpbmdcclxuICBjYWxsZWRfYnk6IHN0cmluZ1xyXG4gIGNhbGxlcl9uYW1lOiBzdHJpbmdcclxuICBjYWxsZXJfcm9sZTogc3RyaW5nXHJcbiAgY2FsbGVyX2F2YXRhcj86IHN0cmluZ1xyXG4gIGNhbGxfdGltZXN0YW1wOiBzdHJpbmdcclxuICBsb2NhdGlvbl9pZD86IHN0cmluZ1xyXG4gIGxvY2F0aW9uX25hbWU/OiBzdHJpbmdcclxuICBsb2NhdGlvbl9jb2RlPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbHNGaWx0ZXIge1xyXG4gIGxvY2F0aW9uSWQ/OiBzdHJpbmcgfCBudWxsXHJcbiAgdXNlcklkPzogc3RyaW5nXHJcbiAgc3RhcnREYXRlPzogc3RyaW5nXHJcbiAgZW5kRGF0ZT86IHN0cmluZ1xyXG4gIGxpbWl0PzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjYWxsc0FwaSA9IHtcclxuICAvKipcclxuICAgKiDwn5OeIFBPQklFUlogSElTVE9SScSYIFBPxYHEhENaRcWDXHJcbiAgICogXHJcbiAgICogUG9iaWVyYSBoaXN0b3JpxJkgcG/FgsSFY3plxYQgdGVsZWZvbmljem55Y2ggeiBhY3Rpdml0eV9sb2dzXHJcbiAgICogVXd6Z2zEmWRuaWEgdXByYXduaWVuaWEgdcW8eXRrb3duaWthOlxyXG4gICAqIC0gQWRtaW4vU3plZjogd3N6eXN0a2llIHBvxYLEhWN6ZW5pYSB6IHd5YnJhbmVnbyBrcmFqdVxyXG4gICAqIC0gUHJvamVjdCBNYW5hZ2VyL0p1bmlvciBNYW5hZ2VyOiB3c3p5c3RraWUgeiBpY2ggbG9rYWxpemFjamlcclxuICAgKiAtIFByYWNvd25pazogdHlsa28gc3dvamUgcG/FgsSFY3plbmlhXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q2FsbHModXNlcjogVXNlciwgZmlsdGVyOiBDYWxsc0ZpbHRlciA9IHt9KTogUHJvbWlzZTxDYWxsUmVjb3JkW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OeIFBvYmllcmFuaWUgaGlzdG9yaWkgcG/FgsSFY3plxYQuLi4nLCB7IHVzZXI6IHVzZXIucm9sZSwgZmlsdGVyIH0pXHJcblxyXG4gICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdhY3Rpdml0eV9sb2dzJylcclxuICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgY2xpZW50X2lkLFxyXG4gICAgICAgICAgY2hhbmdlZF9ieSxcclxuICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgIGNsaWVudHMhaW5uZXIgKFxyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgZmlyc3RfbmFtZSxcclxuICAgICAgICAgICAgbGFzdF9uYW1lLFxyXG4gICAgICAgICAgICBjb21wYW55X25hbWUsXHJcbiAgICAgICAgICAgIHBob25lLFxyXG4gICAgICAgICAgICBsb2NhdGlvbl9pZCxcclxuICAgICAgICAgICAgbG9jYXRpb246bG9jYXRpb25zIChcclxuICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgIGNvZGVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIGApXHJcbiAgICAgICAgLmVxKCdmaWVsZF9jaGFuZ2VkJywgJ2xhc3RfcGhvbmVfY2xpY2snKVxyXG4gICAgICAgIC5vcmRlcigndGltZXN0YW1wJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcbiAgICAgICAgLmxpbWl0KGZpbHRlci5saW1pdCB8fCAxMDApXHJcblxyXG4gICAgICAvLyBGaWx0cm93YW5pZSB3ZWTFgnVnIHVwcmF3bmllxYQgdcW8eXRrb3duaWthXHJcbiAgICAgIGlmICh1c2VyLnJvbGUgPT09ICdwcmFjb3duaWsnKSB7XHJcbiAgICAgICAgLy8gUHJhY293bmlrIHdpZHppIHR5bGtvIHN3b2plIHBvxYLEhWN6ZW5pYVxyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2NoYW5nZWRfYnknLCB1c2VyLmlkKVxyXG4gICAgICB9IGVsc2UgaWYgKFsnanVuaW9yX21hbmFnZXInLCAnbWFuYWdlcicsICdwcm9qZWN0X21hbmFnZXInXS5pbmNsdWRlcyh1c2VyLnJvbGUpKSB7XHJcbiAgICAgICAgLy8gTWVuZWTFvGVyb3dpZSB3aWR6xIUgcG/FgsSFY3plbmlhIHogaWNoIGxva2FsaXphY2ppXHJcbiAgICAgICAgaWYgKGZpbHRlci5sb2NhdGlvbklkKSB7XHJcbiAgICAgICAgICAvLyBKZcWbbGkgd3licmFubyBrb25rcmV0bsSFIGxva2FsaXphY2rEmSwgZmlsdHJ1aiBwbyBuaWVqXHJcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjbGllbnRzLmxvY2F0aW9uX2lkJywgZmlsdGVyLmxvY2F0aW9uSWQpXHJcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyLmxvY2F0aW9uX2lkKSB7XHJcbiAgICAgICAgICAvLyBKZcWbbGkgbmllIHd5YnJhbm8gbG9rYWxpemFjamksIHBva2HFvCB6IGxva2FsaXphY2ppIHXFvHl0a293bmlrYVxyXG4gICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnY2xpZW50cy5sb2NhdGlvbl9pZCcsIHVzZXIubG9jYXRpb25faWQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKFsnc3plZicsICdhZG1pbiddLmluY2x1ZGVzKHVzZXIucm9sZSkpIHtcclxuICAgICAgICAvLyBTemVmIGkgYWRtaW4gd2lkesSFIHdzenlzdGtvLCBvcGNqb25hbG5pZSBmaWx0cm93YW5lIHBvIGxva2FsaXphY2ppXHJcbiAgICAgICAgaWYgKGZpbHRlci5sb2NhdGlvbklkKSB7XHJcbiAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjbGllbnRzLmxvY2F0aW9uX2lkJywgZmlsdGVyLmxvY2F0aW9uSWQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEb2RhdGtvd2UgZmlsdHJ5IGN6YXNvd2VcclxuICAgICAgaWYgKGZpbHRlci5zdGFydERhdGUpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmd0ZSgndGltZXN0YW1wJywgZmlsdGVyLnN0YXJ0RGF0ZSlcclxuICAgICAgfVxyXG4gICAgICBpZiAoZmlsdGVyLmVuZERhdGUpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmx0ZSgndGltZXN0YW1wJywgZmlsdGVyLmVuZERhdGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHsgZGF0YTogY2FsbExvZ3MsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBwb2JpZXJhbmlhIHBvxYLEhWN6ZcWEOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghY2FsbExvZ3MgfHwgY2FsbExvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk54gQnJhayBwb8WCxIVjemXFhCBkbGEgcG9kYW55Y2gga3J5dGVyacOzdycpXHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBvYmllcnogaW5mb3JtYWNqZSBvIHXFvHl0a293bmlrYWNoIChkendvbmnEhWN5Y2gpXHJcbiAgICAgIGNvbnN0IGNhbGxlcklkcyA9IFsuLi5uZXcgU2V0KGNhbGxMb2dzLm1hcChsb2cgPT4gbG9nLmNoYW5nZWRfYnkpKV1cclxuICAgICAgY29uc3QgeyBkYXRhOiBjYWxsZXJzLCBlcnJvcjogY2FsbGVyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgLnNlbGVjdCgnaWQsIGZ1bGxfbmFtZSwgcm9sZSwgYXZhdGFyX3VybCcpXHJcbiAgICAgICAgLmluKCdpZCcsIGNhbGxlcklkcylcclxuXHJcbiAgICAgIGlmIChjYWxsZXJzRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgdcW8eXRrb3duaWvDs3c6JywgY2FsbGVyc0Vycm9yKVxyXG4gICAgICAgIC8vIEtvbnR5bnV1aiBiZXogc3pjemVnw7PFgsOzdyB1xbx5dGtvd25pa8Ozd1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdHfDs3J6IG1hcMSZIHXFvHl0a293bmlrw7N3XHJcbiAgICAgIGNvbnN0IGNhbGxlcnNNYXAgPSAoY2FsbGVycyB8fCBbXSkucmVkdWNlKChhY2MsIGNhbGxlcikgPT4ge1xyXG4gICAgICAgIGFjY1tjYWxsZXIuaWRdID0gY2FsbGVyXHJcbiAgICAgICAgcmV0dXJuIGFjY1xyXG4gICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxyXG5cclxuICAgICAgICAgICAgIC8vIFByemVrc3p0YcWCxIcgZGFuZSBuYSBmb3JtYXQgQ2FsbFJlY29yZFxyXG4gICAgICAgY29uc3QgY2FsbFJlY29yZHM6IENhbGxSZWNvcmRbXSA9IGNhbGxMb2dzLm1hcChsb2cgPT4ge1xyXG4gICAgICAgICBjb25zdCBjbGllbnQgPSBBcnJheS5pc0FycmF5KGxvZy5jbGllbnRzKSA/IGxvZy5jbGllbnRzWzBdIDogbG9nLmNsaWVudHNcclxuICAgICAgICAgY29uc3QgY2FsbGVyID0gY2FsbGVyc01hcFtsb2cuY2hhbmdlZF9ieV1cclxuICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBBcnJheS5pc0FycmF5KGNsaWVudD8ubG9jYXRpb24pID8gY2xpZW50LmxvY2F0aW9uWzBdIDogY2xpZW50Py5sb2NhdGlvblxyXG5cclxuICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICBpZDogbG9nLmlkLFxyXG4gICAgICAgICAgIGNsaWVudF9pZDogbG9nLmNsaWVudF9pZCxcclxuICAgICAgICAgICBjbGllbnRfbmFtZTogY2xpZW50ID8gYCR7Y2xpZW50LmZpcnN0X25hbWV9ICR7Y2xpZW50Lmxhc3RfbmFtZX1gLnRyaW0oKSA6ICdOaWV6bmFueSBrbGllbnQnLFxyXG4gICAgICAgICAgIGNsaWVudF9jb21wYW55OiBjbGllbnQ/LmNvbXBhbnlfbmFtZSB8fCAnQnJhayBpbmZvcm1hY2ppJyxcclxuICAgICAgICAgICBjbGllbnRfcGhvbmU6IGNsaWVudD8ucGhvbmUgfHwgJ0JyYWsgdGVsZWZvbnUnLFxyXG4gICAgICAgICAgIGNhbGxlZF9ieTogbG9nLmNoYW5nZWRfYnksXHJcbiAgICAgICAgICAgY2FsbGVyX25hbWU6IGNhbGxlcj8uZnVsbF9uYW1lIHx8ICdOaWV6bmFueSB1xbx5dGtvd25paycsXHJcbiAgICAgICAgICAgY2FsbGVyX3JvbGU6IGNhbGxlcj8ucm9sZSB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICAgY2FsbGVyX2F2YXRhcjogY2FsbGVyPy5hdmF0YXJfdXJsIHx8IG51bGwsXHJcbiAgICAgICAgICAgY2FsbF90aW1lc3RhbXA6IGxvZy50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgbG9jYXRpb25faWQ6IGNsaWVudD8ubG9jYXRpb25faWQgfHwgbnVsbCxcclxuICAgICAgICAgICBsb2NhdGlvbl9uYW1lOiBsb2NhdGlvbj8ubmFtZSB8fCBudWxsLFxyXG4gICAgICAgICAgIGxvY2F0aW9uX2NvZGU6IGxvY2F0aW9uPy5jb2RlIHx8IG51bGxcclxuICAgICAgICAgfVxyXG4gICAgICAgfSlcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9icmFubyAke2NhbGxSZWNvcmRzLmxlbmd0aH0gcmVrb3Jkw7N3IHBvxYLEhWN6ZcWEYClcclxuICAgICAgcmV0dXJuIGNhbGxSZWNvcmRzXHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IGNhbGxzQXBpLmdldENhbGxzOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIPCfk4ogUE9CSUVSWiBTVEFUWVNUWUtJIFBPxYHEhENaRcWDXHJcbiAgICogXHJcbiAgICogUG9iaWVyYSBzdGF0eXN0eWtpIHBvxYLEhWN6ZcWEIGRsYSB3eWJyYW5lZ28gb2tyZXN1XHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q2FsbHNTdGF0cyh1c2VyOiBVc2VyLCBmaWx0ZXI6IENhbGxzRmlsdGVyID0ge30pOiBQcm9taXNlPHtcclxuICAgIHRvdGFsQ2FsbHM6IG51bWJlclxyXG4gICAgY2FsbHNUb2RheTogbnVtYmVyXHJcbiAgICBjYWxsc1RoaXNXZWVrOiBudW1iZXJcclxuICAgIGNhbGxzVGhpc01vbnRoOiBudW1iZXJcclxuICAgIHRvcENhbGxlcnM6IEFycmF5PHsgbmFtZTogc3RyaW5nLCByb2xlOiBzdHJpbmcsIGNvdW50OiBudW1iZXIsIGF2YXRhcj86IHN0cmluZyB9PlxyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFBvYmllcmFuaWUgc3RhdHlzdHlrIHBvxYLEhWN6ZcWELi4uJylcclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcclxuICAgICAgY29uc3QgdG9kYXkgPSBub3cudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXHJcbiAgICAgIGNvbnN0IHdlZWtTdGFydCA9IG5ldyBEYXRlKG5vdy5zZXREYXRlKG5vdy5nZXREYXRlKCkgLSBub3cuZ2V0RGF5KCkpKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cclxuICAgICAgY29uc3QgbW9udGhTdGFydCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgMSkudG9JU09TdHJpbmcoKVxyXG5cclxuICAgICAgLy8gUG9iaWVyeiB3c3p5c3RraWUgcG/FgsSFY3plbmlhIHpnb2RuaWUgeiB1cHJhd25pZW5pYW1pXHJcbiAgICAgIGNvbnN0IGFsbENhbGxzID0gYXdhaXQgY2FsbHNBcGkuZ2V0Q2FsbHModXNlciwgeyAuLi5maWx0ZXIsIGxpbWl0OiAxMDAwIH0pXHJcblxyXG4gICAgICAvLyBabGljeiBzdGF0eXN0eWtpXHJcbiAgICAgIGNvbnN0IHRvdGFsQ2FsbHMgPSBhbGxDYWxscy5sZW5ndGhcclxuICAgICAgY29uc3QgY2FsbHNUb2RheSA9IGFsbENhbGxzLmZpbHRlcihjYWxsID0+IGNhbGwuY2FsbF90aW1lc3RhbXAuc3RhcnRzV2l0aCh0b2RheSkpLmxlbmd0aFxyXG4gICAgICBjb25zdCBjYWxsc1RoaXNXZWVrID0gYWxsQ2FsbHMuZmlsdGVyKGNhbGwgPT4gY2FsbC5jYWxsX3RpbWVzdGFtcCA+PSB3ZWVrU3RhcnQpLmxlbmd0aFxyXG4gICAgICBjb25zdCBjYWxsc1RoaXNNb250aCA9IGFsbENhbGxzLmZpbHRlcihjYWxsID0+IGNhbGwuY2FsbF90aW1lc3RhbXAgPj0gbW9udGhTdGFydCkubGVuZ3RoXHJcblxyXG4gICAgICAvLyBUb3AgZHp3b25pxIVjeVxyXG4gICAgICBjb25zdCBjYWxsZXJDb3VudHMgPSBhbGxDYWxscy5yZWR1Y2UoKGFjYywgY2FsbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGNhbGwuY2FsbGVkX2J5XHJcbiAgICAgICAgaWYgKCFhY2Nba2V5XSkge1xyXG4gICAgICAgICAgYWNjW2tleV0gPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGNhbGwuY2FsbGVyX25hbWUsXHJcbiAgICAgICAgICAgIHJvbGU6IGNhbGwuY2FsbGVyX3JvbGUsXHJcbiAgICAgICAgICAgIGF2YXRhcjogY2FsbC5jYWxsZXJfYXZhdGFyLFxyXG4gICAgICAgICAgICBjb3VudDogMFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhY2Nba2V5XS5jb3VudCsrXHJcbiAgICAgICAgcmV0dXJuIGFjY1xyXG4gICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCB7IG5hbWU6IHN0cmluZywgcm9sZTogc3RyaW5nLCBhdmF0YXI/OiBzdHJpbmcsIGNvdW50OiBudW1iZXIgfT4pXHJcblxyXG4gICAgICBjb25zdCB0b3BDYWxsZXJzID0gT2JqZWN0LnZhbHVlcyhjYWxsZXJDb3VudHMpXHJcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxyXG4gICAgICAgIC5zbGljZSgwLCA1KVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbENhbGxzLFxyXG4gICAgICAgIGNhbGxzVG9kYXksXHJcbiAgICAgICAgY2FsbHNUaGlzV2VlayxcclxuICAgICAgICBjYWxsc1RoaXNNb250aCxcclxuICAgICAgICB0b3BDYWxsZXJzXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgc3RhdHlzdHlrIHBvxYLEhWN6ZcWEOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsQ2FsbHM6IDAsXHJcbiAgICAgICAgY2FsbHNUb2RheTogMCxcclxuICAgICAgICBjYWxsc1RoaXNXZWVrOiAwLFxyXG4gICAgICAgIGNhbGxzVGhpc01vbnRoOiAwLFxyXG4gICAgICAgIHRvcENhbGxlcnM6IFtdXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIPCfk6EgTk9USUZJQ0FUSU9OUyBBUEkgLSBTeXN0ZW0gcG93aWFkb21pZcWEXHJcbmV4cG9ydCBjb25zdCBub3RpZmljYXRpb25zQXBpID0ge1xyXG4gIC8vIFBvYmllcnogcG93aWFkb21pZW5pYSBkbGEgdcW8eXRrb3duaWthXHJcbiAgYXN5bmMgZ2V0Tm90aWZpY2F0aW9ucyh1c2VyOiBVc2VyLCBvcHRpb25zPzoge1xyXG4gICAgdW5yZWFkT25seT86IGJvb2xlYW5cclxuICAgIGxpbWl0PzogbnVtYmVyXHJcbiAgICB0eXBlPzogTm90aWZpY2F0aW9uWyd0eXBlJ11cclxuICB9KTogUHJvbWlzZTxOb3RpZmljYXRpb25bXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnbm90aWZpY2F0aW9ucycpXHJcbiAgICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIHVzZXJfaWQsXHJcbiAgICAgICAgICBjbGllbnRfaWQsXHJcbiAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgcmVhZCxcclxuICAgICAgICAgIHVyZ2VudCxcclxuICAgICAgICAgIG1ldGFkYXRhLFxyXG4gICAgICAgICAgY3JlYXRlZF9hdCxcclxuICAgICAgICAgIGV4cGlyZXNfYXQsXHJcbiAgICAgICAgICBjbGllbnQ6Y2xpZW50cyAoXHJcbiAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICBmaXJzdF9uYW1lLFxyXG4gICAgICAgICAgICBsYXN0X25hbWUsXHJcbiAgICAgICAgICAgIGNvbXBhbnlfbmFtZVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIGApXHJcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcclxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgIC8vIEZpbHRydWogdHlsa28gbmllcHJ6ZWN6eXRhbmVcclxuICAgICAgaWYgKG9wdGlvbnM/LnVucmVhZE9ubHkpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdyZWFkJywgZmFsc2UpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbHRydWogcG8gdHlwaWVcclxuICAgICAgaWYgKG9wdGlvbnM/LnR5cGUpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCd0eXBlJywgb3B0aW9ucy50eXBlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMaW1pdFxyXG4gICAgICBpZiAob3B0aW9ucz8ubGltaXQpIHtcclxuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmxpbWl0KG9wdGlvbnMubGltaXQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHBvYmllcmFuaWEgcG93aWFkb21pZcWEOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKG5vdGlmaWNhdGlvbiA9PiAoe1xyXG4gICAgICAgIC4uLm5vdGlmaWNhdGlvbixcclxuICAgICAgICAvLyBQcnpla3N6dGHFgsSHIGRhbmUga2xpZW50YSB6IEpPSU5cclxuICAgICAgICBjbGllbnQ6IG5vdGlmaWNhdGlvbi5jbGllbnQgJiYgQXJyYXkuaXNBcnJheShub3RpZmljYXRpb24uY2xpZW50KSAmJiBub3RpZmljYXRpb24uY2xpZW50Lmxlbmd0aCA+IDBcclxuICAgICAgICAgID8gbm90aWZpY2F0aW9uLmNsaWVudFswXVxyXG4gICAgICAgICAgOiBub3RpZmljYXRpb24uY2xpZW50ICYmICFBcnJheS5pc0FycmF5KG5vdGlmaWNhdGlvbi5jbGllbnQpXHJcbiAgICAgICAgICA/IG5vdGlmaWNhdGlvbi5jbGllbnRcclxuICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgIH0pKSBhcyBOb3RpZmljYXRpb25bXVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBnZXROb3RpZmljYXRpb25zOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFBvYmllcnogbGljemLEmSBuaWVwcnplY3p5dGFueWNoIHBvd2lhZG9taWXFhFxyXG4gIGFzeW5jIGdldFVucmVhZENvdW50KHVzZXI6IFVzZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBjb3VudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ25vdGlmaWNhdGlvbnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXHJcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcclxuICAgICAgICAuZXEoJ3JlYWQnLCBmYWxzZSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBsaWN6YnkgbmllcHJ6ZWN6eXRhbnljaDonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY291bnQgfHwgMFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IGdldFVucmVhZENvdW50OicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gMFxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIE96bmFjeiBwb3dpYWRvbWllbmllIGpha28gcHJ6ZWN6eXRhbmVcclxuICBhc3luYyBtYXJrQXNSZWFkKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnbWFya19ub3RpZmljYXRpb25fYXNfcmVhZCcsIHtcclxuICAgICAgICBub3RpZmljYXRpb25faWQ6IG5vdGlmaWNhdGlvbklkXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIG96bmFjemFuaWEgamFrbyBwcnplY3p5dGFuZTonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IG1hcmtBc1JlYWQ6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gT3puYWN6IHdzenlzdGtpZSBwb3dpYWRvbWllbmlhIGpha28gcHJ6ZWN6eXRhbmVcclxuICBhc3luYyBtYXJrQWxsQXNSZWFkKHVzZXI6IFVzZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdtYXJrX2FsbF9ub3RpZmljYXRpb25zX2FzX3JlYWQnKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBvem5hY3phbmlhIHdzenlzdGtpY2ggamFrbyBwcnplY3p5dGFuZTonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YSB8fCAwXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHcgbWFya0FsbEFzUmVhZDonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBVdHfDs3J6IG5vd2UgcG93aWFkb21pZW5pZVxyXG4gIGFzeW5jIGNyZWF0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9taXQ8Tm90aWZpY2F0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRfYXQnPik6IFByb21pc2U8Tm90aWZpY2F0aW9uPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgICAuaW5zZXJ0KFtub3RpZmljYXRpb25dKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB0d29yemVuaWEgcG93aWFkb21pZW5pYTonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGF0YSBhcyBOb3RpZmljYXRpb25cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBjcmVhdGVOb3RpZmljYXRpb246JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gVXN1xYQgcG93aWFkb21pZW5pZVxyXG4gIGFzeW5jIGRlbGV0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgICAuZGVsZXRlKClcclxuICAgICAgICAuZXEoJ2lkJywgbm90aWZpY2F0aW9uSWQpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHVzdXdhbmlhIHBvd2lhZG9taWVuaWE6JywgZXJyb3IpXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBkZWxldGVOb3RpZmljYXRpb246JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gV3ljennFm8SHIHN0YXJlIHBvd2lhZG9taWVuaWFcclxuICBhc3luYyBjbGVhbnVwT2xkTm90aWZpY2F0aW9ucygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnY2xlYW51cF9vbGRfbm90aWZpY2F0aW9ucycpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIGN6eXN6Y3plbmlhIHN0YXJ5Y2ggcG93aWFkb21pZcWEOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHcgY2xlYW51cE9sZE5vdGlmaWNhdGlvbnM6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gUG9iaWVyeiBkemlzaWVqc3plIHByenlwb21uaWVuaWEgZGxhIGRhc2hib2FyZFxyXG4gIGFzeW5jIGdldFRvZGF5UmVtaW5kZXJzKHVzZXI6IFVzZXIpOiBQcm9taXNlPE5vdGlmaWNhdGlvbltdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXHJcblxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgICAuc2VsZWN0KGBcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgdXNlcl9pZCxcclxuICAgICAgICAgIGNsaWVudF9pZCxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICByZWFkLFxyXG4gICAgICAgICAgdXJnZW50LFxyXG4gICAgICAgICAgbWV0YWRhdGEsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICAgICAgZXhwaXJlc19hdCxcclxuICAgICAgICAgIGNsaWVudDpjbGllbnRzIChcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgIGZpcnN0X25hbWUsXHJcbiAgICAgICAgICAgIGxhc3RfbmFtZSxcclxuICAgICAgICAgICAgY29tcGFueV9uYW1lXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgYClcclxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxyXG4gICAgICAgIC5lcSgndHlwZScsICdyZW1pbmRlcicpXHJcbiAgICAgICAgLmd0ZSgnY3JlYXRlZF9hdCcsIGAke3RvZGF5fVQwMDowMDowMC4wMDBaYClcclxuICAgICAgICAubHQoJ2NyZWF0ZWRfYXQnLCBgJHt0b2RheX1UMjM6NTk6NTkuOTk5WmApXHJcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgcG9iaWVyYW5pYSBkemlzaWVqc3p5Y2ggcHJ6eXBvbW5pZcWEOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZGF0YSB8fCBbXSkubWFwKG5vdGlmaWNhdGlvbiA9PiAoe1xyXG4gICAgICAgIC4uLm5vdGlmaWNhdGlvbixcclxuICAgICAgICBjbGllbnQ6IG5vdGlmaWNhdGlvbi5jbGllbnQgJiYgQXJyYXkuaXNBcnJheShub3RpZmljYXRpb24uY2xpZW50KSAmJiBub3RpZmljYXRpb24uY2xpZW50Lmxlbmd0aCA+IDBcclxuICAgICAgICAgID8gbm90aWZpY2F0aW9uLmNsaWVudFswXVxyXG4gICAgICAgICAgOiBub3RpZmljYXRpb24uY2xpZW50ICYmICFBcnJheS5pc0FycmF5KG5vdGlmaWNhdGlvbi5jbGllbnQpXHJcbiAgICAgICAgICA/IG5vdGlmaWNhdGlvbi5jbGllbnRcclxuICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgIH0pKSBhcyBOb3RpZmljYXRpb25bXVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBCxYLEhWQgdyBnZXRUb2RheVJlbWluZGVyczonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gVXJ1Y2hvbSBmdW5rY2plIGdlbmVyb3dhbmlhIHBvd2lhZG9taWXFhCAoZG8gdGVzdG93YW5pYSlcclxuICBhc3luYyB0cmlnZ2VyUmVtaW5kZXJDaGVjaygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygnY3JlYXRlX3JlbWluZGVyX25vdGlmaWNhdGlvbnMnKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB1cnVjaGFtaWFuaWEgc3ByYXdkemFuaWEgcHJ6eXBvbW5pZcWEOicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHcgdHJpZ2dlclJlbWluZGVyQ2hlY2s6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgdHJpZ2dlckFudGlzYWxlQ2hlY2soKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ2NyZWF0ZV9hbnR5c2FsZV93YXJuaW5ncycpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHVydWNoYW1pYW5pYSBzcHJhd2R6YW5pYSBhbnR5c2FsZTonLCBlcnJvcilcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCB3IHRyaWdnZXJBbnRpc2FsZUNoZWNrOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIFN1YnNrcnlwY2phIG5hIHJlYWwtdGltZSBwb3dpYWRvbWllbmlhXHJcbiAgc3Vic2NyaWJlVG9Ob3RpZmljYXRpb25zKHVzZXJJZDogc3RyaW5nLCBjYWxsYmFjazogKG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uKSA9PiB2b2lkKSB7XHJcbiAgICByZXR1cm4gc3VwYWJhc2VcclxuICAgICAgLmNoYW5uZWwoYG5vdGlmaWNhdGlvbnNfJHt1c2VySWR9YClcclxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgXHJcbiAgICAgICAgeyBcclxuICAgICAgICAgIGV2ZW50OiAnSU5TRVJUJywgXHJcbiAgICAgICAgICBzY2hlbWE6ICdwdWJsaWMnLCBcclxuICAgICAgICAgIHRhYmxlOiAnbm90aWZpY2F0aW9ucycsXHJcbiAgICAgICAgICBmaWx0ZXI6IGB1c2VyX2lkPWVxLiR7dXNlcklkfWBcclxuICAgICAgICB9LCBcclxuICAgICAgICAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgICAgY2FsbGJhY2socGF5bG9hZC5uZXcgYXMgTm90aWZpY2F0aW9uKVxyXG4gICAgICAgIH1cclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKClcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImdldEF2YXRhclVybCIsImF2YXRhclVybCIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImRhdGEiLCJzdG9yYWdlIiwiZnJvbSIsImdldFB1YmxpY1VybCIsInB1YmxpY1VybCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJzdG9yYWdlQXBpIiwidXBsb2FkQ1NWIiwiZmlsZSIsInVzZXIiLCJjbGVhbkZpbGVOYW1lIiwibmFtZSIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImZpbGVOYW1lIiwiRGF0ZSIsImlkIiwibm93IiwiZmlsZVBhdGgiLCJsb2ciLCJ1cGxvYWQiLCJjYWNoZUNvbnRyb2wiLCJ1cHNlcnQiLCJFcnJvciIsIm1lc3NhZ2UiLCJwYXRoIiwiZGVsZXRlRmlsZSIsInJlbW92ZSIsImNzdkltcG9ydEFwaSIsInBhcnNlQ1NWIiwiY3N2VGV4dCIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwidHJpbSIsImxlbmd0aCIsInBhcnNlQ1NWTGluZSIsInJlc3VsdCIsImN1cnJlbnQiLCJpblF1b3RlcyIsImkiLCJjaGFyIiwicHVzaCIsIm1hcCIsImNlbGwiLCJoZWFkZXJzIiwicm93cyIsInNsaWNlIiwibWFwSGVhZGVycyIsIm1hcHBpbmciLCJmaWVsZE1hcHBpbmdzIiwiZmllbGRzIiwiZGJGaWVsZCIsImZpZWxkTWFwcGluZyIsImhlYWRlciIsInNvbWUiLCJmaWVsZCIsInZhbGlkYXRlUmVxdWlyZWRGaWVsZHMiLCJyZXF1aXJlZEZpZWxkcyIsIm1pc3NpbmdGaWVsZHMiLCJqb2luIiwiYW5hbHl6ZUNvbHVtbnMiLCJhbGxQb3NzaWJsZUZpZWxkcyIsImRpc3BsYXlOYW1lIiwicmVxdWlyZWQiLCJmb3VuZCIsIm1pc3NpbmciLCJvcHRpb25hbCIsImZvckVhY2giLCJyb3dUb0NsaWVudCIsInJvdyIsImxvY2F0aW9uSWQiLCJnZXRGaWVsZCIsImRlZmF1bHRWYWx1ZSIsImluZGV4IiwidW5kZWZpbmVkIiwidmFsdWUiLCJyYXdTdGF0dXMiLCJ2YWxpZFN0YXR1c2VzIiwic3RhdHVzIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImNvbXBhbnlfbmFtZSIsIm5pcCIsInBob25lIiwiZW1haWwiLCJ3ZWJzaXRlIiwibm90ZXMiLCJlZGl0ZWRfYnkiLCJlZGl0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsIm93bmVyX2lkIiwibG9jYXRpb25faWQiLCJsYXN0X2VkaXRlZF9ieV9uYW1lIiwiZnVsbF9uYW1lIiwibGFzdF9lZGl0ZWRfYnlfYXZhdGFyX3VybCIsImF2YXRhcl91cmwiLCJpbXBvcnRDU1YiLCJvblByb2dyZXNzIiwidG90YWwiLCJ0ZXh0IiwiY29sdW1uQW5hbHlzaXMiLCJyZXN1bHRzIiwic3VjY2VzcyIsImVycm9ycyIsImV2ZXJ5IiwiY2xpZW50RGF0YSIsImNsaWVudHNBcGkiLCJwcm9ncmVzcyIsIk1hdGgiLCJmbG9vciIsInBlcm1pc3Npb25zQXBpIiwiY2FuVmlldyIsImNsaWVudCIsInJvbGUiLCJzYW1lTG9jYXRpb24iLCJjYW5FZGl0IiwiY2FuRGVsZXRlIiwiY2FuQXNzaWduQ2xpZW50cyIsImNhbkNoYW5nZVJvbGVzIiwiY2FuQWNjZXNzQWR2YW5jZWRSZXBvcnRzIiwiY2FuVmlld0FsbExvY2F0aW9ucyIsImNhbkZpbHRlckJ5TG9jYXRpb24iLCJjYW5NYW5hZ2VVc2VyIiwidXNlcjEiLCJ1c2VyMiIsImhpZ2hlckluSGllcmFyY2h5Iiwicm9sZV9oaWVyYXJjaHlfbGV2ZWwiLCJ0ZXN0QmFzaWNRdWVyeSIsInNlbGVjdCIsImxpbWl0IiwiZ2V0Q2xpZW50c1BhZ2luYXRlZCIsImZpbHRlcnMiLCJxdWVyeSIsImNvdW50Iiwic29ydEZpZWxkIiwic29ydEJ5IiwiaXNBc2NlbmRpbmciLCJzb3J0RGlyZWN0aW9uIiwib3JkZXIiLCJhc2NlbmRpbmciLCJkYXRlIiwiZ3RlIiwiZXEiLCJlbXBsb3llZSIsInNlYXJjaCIsInNlYXJjaFRlcm0iLCJvciIsImxvY2F0aW9uIiwicGFnZSIsInBhZ2VTaXplIiwidG8iLCJyYW5nZSIsImNsaWVudHMiLCJ0cmFuc2Zvcm1lZENsaWVudHMiLCJvd25lciIsIkFycmF5IiwiaXNBcnJheSIsImNsaWVudHNXaXRoT3duZXJzIiwiY2xpZW50c1dpdGhvdXRPd25lcnMiLCJvd25lcl9uYW1lIiwib3duZXJfZW1haWwiLCJnZXRDbGllbnRzIiwic2FmZVN0YXR1cyIsImNsaWVudFRvQ3JlYXRlIiwic3RhdHVzX2NoYW5nZWRfYXQiLCJyZW1pbmRlciIsImluc2VydCIsInNpbmdsZSIsInVwZGF0ZUNsaWVudCIsInVwZGF0ZXMiLCJjdXJyZW50Q2xpZW50IiwiZmV0Y2hFcnJvciIsInVwZGF0ZWREYXRhIiwic3RhdHVzQ2hhbmdlZCIsImZpbmFsRGF0YSIsInVwZGF0ZWRfYXQiLCJ1cGRhdGUiLCJjb2RlIiwiZGV0YWlscyIsImhpbnQiLCJ1cGRhdGVMYXN0UGhvbmVDbGljayIsImNsaWVudElkIiwibGFzdF9waG9uZV9jbGljayIsImFjdGl2aXR5TG9nc0FwaSIsImNyZWF0ZUxvZyIsImNsaWVudF9pZCIsImNoYW5nZWRfYnkiLCJjaGFuZ2VfdHlwZSIsImZpZWxkX2NoYW5nZWQiLCJvbGRfdmFsdWUiLCJuZXdfdmFsdWUiLCJsb2dFcnJvciIsImRlbGV0ZUNsaWVudCIsImRlbGV0ZSIsImFzc2lnbkNsaWVudCIsIm5ld093bmVySWQiLCJjbGVhbnVwSW52YWxpZE93bmVySWRzIiwiYWxsQ2xpZW50cyIsImNsaWVudHNFcnJvciIsIm5vdCIsImNsZWFuZWQiLCJvd25lcklkcyIsIlNldCIsImMiLCJleGlzdGluZ1VzZXJzIiwidXNlcnNFcnJvciIsImluIiwiZXhpc3RpbmdVc2VySWRzIiwidSIsImNsaWVudHNUb0NsZWFuIiwiY2xlYW51cFJlc3VsdHMiLCJlcnIiLCJTdHJpbmciLCJjbGVhbmVkQ2xpZW50cyIsInN1YnNjcmliZVRvQ2hhbmdlcyIsImNhbGxiYWNrIiwiY2hhbm5lbCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInN1YnNjcmliZSIsInN1YnNjcmliZVRvT3duZXJDaGFuZ2VzIiwiY2hhbm5lbE5hbWUiLCJwYXlsb2FkIiwiZXZlbnRUeXBlIiwiY2hhbmdlcyIsIm5ldyIsImNhbGxiYWNrRXJyb3IiLCJzZXRUaW1lb3V0Iiwic3RhdGUiLCJ1bnN1YnNjcmliZSIsImdldENsaWVudHNXaXRoUmVtaW5kZXJzIiwidGFyZ2V0RGF0ZSIsInRvZGF5IiwiY2xpZW50c1dpdGhUb2RheVJlbWluZGVycyIsImVuYWJsZWQiLCJ0aW1lIiwibm90ZSIsInNvcnRlZENsaWVudHMiLCJzb3J0IiwiYSIsImIiLCJ0aW1lQSIsInRpbWVCIiwibG9jYWxlQ29tcGFyZSIsImdldERhaWx5U2NoZWR1bGVXaXRoQ2xpZW50cyIsImNsaWVudHNXaXRoUmVtaW5kZXJzIiwidGltZVNsb3RzIiwidHlwZSIsImNvbG9yIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInN0YXR1c2VzIiwic2xvdHNXaXRoQ2xpZW50cyIsInNsb3QiLCJzbG90Q2xpZW50cyIsInJlbWluZGVyVGltZSIsImhvdXJzIiwibWludXRlcyIsIk51bWJlciIsInJlbWluZGVyTWludXRlcyIsInN0YXJ0SG91cnMiLCJzdGFydE1pbnMiLCJlbmRIb3VycyIsImVuZE1pbnMiLCJzdGFydE1pbnV0ZXMiLCJlbmRNaW51dGVzIiwidGltZUluU2xvdCIsInJlZHVjZSIsInN1bSIsImdldExvZ3MiLCJnZXRDbGllbnRIaXN0b3J5IiwiYXV0aCIsImdldFVzZXIiLCJKU09OIiwic3RyaW5naWZ5IiwidXNlcklkcyIsIkJvb2xlYW4iLCJ1c2VycyIsInVzZXJzTWFwIiwiYWNjIiwidGltZXN0YW1wIiwiZWRpdG9yX25hbWUiLCJlZGl0b3Jfcm9sZSIsImVkaXRvcl9hdmF0YXIiLCJ0ZXN0QWN0aXZpdHlMb2dzQWNjZXNzIiwidXNlclByb2ZpbGUiLCJ1c2VyRXJyb3IiLCJyZXBvcnRzQXBpIiwiZ2V0RW1wbG95ZWVTdGF0cyIsImFsbEVtcGxveWVlcyIsImUiLCJlbXBsb3llZUlkcyIsImVtcCIsImV4aXN0aW5nU3RhdHMiLCJzdGF0c0Vycm9yIiwidG9kYXlDbGllbnRzIiwibHQiLCJ5ZXN0ZXJkYXkiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInllc3RlcmRheVN0ciIsInllc3RlcmRheUNsaWVudHMiLCJ5ZXN0ZXJkYXlFcnJvciIsImFsbE93bmVkQ2xpZW50cyIsIm93bmVkRXJyb3IiLCJ0b2RheVN0YXRzIiwidXNlcklkIiwiY2FudmFzIiwiYW50eXNhbGUiLCJzYWxlIiwib3RoZXIiLCJ5ZXN0ZXJkYXlTdGF0cyIsIm93bmVkQ2xpZW50c1N0YXRzIiwib3duZXJJZCIsImJyYWtfa29udGFrdHUiLCJuaWVfemFpbnRlcmVzb3dhbnkiLCJ6ZGVuZXJ3b3dhbnkiLCJzdGF0c01hcCIsIk1hcCIsInN0YXQiLCJzZXQiLCJ1c2VyX2lkIiwiZW5oYW5jZWRTdGF0cyIsImJhc2ljU3RhdCIsImdldCIsImRhaWx5X3RhcmdldCIsImNvbW1pc3Npb25fcmF0ZSIsIm1vbnRobHlfY2FudmFzIiwibW9udGhseV9hbnR5c2FsZSIsIm1vbnRobHlfc2FsZSIsInRvdGFsX2NvbW1pc3Npb25zIiwidG90YWxfcGVuYWx0aWVzIiwiY3VzdG9tX2NsaWVudHNfY291bnQiLCJjdXN0b21fdG90YWxfcGF5bWVudHMiLCJjcmVhdGVkX2F0IiwidG9kYXlGb3JVc2VyIiwieWVzdGVyZGF5Rm9yVXNlciIsIm93bmVkRm9yVXNlciIsInllc3RlcmRheVNob3J0YWdlIiwibWF4IiwicGVuYWx0eSIsImNvbW1pc3Npb24iLCJkYWlseV9hY2hpZXZlZCIsInllc3RlcmRheV9zaG9ydGFnZSIsInN0YXR1c19jaGFuZ2VzX3RvZGF5IiwicyIsImdldERhaWx5U3VtbWFyeSIsInN0YXR1c0JyZWFrZG93biIsImVtcGxveWVlU3RhdHMiLCJ0b3RhbENsaWVudHMiLCJnZXRXZWVrbHlTdW1tYXJ5Iiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInVwZGF0ZUVtcGxveWVlU3RhdHMiLCJjdXJyZW50VXNlciIsInVwZGF0ZUVtcGxveWVlQ2xpZW50U3RhdHMiLCJjbGllbnRzQ291bnQiLCJ0b3RhbFBheW1lbnRzIiwibGVnYWN5VXBkYXRlcyIsIm1ldGhvZDFFcnJvciIsImluc2VydERhdGEiLCJvbkNvbmZsaWN0IiwiaWdub3JlRHVwbGljYXRlcyIsIm1ldGhvZDJFcnJvciIsImNyZWF0ZUVtcGxveWVlU3RhdHMiLCJnZXREYXRhYmFzZVV0aWxpemF0aW9uIiwidG90YWxDb3VudCIsInRvdGFsRXJyb3IiLCJoZWFkIiwid2l0aE93bmVyQ291bnQiLCJ3aXRoT3duZXJFcnJvciIsIndpdGhvdXRPd25lckNvdW50IiwidXRpbGl6YXRpb25QZXJjZW50YWdlIiwicm91bmQiLCJ3aXRoT3duZXIiLCJ3aXRob3V0T3duZXIiLCJyZXNldEFsbENsaWVudE93bmVycyIsImJlZm9yZUNvdW50IiwiYmVmb3JlRXJyb3IiLCJyZXNldENvdW50IiwiZ2V0RW1wbG95ZWVBY3Rpdml0eVN0YXRzIiwiZW1wbG95ZWVzIiwiYWN0aXZpdHlTdGF0cyIsInN0YXRzIiwibGF0ZXN0U3RhdHNNYXAiLCJoYXMiLCJzaXplIiwiYWN0aXZpdHlTdGF0IiwiY3VycmVudERhdGUiLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aFN0YXJ0IiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1vbnRoRW5kIiwicGVyaW9kX3R5cGUiLCJwZXJpb2Rfc3RhcnQiLCJwZXJpb2RfZW5kIiwidG90YWxfd29ya19taW51dGVzIiwiYXZlcmFnZV9kYWlseV9taW51dGVzIiwiZXhwZWN0ZWRfd29ya19taW51dGVzIiwiZWZmaWNpZW5jeV9wZXJjZW50YWdlIiwidG90YWxfYWN0aXZpdGllcyIsImF2ZXJhZ2VfZGFpbHlfYWN0aXZpdGllcyIsImRheXNfd29ya2VkIiwiZGF5c19hYnNlbnQiLCJ3aXRoRGF0YSIsInIiLCJ3aXRob3V0RGF0YSIsImdldFNhbGVzVHJlbmRzIiwibHRlIiwiZmlsdGVyZWREYXRhIiwiZGF5TmFtZXMiLCJ0cmVuZHMiLCJkYXlOYW1lIiwiZ2V0RGF5IiwiZGF5IiwiZ2V0UGhvbmVDbGlja3NTdGF0cyIsImVtcGxveWVlc0Vycm9yIiwidG90YWxQaG9uZUNhbGxzIiwidG90YWxQaG9uZUNhbGxzVG9kYXkiLCJhbGxQaG9uZUNsaWNrcyIsImFsbENsaWNrc0Vycm9yIiwidG9kYXlQaG9uZUNsaWNrcyIsInRvZGF5Q2xpY2tzRXJyb3IiLCJnZXRUZWFtUGVyZm9ybWFuY2VUcmVuZHMiLCJ0ZWxlZm9ueSIsImtvbndlcnNqYSIsImtsaWVuY2kiLCJwaG9uZUNsaWNrcyIsInBob25lRXJyb3IiLCJjbGllbnRDaGFuZ2VzIiwiY2hhbmdlc0Vycm9yIiwidHJlbmRzRGF0YSIsInNhbGVzIiwiY2xpY2siLCJjaGFuZ2UiLCJkYXlEYXRhIiwiZ2V0TXlQZXJzb25hbFN0YXRzIiwic3RhcnRPZk1vbnRoIiwiZW5kT2ZNb250aCIsInBob25lQ2FsbHNUaGlzTW9udGgiLCJteUNsaWVudHMiLCJzdGF0dXNNYXAiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInN0YXR1c0NvbG9ycyIsImNsaWVudFN0YXRzIiwiZW50cmllcyIsImNvbW1pc3Npb25Ub3RhbCIsImFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzRXJyb3IiLCJkYWlseUFjdGl2aXRpZXMiLCJhY3Rpdml0eSIsImhvdXIiLCJnZXRIb3VycyIsImFkZCIsIndvcmtpbmdIb3Vyc1RoaXNNb250aCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIndlZWtkYXkiLCJzb3J0RGF0ZSIsImdldFRpbWUiLCJ0b3RhbFdvcmtpbmdIb3VycyIsInZhbHVlcyIsInRvdGFsV29ya2luZ0RheXMiLCJzdGFjayIsInNhdmVXb3JraW5nSG91cnMiLCJkYXRlUGFydHMiLCJ5ZWFyIiwicGFyc2VJbnQiLCJtb250aCIsImRhdGVPYmoiLCJkYXlPZldlZWsiLCJ3b3JrX2RhdGUiLCJob3Vyc193b3JrZWQiLCJzdG9yYWdlS2V5IiwiZXhpc3RpbmdEYXRhIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInN0b3JhZ2VFcnJvciIsImdldFdvcmtpbmdIb3Vyc0Zvck1vbnRoIiwic3RvcmVkRGF0YSIsImhvdXJzTWFwIiwia2V5cyIsImVudHJ5Iiwic3RhcnREYXRlU3RyIiwiZW5kRGF0ZVN0ciIsImdldE1vbnRobHlFbXBsb3llZVBlcmZvcm1hbmNlIiwicnBjIiwidGFyZ2V0X3llYXIiLCJ0YXJnZXRfbW9udGgiLCJnZXRUZWFtU3VtbWFyeSIsImdldFRvcFBlcmZvcm1lcnMiLCJsaW1pdF9jb3VudCIsImxvY2F0aW9uc0FwaSIsImdldEFsbExvY2F0aW9ucyIsImdldEFsbExvY2F0aW9uc1dpdGhNYW5hZ2VycyIsInRyYW5zZm9ybWVkRGF0YSIsInByb2plY3RfbWFuYWdlciIsImdldFVzZXJBY2Nlc3NpYmxlTG9jYXRpb25zIiwibG9jYXRpb25FcnJvciIsImZhbGxiYWNrRXJyb3IiLCJnZXRMb2NhdGlvbkJ5SWQiLCJ1cGRhdGVMb2NhdGlvblByb2plY3RNYW5hZ2VyIiwicHJvamVjdE1hbmFnZXJJZCIsInByb2plY3RfbWFuYWdlcl9pZCIsImF1dGhBcGkiLCJzaWduSW4iLCJwYXNzd29yZCIsInNpZ25JbldpdGhQYXNzd29yZCIsInNpZ25VcCIsImZ1bGxOYW1lIiwib3B0aW9ucyIsInNpZ25PdXQiLCJnZXRDdXJyZW50VXNlciIsImdldFVzZXJQcm9maWxlIiwiZ2V0QWxsVXNlcnMiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwidXBkYXRlVXNlckxhbmd1YWdlIiwibGFuZ3VhZ2UiLCJnZXRBbGxVc2Vyc0ZvckRpc3BsYXkiLCJwcm9maWxlRXJyb3IiLCJjcml0aWNhbEVycm9yIiwiZ2V0Q2FudmFzU3RhdHVzQ29sb3IiLCJzdGF0dXNDaGFuZ2VkQXQiLCJkZXNjcmlwdGlvbiIsInByaW9yaXR5Iiwic3RhdHVzRGF0ZSIsImRheXNEaWZmIiwiZ2V0Q2FudmFzQ2xpZW50c1dpdGhQcmlvcml0eSIsImNhbnZhc0NsaWVudHMiLCJwcmlvcml0eVN0YXRzIiwiaGlnaCIsIm1lZGl1bSIsImxvdyIsImRhc2hib2FyZEFwaSIsImdldERhc2hib2FyZE1ldHJpY3MiLCJjaGVja1ZpZXdGcmVzaG5lc3MiLCJsYXN0VXBkYXRlIiwibWludXRlc1NpbmNlVXBkYXRlIiwiaXNTdGFsZSIsImxhc3RfdXBkYXRlZCIsInRlYW1BcGkiLCJnZXRUZWFtQWN0aXZpdHlPdmVydmlldyIsImdldEFjdGl2ZVVzZXJzTm93IiwiZ2V0UHJvZHVjdGl2aXR5U3RhdHMiLCJ0b3RhbFVzZXJzIiwiYXZnRGFpbHkiLCJhY3Rpdml0aWVzXzI0aCIsImF2Z1dlZWtseSIsImFjdGl2aXRpZXNfN2QiLCJhdmdEYWlseUFjdGl2aXRpZXMiLCJhdmdXZWVrbHlBY3Rpdml0aWVzIiwidG90YWxEYWlseUFjdGl2aXRpZXMiLCJ0b3RhbFdlZWtseUFjdGl2aXRpZXMiLCJwZXJmb3JtYW5jZUFwaSIsImdldFN5c3RlbU1ldHJpY3MiLCJ0YWJsZVN0YXRzIiwiZ2V0VGFibGVTdGF0cyIsInRhYmxlTmFtZSIsInRhYmxlX25hbWUiLCJyZWNvcmRfY291bnQiLCJ0YWJsZV9zaXplIiwidGFibGVzIiwicmVmcmVzaE1hdGVyaWFsaXplZFZpZXdzIiwiYXJjaGl2ZU9sZExvZ3MiLCJvcHRpbWl6ZURhdGFiYXNlIiwiY2FsbHNBcGkiLCJnZXRDYWxscyIsImNhbGxMb2dzIiwiY2FsbGVySWRzIiwiY2FsbGVycyIsImNhbGxlcnNFcnJvciIsImNhbGxlcnNNYXAiLCJjYWxsZXIiLCJjYWxsUmVjb3JkcyIsImNsaWVudF9uYW1lIiwiY2xpZW50X2NvbXBhbnkiLCJjbGllbnRfcGhvbmUiLCJjYWxsZWRfYnkiLCJjYWxsZXJfbmFtZSIsImNhbGxlcl9yb2xlIiwiY2FsbGVyX2F2YXRhciIsImNhbGxfdGltZXN0YW1wIiwibG9jYXRpb25fbmFtZSIsImxvY2F0aW9uX2NvZGUiLCJnZXRDYWxsc1N0YXRzIiwid2Vla1N0YXJ0IiwiYWxsQ2FsbHMiLCJ0b3RhbENhbGxzIiwiY2FsbHNUb2RheSIsImNhbGwiLCJjYWxsc1RoaXNXZWVrIiwiY2FsbHNUaGlzTW9udGgiLCJjYWxsZXJDb3VudHMiLCJrZXkiLCJhdmF0YXIiLCJ0b3BDYWxsZXJzIiwibm90aWZpY2F0aW9uc0FwaSIsImdldE5vdGlmaWNhdGlvbnMiLCJ1bnJlYWRPbmx5Iiwibm90aWZpY2F0aW9uIiwiZ2V0VW5yZWFkQ291bnQiLCJtYXJrQXNSZWFkIiwibm90aWZpY2F0aW9uSWQiLCJub3RpZmljYXRpb25faWQiLCJtYXJrQWxsQXNSZWFkIiwiY3JlYXRlTm90aWZpY2F0aW9uIiwiZGVsZXRlTm90aWZpY2F0aW9uIiwiY2xlYW51cE9sZE5vdGlmaWNhdGlvbnMiLCJnZXRUb2RheVJlbWluZGVycyIsInRyaWdnZXJSZW1pbmRlckNoZWNrIiwidHJpZ2dlckFudGlzYWxlQ2hlY2siLCJzdWJzY3JpYmVUb05vdGlmaWNhdGlvbnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.ts\n"));

/***/ })

});